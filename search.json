[{"title":"Hello World","url":"/2021/12/22/hello-world/","content":"\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!--more--> \n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","tags":["Hello Hexo"]},{"title":"JVM学习笔记","url":"/2020/05/19/JVM学习笔记/","content":"\nJVM体系结构概览\n<!-- more-->\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/72785FD91D514ADDB0134D43276ED7E5/389)\n\n\n### 类加载器（Class loader）：\n\n负责加载class文件，class文件在文件开头有特定的文件标示，将class文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构并且ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定 \n\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/3C474F1A64594F35B61AD0245184688F/391)\n\n---\n\n类加载器的分类：\n\n启动类加载器（Bootstrap）C++\n\n\n扩展类加载器（Extension）Java\n\n应用程序类加载器（AppClassLoader）Java也叫系统类加载器，加载当前应用的classpath的所有类\n\n用户自定义加载器  Java.lang.ClassLoader的子类，用户可以定制类的加载方式\n\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/BB4939364DEB41CD9BCF754F7F1EC00B/393)\n\n\n双亲委派机制：\n\n当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。 \n\n采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object对象。\n\n\n\n        Object o=new Object();\n\n         System.out.println(o.getClass().getClassLoader()); //输出null,因为这个类的加载器是 启动类加载器（启动类加载器（Bootstrap）C++）\n        // System.out.println(o.getClass().getClassLoader().getParent());  //会报空异常，启动类加载器已经是最顶层了。\n\n         MyObject myObject=new MyObject();\n         System.out.println(myObject.getClass().getClassLoader());\n         //输出sun.misc.Launcher$AppClassLoader@18b4aac2  应用程序类加载器\n         //sun.misc.Launcher 它是一个java虚拟机的入口应用\n\n        System.out.println(myObject.getClass().getClassLoader().getParent());  //输出sun.misc.Launcher$ExtClassLoader@1540e19d  应用程序类加载器的上一层就是ExtClassLoader\n        System.out.println(myObject.getClass().getClassLoader().getParent().getParent());  //null .启动类加载器\n---\nnative:是一个关键字，表示调用本地函数库，在本地方法栈中执行\n\n---\n pc寄存器：存储下一条指令的地址\n\n---\n\n ### 方法区：\n\n供各线程共享的运行时内存区域。它存储了每一个类的结构信息，例如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容。上面讲的是规范，在不同虚拟机里头实现是不一样的，最典型的就是永久代(PermGen space)和元空间(Metaspace)。\n\n\n空调 k=new 格力();//左边叫规范，右边叫实现\n\nList l=new ArrayList();\n\nf  =new 永久代；\nf  =new 元空间\n\n实例变量是存在堆中的，和方法区无关。\n\n注意：jdk6的Class实例存放在方法区中，jdk7和jdk8的Class实例存放在堆空间中\n\n\n### 栈\n\n栈也叫栈内存，主管Java程序的运行，是在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束该栈就Over，生命周期和线程一致，是线程私有的。8种基本类型的变量+对象的引用变量+实例方法都是在函数的栈内存中分配。\n\n\n栈存什么？ 8种基本数据类型，对象引用，实例方法 ，实例方法的输入输出参数，实例方法中的变量，实例方法中的返回值\n\nStackOverflowError  栈溢出，不是异常，是错误 ，它是Error的子类\n\n每执行一个方法都会产生一个栈帧，保存到栈(后进先出)的顶部，顶部栈就是当前的方法，该方法执行完毕 后会自动将此栈帧出栈。\n\n\n\n#### 栈+堆+方法区的交互关系\n\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/712573E4450F4659B193B6DFC262A622/395)\n\n\n比如Person p1=new Person();\nPerson p2=new Person();\n\n左边是引用，右边是实例对象\n\n栈中存的就是引用，堆中存的是实例对象，那么栈就指向堆中的实例对象，\n在堆中同时也会存放访问类元数据的地址（也就是指向方法区中的Person中的类的结构数据，类模板的地址）\n\n---\n\n### 堆\n\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/78A68F0FE60148B0B710901E97E3E077/397)\n\n\n\n堆中存放的是new出来的对象实例，栈存的是引用，但是比如 String str=\"aaa\"，那么右边的对象实例存在字符串常量池中, String str=new String(\"aaa\")，那么右边的对象实例就存在堆中\n\n\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/D8E8041FBFD84A07805A303C76FFEE50/399)\n\n\n堆内存分为三部分：新生区 养老区   永久代（jdk7之前，之后叫元空间） 这是逻辑上的\n\n\n永久代的话呢\n\n用于存放JDK自身所携带的 Class,Interface 的元数据，（就是描述类的数据，也就是模板）\n也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭 JVM 才会释放此区域所占用的内存。\n\n\njdk7之前的永久代用的是堆内存，之后的元空间用的是物理内存,不用堆内存\n\n物理上：新生区（1/3） 养老区（2/3）\n\n新生区又分为 Eden（伊甸园区）  from(幸存者0区) to(幸存者1区)  占比是 8 ： 1 ： 1\n\n\n然后对象的创建和消亡是在Eden（伊甸园区）\n\n* GC过程：  当Eden区的对象创建满了的时候，触发第一次GC,然后在幸存的对象移到from区。清空Eden（伊甸园区）\n\n  当Eden（伊甸园区）又满了，那么触发第二次GC,然后就会扫描Eden（伊甸园区）和from区\n\n  （注意，相当于就是在Eden区就是战场，对Eden区和from区的数据进行GC，但是原来的from区的死不掉）进行GC\n\n  GC复制后有交换，谁空谁是to,\n\n  意思就是，这次GC后活下来的，就把eden连同from区的复制到to区，\n\n  然后清空eden和from那么这个时候原来的from区就变成了to,\n\n  原来的to就是from了（相对于下一次gc来说），\n\n  然后对象的年龄会加1，然后一直这样复制交换直到活过15岁，\n\n  那么满足这个条件的对象就会进入养老区,养老区满了后，养老区会执行Full GC\n\n  之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemoryError”。\n\n\n\n### 堆参数调优入门\n\n\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/2A979E2F9BDB4B6A81107B85CF18E159/401)\n\n\n\n\n---\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/40E0AD03CF2F4476A358EEB35C1FCA1A/403)\n\n\n      public class TYDemo {\n\n    //jvm参数调优入门\n\n\n     public static void main(String args[]) {\n\n        /* System.out.println(Runtime.getRuntime().availableProcessors()); //返回cpu的核数\n\n         long maxMemory=Runtime.getRuntime().maxMemory();// java虚拟机试图使用的最大内存量\n         long totalMemory=Runtime.getRuntime().totalMemory();//Java虚拟机中的内存总量\n\n         System.out.println(\"-Xmx:MAX_MEMORY=\"+maxMemory+\"(字节)丶\"+(maxMemory/(double)1024/1024)+\"MB\");\n         System.out.println(\"-Xms:TOTAL_MEMORY=\"+maxMemory+\"(字节)丶\"+(totalMemory/(double)1024/1024)+\"MB\");*/\n\n        String str=\"yjryjr\";\n        while (true){\n\n             str+=str+new Random().nextInt(888888)+new Random().nextInt(9999999);\n        }\n     }\n\n\n\n    }\n\n\n\n VM参数：\t-Xms1024m -Xmx1024m -XX:+PrintGCDetails\n\n ![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/F9CD0358DF2B4A4EA9787B850972890F/405)\n\n\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/9D0F1AA84C07433DB2DA169F4282AB9C/407)\n\n---\n1：GC类型 YoungGC \n\n2:YoungGC前新生代内存占用   \n\n3.YoungGC后新生代内存占用   \n\n4。新生代总共大小\n\n5.YoungGC前JVM内存占用 \n\n6.YoungGC后JVM内存占用  \n\n7:JVM堆总大小   \n\n8:YoungGC耗时   \n\n9:YoungGC用户耗时 \n\n10:YoungGC系统耗时  \n\n11:YoungGC实际耗时\n\n\n[Full GC (Allocation Failure) [PSYoungGen: 0K->0K(294400K)] [ParOldGen: 467602K->467582K(699392K)\n\n] 467602K->467582K(993792K), [Metaspace: 3505K->3505K(1056768K)], 0.0992225 secs] [Times: user=0.09 sys=0.00, real=0.09 secs]\n\n---\n\n gc类型Full GC        和上面一样的道理\n\n 规律：gc类型  gc前内存占用  gc后内存占用  该区内存总大小     （新生代  老年代   jvm堆总）\n\n---\n GC是什么(分代收集算法)\n\n 次数上频繁收集Young区\n\n 次数上较少收集Old区\n\n 基本不动元空间\n\n---\n\n### GC算法总体概述\n  JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。\n  \n  因此GC按照回收的区域又分了两种类型，一种是普通GC（minor GC），一种是全局GC（major GC or Full GC） \n  \n  Minor GC和Full GC的区别　\n  \n  普通GC（minor GC）：只针对新生代区域的GC,指发生在新生代的垃圾收集动作，因为大多数Java对象存活率都不高，所以Minor GC非常频繁，一般回收速度也比较快。 \n  \n  全局GC（major GC or Full GC）：指发生在老年代的垃圾收集动作，出现了Major GC，经常会伴随至少一次的Minor GC（但并不是绝对的）。Major GC的速度一般要比Minor GC慢上10倍以上   \n\n\n\n---GC四大算法：\n\n 引用计数法（一般不用）缺点：1.每次对对象赋值时均要维护引用计数器，且计数器本身也有一定的消耗    2.较难处理循环引用\n\n 复制算法：年轻代中的GC主要是这个算法，原理就是上面说的复制之后有交换，谁空谁是to。\n\n 复制算法优点不会产生内存碎片,但是耗空间\n\n 标记清除:老年代一般是由标记清除或者是标记清除与标记整理的混合实现,  分为标记和清除两个阶段，先标记出要回收的对象，再统一回收这些对象\n\n 标记清除的优点是不需要额外的空间，缺点是1.两次扫描，耗时严重 2.会产生内存碎片(也就是内存不连续)\n\n 标记压缩：标记存活的对象，然后所有存活对像都向一端移动，然后直接清除边界以外的内存。标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。\n\n 标记压缩的优点是不会产生内存碎片，但是效率不高\n\n 问？哪一种算法最好，答案不知道，分代收集算法，根据各个代不用的特性采用不同的算法，新生代是复制算法，老年代是标记清除或者是标记清除与标记整理的混合实现\n\n---\n\n 小总结\n\n   内存效率：复制算法>标记清除算法>标记整理算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）。\n   \n 内存整齐度：复制算法=标记整理算法>标记清除算法。 \n \n 内存利用率：标记整理算法=标记清除算法>复制算法。 \n \n  可以看出，效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存，而为了尽量兼顾上面所提到的三个指标，标记/整理算法相对来说更平滑一些，但效率上依然不尽如人意，它比复制算法多了一个标记的阶段，又比标记/清除多了一个整理内存的过程 　\n  \n  难道就没有一种最优算法吗？ 猜猜看，下面还有 \n  \n回答：无，没有最好的算法，只有最合适的算法。==========>分代收集算法。\n\n 年轻代(Young Gen)   年轻代特点是区域相对老年代较小，对像存活率低。 这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对像大小有关，因而很适用于年轻代的回收。\n \n 而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。 \n \n 老年代(Tenure Gen) 老年代的特点是区域较大，对像存活率高。 这种情况，存在大量存活率高的对像，复制算法明显变得不合适。一般是由标记清除或者是标记清除与标记整理的混合实现。 \n\n\n\n System.gc()  手动唤醒GC，但是GC并不会立即执行\n\n---\n ### JMM\n\nJMM:JVM内存模型  特征：原子性，可见性，有序性    volatile 保证可见性，不保证原子性  禁止指令重排\n\n JMM(Java内存模型Java Memory Model,简称JMM)本身是一种抽象的概念 并不真实存在,它描述的是一组规则或规范\n\n 通过规范定制了程序中各个变量(包括实例字段,静态字段和构成数组对象的元素)的访问方式.\n\n JMM关于同步规定:\n \n 1.线程解锁前,必须把共享变量的值刷新回主内存\n\n2.线程加锁前,必须读取主内存的最新值到自己的工作内存\n\n3.加锁解锁是同一把锁\n\n\n由于JVM运行程序的实体是线程,而每个线程创建时JVM都会为其创建一个工作内存(有些地方成为栈空间),\n\n工作内存是每个线程的私有数据区域,\n\n而Java内存模型中规定所有变量都存储在主内存,\n\n主内存是共享内存区域,\n\n所有线程都可访问,但线程对变量的操作(读取赋值等)必须在工作内存中进行,\n\n首先要将变量从主内存拷贝到自己的工作空间,然后对变量进行操作,操作完成再将变量写回主内存,\n\n不能直接操作主内存中的变量,各个线程中的工作内存储存着主内存中的变量副本拷贝,因此不同的线程无法访问对方的工作内存,\n\n此案成间的通讯(传值) 必须通过主内存来完成\n\n---\n\n\n    public static void main(String args[]) {\n      //这里要是什么都不写，那么就是有两个线程在执行，一个是main线程,一个是gc线程，需要gc的时候会自动gc\n\n\n     }\n\n\n\n---\n\n验证volatile的Demo\n\n        public class volatileDemo {\n\n\n     volatile int number=20;   //不加volatile main线程就一直运行着\n\n    public  void addNumber(){\n\n      this.number=200;\n\n     }\n\n      public static void main(String args[]) {\n\n\n    volatileDemo volatileDemo=new volatileDemo();\n\n\n    new Thread(()->{\n\n\n        System.out.println(Thread.currentThread().getName()+\"is coming...\");\n\n       try{TimeUnit.SECONDS.sleep(4);}catch(InterruptedException e){e.printStackTrace();}\n        volatileDemo.addNumber();\n\n        System.out.println(Thread.currentThread().getName()+\"update number\"+volatileDemo.number);\n\n    },\"A\").start();\n\n    while (volatileDemo.number==20){\n\n        //当number一直是20就一直转着\n\n\n    }\n\n\n\n    System.out.println(\"main is ok\");\n\n\n       }\n\n\n    }\n\n\n---\n### 加载代码：\n\n        public class CodeBlock03 {\n\n    //加载代码练习：\n    {\n        System.out.println(\"CodeBlock03的构造块4444\");\n    }\n    static {\n\n        System.out.println(\"CodeBlock03的静态代码块5555\");\n    }\n\n    public CodeBlock03() {\n       System.out.println(\"CodeBlock03的构造方法6666\");\n    }\n\n     public static void main(String args[]) {\n\n        //main是入口，先加载CodeBlock03的静态代码块，也就是先有类的模板（方法区）\n        //jvm规定：优先级  静态>构造块>构造方法   静态的只加载一次\n\n        System.out.println(\"我是美丽的分割线===================CodeBlock03的main方法77777\");\n        new CodeJr();\n        System.out.println(\"--------------\");\n        new CodeJr();\n        System.out.println(\"----------------\");\n        new  CodeBlock03();\n     }\n\n     }\n\n     class CodeJr{\n\n    public CodeJr(){\n\n        System.out.println(\"Code的构造方法11111\");\n    }\n    {\n        System.out.println(\"code的构造块2222\");\n    }\n\n    static {\n\n        System.out.println(\"code的静态代码块33333\");\n    }\n\n     }\n\n\n\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/18790C02500841D599C6E67ADD032F8F/409)   ","tags":["学习笔记"]}]