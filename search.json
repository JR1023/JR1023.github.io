[{"title":"Redis的分布式锁","url":"/2020/07/10/Redis的分布式锁/","content":"\n### Redis分布式锁\n\n<!-- more-->\n\n\n\n\n\n     @RestController\n    public class IndexController {\n\n    @Autowired\n    private StringRedisTemplate redisTemplate;\n\n\n    @Autowired\n    private Redisson redisson;\n    @RequestMapping(\"/deduct_stock\")\n    public  String deductStock(){\n         String lockKey=\"product_001\";\n        String clientId= UUID.randomUUID().toString();\n\n        RLock rLock=redisson.getLock(lockKey);//获取一个redisson锁对象\n\n        try{\n            //Boolean result = redisTemplate.opsForValue().setIfAbsent(lockKey, \"jr\");\n            //redisTemplate.expire(lockKey,10, TimeUnit.SECONDS);\n      //            Boolean result=redisTemplate.opsForValue().setIfAbsent(lockKey,clientId);\n      //            if(!result){\n     //\n     //                return  \"系统繁忙，请稍后再试!\";\n     //            }\n\n            rLock.lock(30,TimeUnit.SECONDS);//加锁\n            int stock = Integer.parseInt(redisTemplate.opsForValue().get(\"stock\"));\n\n            if(stock>0){\n\n                int realStock=stock-1;\n                redisTemplate.opsForValue().set(\"stock\",realStock+\"\");\n                System.out.println(\"扣减成功，剩余库存:\"+realStock);\n            }\n            else {\n\n                System.out.println(\"扣减失败，库存不足!\");\n            }\n\n        }\n        finally {\n\n            rLock.unlock(); //释放锁\n     //            if(clientId.equals(redisTemplate.opsForValue().get(lockKey))) {\n     //                redisTemplate.delete(\"product_001\");\n    //            }\n        }\n\n        return \"end\";\n\n\n    }\n\n\n    }\n\n\n---\n\n面对高并发的环境下这样绝对出问题\n\n解决方法1：\n\n对代码块加synchronized，这样只能是在单体运用上才可以（即项目就部署到一个tomcat服务器上），\n假如对服务器做了集群的话，那么多个线程去访问的时候，不同的线程在不同的服务器上都获取到了相应的synchronized锁，还是有并发争抢问题的\n\n        \n解决方法2：\n\n最简单的redis分布式锁,setnx key value  ,只有key不存在的时候才会操作成功，返回true，代码的最后释放锁，也就是删除lockKey;\n\n但是这样还是存在很多问题的: 要是在释放锁之前的代码出异常了，那么锁就释放不了，就会造成lockKey一直在，这样的话其他线程就一直访问不到\n\n所以就想到了用try finally,finally里面的逻辑就是释放锁的逻辑\n\n但是要是在运行的过程中，你整个web应用挂了，那么你的finally就执行不了了，那么redis的key也是一直存在,会造成其他线程访问不了的死锁\n\n那么又想到设置lockKey的过期时间，但是你要是这样写:redisTemplate.expire(lockKey,10, TimeUnit.SECONDS),也会有可能在设置过期时间之前服务器宕机了，那么就会造成设置过期时间不成功\n\n所以需要用另外一种方式redisTemplate.opsForValue().setIfAbsent(lockKey,\"jr\",10,TimeUnit.SECONDS);\n\n但是呢，这样又有问题，比如你设置的超时时间是10秒，要是你的一个线程比较慢，比如说执行要15秒，在执行到还没释放锁的代码的时候，你用了10秒这个时候的锁已经过期失效了，但是呢，所以其他线程就可以进来获取锁，当你执行到释放锁的代码时，人家其他线程进来后可能还没执行完，你又把lockKey给删了，那么这样的话就可能造成永久失效的问题\n\n解决这个问题的话，可以使用uuid生成唯一标识，让每一个线程都有自己的唯一标识，作为lcokKey的value，然后在释放锁的时候判断当前的锁的value值和我当前的clientId是否相同，相同的话就可以释放了\n\n但是时间的问题怎么解决呢，你可以把当前线程分出一个定时器线程，每隔一定的时间看当前线程的锁是否失效，要是没失效就续命一定的时间，但是这样实现起来是很难的\n\n所以我们可以用到redisson来实现分布式锁\n\nRLock rLock=redisson.getLock(lockKey);//获取一个redisson锁对象\n\nrLock.lock(30,TimeUnit.SECONDS);//加锁\n\nrLock.unlock(); //释放锁"},{"title":"SQL中INNER JOIN、LEFT JOIN、RIGHT JOIN、FULL JOIN区别","url":"/2020/06/11/SQL中INNER-JOIN、LEFT-JOIN、RIGHT-JOIN、FULL-JOIN区别/","content":"\n\n\nsql中的连接查询有inner join(内连接）、left join(左连接)、right join（右连接）、full join（全连接）四种方式，它们之间其实并没有太大区别，仅仅是查询出来的结果有所不同。 \n\n<!-- more-->\n例如我们有两张表： \n\n![](https://img-blog.csdn.net/20150603222647340)\n\nOrders表通过外键Id_P和Persons表进行关联。\n\n- 1.inner join，在两张表进行连接查询时，只保留两张表中完全匹配的结果集。\n\n我们使用inner join对两张表进行连接查询，sql如下：\n\n     1 SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo\n     2 FROM Persons\n     3 INNER JOIN Orders\n     4 ON Persons.Id_P=Orders.Id_P\n     5 ORDER BY Persons.LastName\n\n\n\n查询结果集： \n\n\n![](https://img-blog.csdn.net/20150603222827804)\n\n此种连接方式Orders表中Id_P字段在Persons表中找不到匹配的，则不会列出来。\n\n\n- 2.left join,在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。\n\n我们使用left join对两张表进行连接查询，sql如下：\n\n\n     1 SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo\n     2 FROM Persons\n     3 LEFT JOIN Orders\n     4 ON Persons.Id_P=Orders.Id_P\n     5 ORDER BY Persons.LastName\n\n\n\n查询结果如下：\n\n\n![](https://img-blog.csdn.net/20150603223638605)\n\n\n可以看到，左表（Persons表）中LastName为Bush的行的Id_P字段在右表（Orders表）中没有匹配，但查询结果仍然保留该行。\n\n\n\n- 3.right join,在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。\n\n\n我们使用right join对两张表进行连接查询，sql如下：\n\n\n\n      1 SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo\n      2 FROM Persons\n      3 RIGHT JOIN Orders\n      4 ON Persons.Id_P=Orders.Id_P\n      5 ORDER BY Persons.LastName\n\n\n 查询结果如下：\n\n ![](https://img-blog.csdn.net/20150603224352995)\n\n Orders表中最后一条记录Id_P字段值为65，在左表中没有记录与之匹配，但依然保留。\n\n\n - 4.full join,在两张表进行连接查询时，返回左表和右表中所有没有匹配的行。   \n\n\n 我们使用full join对两张表进行连接查询，sql如下：\n\n\n       1 SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo\n       2 FROM Persons\n       3 FULL JOIN Orders\n       4 ON Persons.Id_P=Orders.Id_P\n       5 ORDER BY Persons.LastName   \n\n\n查询结果如下：\n\n\n![](https://img-blog.csdn.net/20150603224604636)\n\n查询结果是left join和right join的并集。\n\n这些连接查询的区别也仅此而已。","tags":["学习笔记"]},{"title":"左移 右移 无符号右移","url":"/2020/06/05/左移-右移-无符号右移/","content":"\n#### 一、背景知识　　\n<!-- more-->\n整数在内存中是以二进制的形式存在的，而且存的是该整数的补码。最高位代表符号位，正数为0，负数为1\n\n　　正数的补码是其二进制本身，负数的补码则是 符号位保持1不变，其他位按位取反再加1,+0和-0的补码相同，都是0。\n\n　　负数在进行按位与运算时是以补码形式参与运算。（这个很好理解，因为负数在内存中本身就是以补码存储的）\n\n#### 二、移位运算\n\n　　下面介绍三种移位运算，\n\n　　首先我们对5作运算。\n\n　　5在内存中的存储形式为：0000 0000 0000 0000 0000 0000 0000 0101\n\n　　1、左移<<\n\n　　　符号位会被保留，数值位左移一位，低位补0，也就是把符号位右边的第一个数给干掉，变为：\n\n　　　0000 0000 0000 0000 0000 0000 0000 1010\n\n　　　得到值为10\n\n　　2、右移>>\n\n　　　符号位会被保留，数值位右移一位，数值位高位补0，（也就是在符号位的右边补0）也就是把最右边的一个数干掉，变为：\n\n　　　0000 0000 0000 0000 0000 0000 0000 0010\n\n　　　得到值为2\n\n　　可以看到，左移相当于乘以2，右移相当于除以2，JDK中很多源码都采用了这种写法，效率高而且优雅\n\n　　3、无符号右移>>>\n\n　　　>>>在右移时会将符号位当做数值位处理，一起右移,高位补0，也就是把最右边的数干掉，直接在数的最左边添0\n\n　　　为了清楚地演示出符号位的变化，以-5为例：\n\n　　　-5在内存中的存储形式为：1111 1111 1111 1111 1111 1111 1111 1011\n\n　　　>>>1      后得到：　　　0111 1111 1111 1111 1111 1111 1111 1101\n\n　　　值为2147483645，很明显，无论从10进制数值，还是从内存中的存储，都能看出，该值比Integer的最大值小2","tags":["随笔"]},{"title":"IO流的学习","url":"/2020/06/04/IO流的学习/","content":"\n### IO流的学习\n\n<!-- more-->\n### 前言\n原文地址：https://www.cnblogs.com/yichunguo/p/11775270.html\n\nio流用到的地方很多，就比如上传下载，传输，设计模式等....基础打扎实了，才能玩更高端的。\n\n在博主认为真正懂IO流的优秀程序员每次在使用IO流之前都会明确分析如下四点：\n\n（1）明确要操作的数据是数据源还是数据目的(也就是要读还是要写)\n\n（2）明确要操作的设备上的数据是字节还是文本\n\n（3）明确数据所在的具体设备\n\n（4）明确是否需要额外功能（比如是否需要转换流、高效流等）\n\n以上四点将会在文章告白IO流的四点明确里面小结一下，如果各位真能熟练以上四点，我觉得这篇文章你就没必要看了，因为你已经把IO玩弄与股掌之中，万物皆可被你盘也就也不再话下了。\n\n\n### 1、告白IO流的四点明确\n\n（1）明确要操作的数据是数据源还是数据目的(要读还是要写)\n\n　　　　\n\n　源：\nInputStream　　Reader\n\n目的：\nOutputStream　　Writer\n\n\n（2）明确要操作的设备上的数据是字节还是文本\n\n　　　　　\n\n　源：\n\n　　　　　　　　　　字节： InputStream\n\n　　　　　　　　　　文本： Reader\n\n---\n\n　目的：\n\n　　　　　　　　　　字节： OutputStream\n\n　　　　　　　　　　文本： Writer\n\n（3）明确数据所在的具体设备\n\n　　　\n　　源设备：\n\n　　　　　　　　硬盘：文件 File开头\n\n　　　　　　　　内存：数组，字符串\n\n　　　　　　　　键盘：System.in\n\n　　　　　　　　网络：Socket\n\n---\n　　对应目的设备：\n\n　　　　　　　　硬盘：文件 File开头\n\n　　　　　　　　内存：数组，字符串\n\n　　　　　　　　屏幕：System.out\n\n　　　　　　　　网络：Socket\n\n（4）明确是否需要额外功能\n\n　　\n\n　　需要转换—— 转换流 InputStreamReader 、OutputStreamWriter\n\n　　　　需要高效—— 缓冲流Bufferedxxx\n\n　　　　多个源—— 序列流 SequenceInputStream\n\n　　　　对象序列化—— ObjectInputStream、ObjectOutputStream\n\n　　　　保证数据的输出形式—— 打印流PrintStream 、Printwriter\n\n　　　　操作基本数据，保证字节原样性——DataOutputStream、DataInputStream\n\n到这里，我们再来看看IO流的分类吧\n\n\n![](https://img-blog.csdnimg.cn/20191014111930276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70)\n\n\nOK，准备好了告白IO流了咩？\n\n\n### 2、File类\n\n至于IO流，也就是输入输出流，从文件出发到文件结束，至始至终都离不开文件，所以IO流还得从文件File类讲起。\n\n#### 1.1 File概述\n\njava.io.File 类是专门对文件进行操作的类，只能对文件本身进行操作，不能对文件内容进行操作。\n\njava.io.File 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。\n\n怎么理解上面两句话？其实很简单！\n\n第一句就是说File跟流无关，File类不能对文件进行读和写也就是输入和输出！\n\n第二句就是说File主要表示类似D:\\\\文件目录1与D:\\\\文件目录1\\\\文件.txt,前者是文件夹（Directory）后者则是文件(file)，而File类就是操作这两者的类。\n\n#### 1.2 构造方法\n\n在java中，一切皆是对象，File类也不例外，不论是哪个对象都应该从该对象的构造说起，所以博主来分析分析File类的构造方法。首先从API开始着手\n\n![](https://img-blog.csdnimg.cn/20191013095030887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70)\n\n\n我们主要来学习一下比较常用的三个：\n\n1、 public File(String pathname) ：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。\n\n2、 public File(String parent, String child) ：从父路径名字符串和子路径名字符串创建新的 File实例。\n\n3、 public File(File parent, String child) ：从父抽象路径名和子路径名字符串创建新的 File实例。\n\n\n看字描述不够生动不够形象不得劲？没得事，下面进行构造举例，马上就生动形象了，代码如下\n\n\n        1. 一个File对象代表硬盘中实际存在的一个文件或者目录。\n        2.  File类构造方法不会给你检验这个文件或文件夹是否真实存在，因此无论该路径下是否存在文件或者目录，都不影响File对象的创建。\n    // 文件路径名 \n    String path = \"D:\\\\123.txt\";\n    File file1 = new File(path);\n\n    // 文件路径名\n    String path2 = \"D:\\\\1\\\\2.txt\";\n    File file2 = new File(path2);     -------------相当于D:\\\\1\\\\2.txt\n\n    // 通过父路径和子路径字符串\n    String parent = \"F:\\\\aaa\";\n    String child = \"bbb.txt\";\n    File file3 = new File(parent, child);  --------相当于F:\\\\aaa\\\\bbb.txt\n\n    // 通过父级File对象和子路径字符串\n    File parentDir = new File(\"F:\\\\aaa\");\n    String child = \"bbb.txt\";\n    File file4 = new File(parentDir, child); --------相当于F:\\\\aaa\\\\bbb.txt\n\n\n\n\n\nFile类的注意点：\n\n一个File对象代表硬盘中实际存在的一个文件或者目录。\nFile类构造方法不会给你检验这个文件或文件夹是否真实存在，因此无论该路径下是否存在文件或者目录，都不影响File对象的创建。\n\n\n#### 1.3 常用方法\nFile的常用方法主要分为获取功能、获取绝对路径和相对路径、判断功能、创建删除功能的方法\n\n1.3.1 获取功能的方法\n\n1、public String getAbsolutePath() ：返回此File的绝对路径名字符串。\n\n2、public String getPath() ：将此File转换为路径名字符串。\n\n3、public String getName() ：返回由此File表示的文件或目录的名称。\n\n4、public long length() ：返回由此File表示的文件的长度。\n\n以上方法测试，代码如下【注意测试以自己的电脑文件夹为准】：\n\n    \n\n            public class FileGet {\n        public static void main(String[] args) {\n            File f = new File(\"d:/aaa/bbb.java\");\n            System.out.println(\"文件绝对路径:\"+f.getAbsolutePath());\n            System.out.println(\"文件构造路径:\"+f.getPath());\n            System.out.println(\"文件名称:\"+f.getName());\n            System.out.println(\"文件长度:\"+f.length()+\"字节\");\n\n            File f2 = new File(\"d:/aaa\");\n            System.out.println(\"目录绝对路径:\"+f2.getAbsolutePath());\n            System.out.println(\"目录构造路径:\"+f2.getPath());\n            System.out.println(\"目录名称:\"+f2.getName());\n            System.out.println(\"目录长度:\"+f2.length());\n        }\n    }\n    输出结果：\n    文件绝对路径:d:\\aaa\\bbb.java\n    文件构造路径:d:\\aaa\\bbb.java\n    文件名称:bbb.java\n    文件长度:2116字节\n\n    目录绝对路径:d:\\aaa\n    目录构造路径:d:\\aaa\n    目录名称:aaa\n    目录长度:3236\n\n\n\n\n注意：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。\n\n1.3.2 绝对路径和相对路径\n\n绝对路径：一个完整的路径，以盘符开头，例如F://aaa.txt。\n\n相对路径：一个简化的路径，不以盘符开头,例如//aaa.txt//b.txt。\n\n\n1、路径是不区分大小写\n\n2、路径中的文件名称分隔符windows使用反斜杠,反斜杠是转义字符,两个反斜杠代表一个普通的反斜杠\n\n\n          //绝对路径\n    public class FilePath {\n        public static void main(String[] args) {\n            // D盘下的bbb.java文件\n            File f = new File(\"D:\\\\bbb.java\");\n            System.out.println(f.getAbsolutePath());\n\n            // 项目下的bbb.java文件\n            File f2 = new File(\"bbb.java\");\n            System.out.println(f2.getAbsolutePath());\n        }\n    }\n    输出结果：\n    D:\\bbb.java\n    D:\\java\\bbb.java\n\n\n\n1.3.3判断功能的方法\n\n1、 public boolean exists() ：此File表示的文件或目录是否实际存在。\n\n2、 public boolean isDirectory() ：此File表示的是否为目录。\n\n3、public boolean isFile() ：此File表示的是否为文件。\n\n方法演示，代码如下：\n\n     public class FileIs {\n        public static void main(String[] args) {\n            File f = new File(\"d:\\\\aaa\\\\bbb.java\");\n            File f2 = new File(\"d:\\\\aaa\");\n            // 判断是否存在\n            System.out.println(\"d:\\\\aaa\\\\bbb.java 是否存在:\"+f.exists());\n            System.out.println(\"d:\\\\aaa 是否存在:\"+f2.exists());\n            // 判断是文件还是目录\n            System.out.println(\"d:\\\\aaa 文件?:\"+f2.isFile());\n            System.out.println(\"d:\\\\aaa 目录?:\"+f2.isDirectory());\n        }\n    }\n    输出结果：\n    d:\\aaa\\bbb.java 是否存在:true\n    d:\\aaa 是否存在:true\n    d:\\aaa 文件?:false\n    d:\\aaa 目录?:true\n\n\n\n1.3.4 创建删除功能的方法\n\npublic boolean createNewFile() ：文件不存在，创建一个新的空文件并返回true，文件存在，不创建文件并返回false。\n\npublic boolean delete() ：删除由此File表示的文件或目录。\n\npublic boolean mkdir() ：创建由此File表示的目录。\n\npublic boolean mkdirs() ：创建由此File表示的目录，包括任何必需但不存在的父目录。\n\n其中，mkdirs()和mkdir()方法类似，但mkdir()，只能创建一级目录，mkdirs()可以创建多级目录比如//a//b//c，所以开发中一般用mkdirs();\n\n这些方法中值得注意的是createNewFile方法以及mkdir与mkdirs的区别\n\n方法测试，代码如下：\n\n\n       public class FileCreateDelete {\n        public static void main(String[] args) throws IOException {\n            // 文件的创建\n            File f = new File(\"aaa.txt\");\n            System.out.println(\"是否存在:\"+f.exists()); // false\n            System.out.println(\"是否创建:\"+f.createNewFile()); // true\n            System.out.println(\"是否创建:\"+f.createNewFile()); // 以及创建过了所以再使用createNewFile返回false\n            System.out.println(\"是否存在:\"+f.exists()); // true\n\n            // 目录的创建\n            File f2= new File(\"newDir\");\n            System.out.println(\"是否存在:\"+f2.exists());// false\n            System.out.println(\"是否创建:\"+f2.mkdir());\t// true\n            System.out.println(\"是否存在:\"+f2.exists());// true\n\n            // 创建多级目录\n            File f3= new File(\"newDira\\\\newDirb\");\n            System.out.println(f3.mkdir());// false\n            File f4= new File(\"newDira\\\\newDirb\");\n            System.out.println(f4.mkdirs());// true\n\n            // 文件的删除\n            System.out.println(f.delete());// true\n\n            // 目录的删除\n            System.out.println(f2.delete());// true\n            System.out.println(f4.delete());// false\n        }\n    }\n\n\n\n注意：delete方法，如果此File表示目录，则目录必须为空才能删除。\n\n\n#### 1.4 目录的遍历\n\npublic String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。\n\npublic File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。\n\n      public class FileFor {\n        public static void main(String[] args) {\n            File dir = new File(\"G:\\光标\");\n\n            //获取当前目录下的文件以及文件夹的名称。\n            String[] names = dir.list();\n            for(String name : names){\n                System.out.println(name);\n            }\n            //获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息\n            File[] files = dir.listFiles();\n            for (File file : files) {\n                System.out.println(file);\n            }\n        }\n    }\n\n\n![](https://img-blog.csdnimg.cn/20191013114927925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70)\n\n\n\nlistFiles在获取指定目录下的文件或者文件夹时必须满足下面两个条件\n\n1，指定的目录必须存在\n\n2，指定的必须是目录。否则容易引发返回数组为null，出现NullPointerException异常\n\n\n#### 1.5 递归遍历文件夹下所有文件以及子文件\n\n不说啥了，直接上代码：\n\n      package File;\n\n       import java.io.File;\n\n    //递归遍历文件夹下所有的文件\n    public class RecursionDirectory {\n        public static void main(String[] args) {\n            File file=new File(\"D:\\\\java专属IO测试\");\n            Recursion(file);\n        }\n        public static void Recursion(File file){\n            //1、判断传入的是否是目录\n            if(!file.isDirectory()){\n                //不是目录直接退出\n                return;\n            }\n            //已经确保了传入的file是目录\n            File[] files = file.listFiles();\n            //遍历files\n            for (File f: files) {\n                //如果该目录下文件还是个文件夹就再进行递归遍历其子目录\n                if(f.isDirectory()){\n                    //递归\n                    Recursion(f);\n                }else {\n                    //如果该目录下文件是个文件，则打印对应的名字\n                    System.out.println(f.getName());\n                }\n\n            }\n        }\n    }\n\n\n\n如果对上面的代码有疑问，可以随时联系我，博主一直都在！\n\n\n\n### 3、初探IO流\n\n #### 1.1 什么是IO\n\n我想在座各位肯定经历都过这样的场景。当你编辑一个文本文件也好用eclipse打代码也罢，忘记了ctrl+s ，在你关闭文件的哪一瞬间手残点了个不该点的按钮，但你反应过来，心早已拔凉拔凉的了。\n\n我们把这种数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为输入input 和输出output ，即流向内存是输入流，流出内存的输出流。\n\nJava中I/O操作主要是指使用java.io包下的内容，进行输入、输出操作。输入也叫做读取数据，输出也叫做作写出数据。\n\n#### 1.2 IO的分类\n\n根据数据的流向分为：输入流 和 输出流。\n\n输入流 ：把数据从其他设备上读取到内存中的流。\n\n输出流 ：把数据从内存 中写出到其他设备上的流。\n\n根据数据的类型分为：字节流 和 字符流。\n\n\n字节流 ：以字节为单位，读写数据的流。\n\n字符流 ：以字符为单位，读写数据的流。\n\n分类之后对应的超类（V8提示：超类也就是父类的意思）\n\n\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/5E94154B24144188BFE08201D1991015/419)\n\n\n注：\n\n由这四个类的子类名称基本都是以其父类名作为子类名的后缀。\n\n如：InputStream的子类FileInputStream。\n\n如：Reader的子类FileReader。\n\n![](https://img-blog.csdnimg.cn/20191013212051298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70)\n\n\n#### 1.3 关于IO的分流向说明\n啥都不说了，看图吧\n\n![](https://img-blog.csdnimg.cn/20191013151622369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70)\n![](https://img-blog.csdnimg.cn/20191015144401127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70)\n\n\n---\n### 字节流OutputStream与InputStream的故事\n\n\nOutputStream与InputStream的继承关系\n![](https://img-blog.csdnimg.cn/20191015145625281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70)\n\n\n\n#### 2.1 文件的世界里一切皆为字节\n\n我们必须明确一点的是，一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。\n\n#### 2.2 字节输出流（OutputStream）\njava.io.OutputStream抽象类是表示字节输出流的所有类的超类（父类），将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法，不要问我OutputStream为啥可以定义字节输出流的基本共性功能方法，熊dei啊，上一句说过了OutputStream是字节输出流的所有类的超类\n\n字节输出流的基本共性功能方法:\n\n1、 public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。\n\n2、 public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。\n\n3、 public void write(byte[] b)：将 b.length个字节从指定的字节数组写入此输出流。\n\n4、 public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。 也就是说从off个字节数开始读取一直到len个字节结束\n\n5、 public abstract void write(int b) ：将指定的字节输出流。\n\n以上五个方法则是字节输出流都具有的方法，由父类OutputStream定义提供，子类都会共享以上方法\n\n#### FileOutputStream类\n\nOutputStream有很多子类，我们从最简单的一个子类FileOutputStream开始。看名字就知道是文件输出流，用于将数据写出到文件。\n\nFileOutputStream构造方法\n\n不管学啥子，只有是对象，就从构造方法开始！\n\n1、 public FileOutputStream(File file)：根据File对象为参数创建对象。\n\n2、 public FileOutputStream(String name)： 根据名称字符串为参数创建对象。\n\n推荐第二种构造方法【开发常用】：\n\nFileOutputStream outputStream = new FileOutputStream(\"abc.txt\");\n\n就以上面这句代码来讲，类似这样创建字节输出流对象都做了三件事情：\n\n1、调用系统功能去创建文件【输出流对象才会自动创建】\n\n2、创建outputStream对象\n\n3、把foutputStream对象指向这个文件\n\n\n注意：\n创建输出流对象的时候，系统会自动去对应位置创建对应文件，而创建输入流对象的时候，文件不存在则会报FileNotFoundException异常，也就是系统找不到指定的文件异常。\n\n当你创建一个流对象时，必须直接或者间接传入一个文件路径。比如现在我们创建一个FileOutputStream流对象，在该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。有兴趣的童鞋可以测试一下，具体代码如下：\n\n\n      public class FileOutputStreamConstructor throws IOException {\n        public static void main(String[] args) {\n            // 使用File对象创建流对象\n            File file = new File(\"G:\\\\自动创建的文件夹\\\\a.txt\");\n            FileOutputStream fos = new FileOutputStream(file);\n\n            // 使用文件名称创建流对象\n            FileOutputStream fos = new FileOutputStream(\"G:\\\\b.txt\");\n        }\n    }\n\n\n#### FileOutputStream写出字节数据\n\n使用FileOutputStream写出字节数据主要通过Write方法，而write方法分如下三种\n\n\npublic void write(int b)\n\npublic void write(byte[] b)\n\npublic void write(byte[] b,int off,int len)  //从`off`索引开始，`len`个字节\n\n---\n写出字节：write(int b) 方法，每次可以写出一个字节数据，代码如下：\n\n    public class IoWrite {\n        public static void main(String[] args) throws IOException {\n            // 使用文件名称创建流对象\n            FileOutputStream fos = new FileOutputStream(\"fos.txt\");\n            // 写出数据\n            fos.write(97); // 写出第1个字节\n            fos.write(98); // 写出第2个字节\n            fos.write(99); // 写出第3个字节\n            // 关闭资源\n            fos.close();\n        }\n    }\n    输出结果：\n    abc\n\n\n虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。\n\n流操作完毕后，必须释放系统资源，调用close方法，千万记得。  \n\n---\n写出字节数组：write(byte[] b)，每次可以写出数组中的数据，代码使用演示：\n\n    public class FOSWrite {\n        public static void main(String[] args) throws IOException {\n            // 使用文件名称创建流对象\n            FileOutputStream fos = new FileOutputStream(\"fos.txt\");\n            // 字符串转换为字节数组\n            byte[] b = \"麻麻我想吃烤山药\".getBytes();\n            // 写出字节数组数据\n            fos.write(b);\n            // 关闭资源\n            fos.close();\n        }\n    }\n    输出结果：\n    麻麻我想吃烤山药\n\n---\n写出指定长度字节数组：write(byte[] b, int off, int len) ,每次写出从off索引开始，len个字节，代码如下：\n\n\n    public class FOSWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream(\"fos.txt\");     \n      \t// 字符串转换为字节数组\n      \tbyte[] b = \"abcde\".getBytes();\n\t\t// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。\n        fos.write(b,2,2);\n      \t// 关闭资源\n        fos.close();\n    }\n    }\n    输出结果：\n    cd\n\n\n### FileOutputStream实现数据追加续写、换行\n\n经过以上的代码测试，每次程序运行，每次创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续追加新数据呢？并且实现换行呢？其实很简单，这个时候我们又要再学习FileOutputStream的另外两个构造方法了，如下：\n\n1、public FileOutputStream(File file, boolean append)\n\n2、public FileOutputStream(String name, boolean append)\n\n这两个构造方法，第二个参数中都需要传入一个boolean类型的值，true 表示追加数据，false 表示不追加也就是清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，至于Windows换行则是 \\n\\r ，下面将会详细讲到。\n\n实现数据追加续写代码如下：\n\n\n     public class FOSWrite {\n        public static void main(String[] args) throws IOException {\n            // 使用文件名称创建流对象\n            FileOutputStream fos = new FileOutputStream(\"fos.txt\"，true);\n            // 字符串转换为字节数组\n            byte[] b = \"abcde\".getBytes();\n            // 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。\n            fos.write(b);\n            // 关闭资源\n            fos.close();\n        }\n    }\n    文件操作前：cd\n    文件操作后：cdabcde\n\n\nWindows系统里，换行符号是\\r\\n ,具体代码如下：\n\n\n     public class FOSWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream(\"fos.txt\");  \n      \t// 定义字节数组\n      \tbyte[] words = {97,98,99,100,101};\n      \t// 遍历数组\n        for (int i = 0; i < words.length; i++) {\n          \t// 写出一个字节\n            fos.write(words[i]);\n          \t// 写出一个换行, 换行符号转成数组写出\n            fos.write(\"\\r\\n\".getBytes());\n        }\n      \t// 关闭资源\n        fos.close();\n    }\n    }\n\n输出结果：\na\nb\nc\nd\ne\n\n\n回车符\\r和换行符\\n ：\n\n回车符：回到一行的开头（return）。\n\n换行符：下一行（newline）。\n\n系统中的换行：\n\nWindows系统里，每行结尾是 回车+换行 ，即\\r\\n；\n\nUnix系统里，每行结尾只有 换行 ，即\\n；\n\nMac系统里，每行结尾是 回车 ，即\\r。从 Mac OS X开始与Linux统一。\n\n\n\n---\n\n#### 2.3 字节输入流（InputStream）\njava.io.InputStream抽象类是表示字节输入流的所有类的超类（父类），可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。\n\n字节输入流的基本共性功能方法:\n\n1、 public void close() ：关闭此输入流并释放与此流相关联的任何系统资源。\n\n2、public abstract int read()： 从输入流读取数据的下一个字节。\n\n3、 public int read(byte[] b)： 该方法返回的int值代表的是读取了多少个字节，读到几个返回几个，读取不到返回-1\n\n#### FileInputStream类\n\njava.io.FileInputStream类是文件输入流，从文件中读取字节。\n\nFileInputStream的构造方法\n\n1、 FileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。\n\n2、 FileInputStream(String name)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名name命名。\n\n同样的，推荐使用第二种构造方法：\n\n FileInputStream inputStream = new FileInputStream(\"a.txt\");\n\n当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出FileNotFoundException 。\n\n构造举例，代码如下：\n\n      public class FileInputStreamConstructor throws IOException{\n        public static void main(String[] args) {\n            // 使用File对象创建流对象\n            File file = new File(\"a.txt\");\n            FileInputStream fos = new FileInputStream(file);\n\n            // 使用文件名称创建流对象\n            FileInputStream fos = new FileInputStream(\"b.txt\");\n        }\n    }\n\n\n\n#### FileInputStream读取字节数据\n\n读取字节：read方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回-1，代码测试如下【read.txt文件中内容为abcde】：\n\n\n     public class FISRead {\n        public static void main(String[] args) throws IOException{\n            // 使用文件名称创建流对象\n            FileInputStream fis = new FileInputStream(\"read.txt\");//read.txt文件中内容为abcde\n            // 读取数据，返回一个字节\n            int read = fis.read();\n            System.out.println((char) read);\n            read = fis.read();\n            System.out.println((char) read);\n            read = fis.read();\n            System.out.println((char) read);\n            read = fis.read();\n            System.out.println((char) read);\n            read = fis.read();\n            System.out.println((char) read);\n            // 读取到末尾,返回-1\n            read = fis.read();\n            System.out.println( read);\n            // 关闭资源\n            fis.close();\n        }\n    }\n    \n\n 输出结果：\na\nb\nc\nd\ne\n-1\n\n---\n循环改进读取方式，代码使用演示：\n\n    public class FISRead {\n        public static void main(String[] args) throws IOException{\n            // 使用文件名称创建流对象\n            FileInputStream fis = new FileInputStream(\"read.txt\");\n            // 定义变量，保存数据\n            int b ；\n            // 循环读取\n            while ((b = fis.read())!=-1) {\n                System.out.println((char)b);\n            }\n            // 关闭资源\n            fis.close();\n        }\n    }\n    输出结果：\n    a\n    b\n    c\n    d\n    e\n---\n\n使用字节数组读取：read(byte[] b)，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回-1 ，代码使用演示：\n\n\n    public class FISRead {\n        public static void main(String[] args) throws IOException{\n            // 使用文件名称创建流对象.\n            FileInputStream fis = new FileInputStream(\"read.txt\"); // read.txt文件中内容为abcde\n            // 定义变量，作为有效个数\n            int len ；\n            // 定义字节数组，作为装字节数据的容器   \n            byte[] b = new byte[2];\n            // 循环读取\n            while (( len= fis.read(b))!=-1) {\n                // 每次读取后,把数组变成字符串打印\n                System.out.println(new String(b));\n            }\n            // 关闭资源\n            fis.close();\n        }\n    }\n\n    输出结果：\n    ab\n    cd\n    ed\n\n\n\n 由于read.txt文件中内容为abcde，而错误数据d，是由于最后一次读取时，只读取一个字节e，数组中，上次读取的数据没有被完全替换【注意是替换，看下图】，所以要通过len ，获取有效的字节   \n\n ![](https://img-blog.csdnimg.cn/20191015160242904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70)\n\n\n 代码如下：\n\n\n      public class FISRead {\n    public static void main(String[] args) throws IOException{\n      \t// 使用文件名称创建流对象.\n       \tFileInputStream fis = new FileInputStream(\"read.txt\"); // 文件中为abcde\n      \t// 定义变量，作为有效个数\n        int len ；\n        // 定义字节数组，作为装字节数据的容器   \n        byte[] b = new byte[2];\n        // 循环读取\n        while (( len= fis.read(b))!=-1) {\n           \t// 每次读取后,把数组的有效字节部分，变成字符串打印\n            System.out.println(new String(b，0，len));//  len 每次读取的有效字节个数\n        }\n\t\t// 关闭资源\n        fis.close();\n    }\n}\n\n输出结果：\nab\ncd\ne\n\n\n在开发中一般强烈推荐使用数组读取文件，代码如下：\n\n      package io;\n\n     import java.io.FileInputStream;\n     import java.io.FileNotFoundException;\n     import java.io.IOException;\n\n    public class input2 {\n    public static void main(String args[]){\n        FileInputStream inputStream = null;\n        try {\n            inputStream = new FileInputStream(\"a.txt\");\n            int len = 0 ;\n            byte[] bys = new byte[1024];\n            while ((len = inputStream.read(bys)) != -1) {\n                System.out.println(new String(bys,0,len));\n            }\n        \n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            try {\n                inputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n    }\n\n#### 字节流FileInputstream复制图片\n复制图片原理\n![](https://img-blog.csdnimg.cn/20191013204020152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70)\n\n\n代码实现\n\n复制图片文件，代码如下：\n\n\n     public class Copy {\n        public static void main(String[] args) throws IOException {\n            // 1.创建流对象\n            // 1.1 指定数据源\n            FileInputStream fis = new FileInputStream(\"D:\\\\test.jpg\");\n            // 1.2 指定目的地\n            FileOutputStream fos = new FileOutputStream(\"test_copy.jpg\");\n\n            // 2.读写数据\n            // 2.1 定义数组\n            byte[] b = new byte[1024];\n            // 2.2 定义长度\n            int len;\n            // 2.3 循环读取\n            while ((len = fis.read(b))!=-1) {\n                // 2.4 写出数据\n                fos.write(b, 0 , len);\n            }\n\n            // 3.关闭资源\n            fos.close();\n            fis.close();\n        }\n    }\n\n\n\n注：复制文本、图片、mp3、视频等的方式一样。\n\n到这里，已经从File类讲到了字节流OutputStream与InputStream，而现在将主要从字符流Reader和Writer的故事开展。\n\n\n----\n\n\n### 字符流Reader和Writer的故事\n\n字符流Reader和Writer的故事从它们的继承图开始，啥都不说了，直接看图\n\n![](https://img-blog.csdnimg.cn/20191015171311217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70)\n\n\n#### 字符流\n\n字符流的由来：因为数据编码的不同，因而有了对字符进行高效操作的流对象，字符流本质其实就是基于字节流读取时，去查了指定的码表，而字节流直接读取数据会有乱码的问题（读中文会乱码），这个时候小白同学就看不懂了，没事，咋们先来看个程序：\n\n      package IO;\n\n    import java.io.FileInputStream;\n    import java.io.FileNotFoundException;\n    import java.io.FileOutputStream;\n\n    public class CharaterStream {\n        public static void main(String[] args) throws Exception {\n            //FileInputStream为操作文件的字符输入流\n            FileInputStream inputStream = new FileInputStream(\"a.txt\");//内容为哥敢摸屎\n\n            int len;\n            while ((len=inputStream.read())!=-1){\n                System.out.print((char)len);\n            }\n\n        }\n    }\n    运行结果：   ??￥??￠????±\n\n\n\n具体现状分析\n\n![](https://img-blog.csdnimg.cn/20191014113505625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70)\n\n话说，就是你哥我敢摸si,那你哥我肯定也不认识这玩意啊： ??￥??￠????±\n\n\n字节流读取中文字符时，可能不会显示完整的字符，那是因为一个中文字符占用多个字节存储。\n\n\n那字节流就没办法了吗？不，字节流依旧有办法，只是麻烦了点，代码如下：\n\n\n     public class CharaterStream {\n    public static void main(String[] args) throws Exception {\n\n        FileInputStream inputStream = new FileInputStream(\"a.txt\");\n        byte[] bytes = new byte[1024];\n        int len;\n        while ((len=inputStream.read(bytes))!=-1){\n           System.out.print(new String(bytes,0,len));\n        }\n    }\n    }\n运行结果： 哥敢摸屎\n\n\n这是为啥呢？没错解码的正是String，查看new String()的源码，String构造方法有解码功能，并且默认编码是utf-8，代码如下：\n\nthis.value = StringCoding.decode(bytes, offset, length);\n \n 再点进decode，循序渐进发现，默认编码是UTF-8\n\n 尽管字节流也能有办法决绝乱码问题，但是还是比较麻烦，于是java就有了字符流，字符为单位读写数据，字符流专门用于处理文本文件。如果处理纯文本的数据优先考虑字符流，其他情况就只能用字节流了（图片、视频、等等只文本例外）。\n\n - 从另一角度来说：字符流 = 字节流 + 编码表\n\n\n\n #### 1、 字符输入流（Reader）\n\njava.io.Reader抽象类是字符输入流的所有类的超类（父类），可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。\n\n字符输入流的共性方法：\n\n1、public void close() ：关闭此流并释放与此流相关联的任何系统资源。\n\n2、 public int read()： 从输入流读取一个字符。\n\n3、 public int read(char[] cbuf)： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中\n\n#### FileReader类\njava.io.FileReader类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。\n\n构造方法\n\n1、FileReader(File file)： 创建一个新的 FileReader ，给定要读取的File对象。\n\n2、 FileReader(String fileName)： 创建一个新的 FileReader ，给定要读取的文件的字符串名称。\n\n构造方法的使用就算不写应该都很熟悉了吧，代码如下：\n\n       public class FileReaderConstructor throws IOException{\n        public static void main(String[] args) {\n            // 使用File对象创建流对象\n            File file = new File(\"a.txt\");\n            FileReader fr = new FileReader(file);\n\n            // 使用文件名称创建流对象\n            FileReader fr = new FileReader(\"b.txt\");\n        }\n    }\n\n #### FileReader读取字符数据\n\n读取字符：read方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回-1，循环读取，代码使用演示：\n\n      public class FRRead {\n        public static void main(String[] args) throws IOException {\n            // 使用文件名称创建流对象\n            FileReader fr = new FileReader(\"a.txt\");\n            // 定义变量，保存数据\n            int b ；\n            // 循环读取\n            while ((b = fr.read())!=-1) {\n                System.out.println((char)b);\n            }\n            // 关闭资源\n            fr.close();\n        }\n    }\n\n\n至于读取的写法类似字节流的写法，只是读取单位不同罢了。\n\n\n#### 2、字符输出流（Writer）\n\njava.io.Writer抽象类是字符输出流的所有类的超类（父类），将指定的字符信息写出到目的地。它同样定义了字符输出流的基本共性功能方法。\n\n字符输出流的基本共性功能方法：\n\n\n1、void write(int c) 写入单个字符。\n\n2、void write(char[] cbuf)写入字符数组。\n\n3、 abstract void write(char[] cbuf, int off, int len)写入字符数组的某一部分,off数组的开始索引,len写的字符个数。\n4、 void write(String str)写入字符串。\n\n5、void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。\n\n6、void flush()刷新该流的缓冲。\n\n7、void close() 关闭此流，但要先刷新它。\n\n#### FileWriter类\n\njava.io.FileWriter类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。\n\n构造方法\n\n1、 FileWriter(File file)： 创建一个新的 FileWriter，给定要读取的File对象。\n\n2、FileWriter(String fileName)： 创建一个新的 FileWriter，给定要读取的文件的名称。\n\n\n依旧是熟悉的构造举例，代码如下：\n\n      public class FileWriterConstructor {\n        public static void main(String[] args) throws IOException {\n            // 第一种：使用File对象创建流对象\n            File file = new File(\"a.txt\");\n            FileWriter fw = new FileWriter(file);\n\n            // 第二种：使用文件名称创建流对象\n            FileWriter fw = new FileWriter(\"b.txt\");\n        }\n    }\n\n#### FileWriter写出数据\n\n写出字符：write(int b) 方法，每次可以写出一个字符数据，代码使用演示：\n\n\n      public class FWWrite {\n        public static void main(String[] args) throws IOException {\n            // 使用文件名称创建流对象\n            FileWriter fw = new FileWriter(\"fw.txt\");\n            // 写出数据\n            fw.write(97); // 写出第1个字符\n            fw.write('b'); // 写出第2个字符\n            fw.write('C'); // 写出第3个字符\n\n            //关闭资源时,与FileOutputStream不同。 如果不关闭,数据只是保存到缓冲区，并未保存到文件。\n            // fw.close();\n        }\n    }\n    输出结果：\n    abC\n\n\n- 【注意】关闭资源时,与FileOutputStream不同。 如果不关闭,数据只是保存到缓冲区，并未保存到文件。\n\n\n关闭close和刷新flush\n\n因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要flush 方法了。\n\n\nflush ：刷新缓冲区，流对象可以继续使用。\n\nclose:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。\n\n\nflush还是比较有趣的，童鞋们不自己运行一下还真不好体会，现在博主就写个程序让你体会体会：\n\n字符流\n\n     public class FlushDemo {\n        public static void main(String[] args) throws Exception {\n            //源   也就是输入流【读取流】 读取a.txt文件\n            FileReader fr=new FileReader(\"a.txt\");  //必须要存在a.txt文件，否则报FileNotFoundException异常\n            //目的地  也就是输出流\n            FileWriter fw=new FileWriter(\"b.txt\");  //系统会自动创建b.txt，因为它是输出流！\n            int len;\n            while((len=fr.read())!=-1){\n                fw.write(len);\n            }\n            注意这里是没有使用close关闭流，开发中不能这样做，但是为了更好的体会flush的作用\n        }\n    }\n\n![](https://img-blog.csdnimg.cn/20191014222100212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70)\n\n\n运行效果是怎么样的呢？答案是b.txt文件中依旧是空的，是的并没有任何东西，为啥呢？熊dei啊，我在上面就用红色字体特别标注过了，就是这句话： \n\n【注意】关闭资源时,与FileOutputStream不同。 如果不关闭,数据只是保存到缓冲区，并未保存到文件。这个时候反应过来了吧，可见实践例子的重要性，编程就是这样，不去敲，永远学不会！！！所以一定要去敲，博主没敲过10万行代码真的没有脸出去说自己是学java的。所以，大家一定要多思考，多敲啊！！！\n\n\n所以，我们在以上的代码中再添加下面三句代码，就完美了，b.txt文件就能复制到源文件的数据了！\n\n  fr.close();\n\n  fw.flush();\n\n  fw.close();\n\nflush()这个函数是清空的意思，用于清空缓冲区的数据流，进行流的操作时，数据先被读到内存中，然后再用数据写到文件中，那么当你数据读完时，我们如果这时调用close()方法关闭读写流，这时就可能造成数据丢失，为什么呢？因为，读入数据完成时不代表写入数据完成，一部分数据可能会留在缓存区中，这个时候flush()方法就格外重要了。\n\n\n好了，接下来close使用代码如下：\n\n       public class FWWrite {\n        public static void main(String[] args) throws IOException {\n            // 使用文件名称创建流对象\n            FileWriter fw = new FileWriter(\"fw.txt\");\n            // 写出数据，通过flush\n            fw.write('刷'); // 写出第1个字符\n            fw.flush();\n            fw.write('新'); // 继续写出第2个字符，写出成功\n            fw.flush();\n\n            // 写出数据，通过close\n            fw.write('关'); // 写出第1个字符\n            fw.close();\n            fw.write('闭'); // 继续写出第2个字符,【报错】java.io.IOException: Stream closed\n            fw.close();\n        }\n    }\n\n即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。\n\n\n####  FileWriter的续写和换行\n\n续写和换行：操作类似于FileOutputStream操作（上一篇博客讲到过），直接上代码：\n\n\n      public class FWWrite {\n        public static void main(String[] args) throws IOException {\n            // 使用文件名称创建流对象，可以续写数据\n            FileWriter fw = new FileWriter(\"fw.txt\"，true);\n            // 写出字符串\n            fw.write(\"哥敢\");\n            // 写出换行\n            fw.write(\"\\r\\n\");\n            // 写出字符串\n            fw.write(\"摸屎\");\n            // 关闭资源\n            fw.close();\n        }\n    }\n    输出结果:\n    哥敢\n    摸屎\n\n#### FileReader和FileWriter类完成文本文件复制\n直接上代码：\n\n\n\n      public class CopyFile {\n        public static void main(String[] args) throws IOException {\n            //创建输入流对象\n            FileReader fr=new FileReader(\"F:\\\\新建文件夹\\\\aa.txt\");//文件不存在会抛出java.io.FileNotFoundException\n            //创建输出流对象\n            FileWriter fw=new FileWriter(\"C:\\\\copyaa.txt\");\n            /*创建输出流做的工作：\n             *      1、调用系统资源创建了一个文件\n             *      2、创建输出流对象\n             *      3、把输出流对象指向文件\n             * */\n            //文本文件复制，一次读一个字符\n            copyMethod1(fr, fw);\n            //文本文件复制，一次读一个字符数组\n            copyMethod2(fr, fw);\n\n            fr.close();\n            fw.close();\n        }\n\n        public static void copyMethod1(FileReader fr, FileWriter fw) throws IOException {\n            int ch;\n            while((ch=fr.read())!=-1) {//读数据\n                fw.write(ch);//写数据\n            }\n            fw.flush();\n        }\n\n        public static void copyMethod2(FileReader fr, FileWriter fw) throws IOException {\n            char chs[]=new char[1024];\n            int len=0;\n            while((len=fr.read(chs))!=-1) {//读数据\n                fw.write(chs,0,len);//写数据\n            }\n            fw.flush();\n        }\n    }\n\n\n\n![](https://img-blog.csdnimg.cn/20191014213256773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70)\n\n\n\n最后再次强调：\n\n字符流，只能操作文本文件，不能操作图片，视频等非文本文件。当我们单纯读或者写文本文件时 使用字符流 其他情况使用字节流\n\n#### IO异常的处理\n我们在学习的过程中可能习惯把异常抛出，而实际开发中并不能这样处理，建议使用try...catch...finally 代码块，处理异常部分，格式代码如下：\n\n\n\n       public class HandleException1 {\n        public static void main(String[] args) {\n            // 声明变量\n            FileWriter fw = null;\n            try {\n                //创建流对象\n                fw = new FileWriter(\"fw.txt\");\n                // 写出数据\n                fw.write(\"哥敢摸si\"); //哥敢摸si\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    if (fw != null) {\n                        fw.close();\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n如果对异常不是特别熟练的童鞋可以参考这篇文章【java基础之异常】死了都要try，不淋漓尽致地catch我不痛快！\n\n好了，到这里，字符流Reader和Writer的故事的到这里了！\n\n\n前面主要写了一些基本的流作为IO流的入门。从这里开始将要见识一些更强大的流。比如能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流等等，而这些强大的流都是在基本的流对象基础之上而来的！这些强大的流将伴随着我们今后的开发！\n\n\n### 1、缓冲流【掌握】\n\n#### 1.1 简要概述\n\n首先我们来认识认识一下缓冲流,也叫高效流，是对4个FileXxx 流的“增强流”。\n\n缓冲流的基本原理：\n\n1、使用了底层流对象从具体设备上获取数据，并将数据存储到缓冲区的数组内。\n\n2、通过缓冲区的read()方法从缓冲区获取具体的字符数据，这样就提高了效率。\n\n3、如果用read方法读取字符数据，并存储到另一个容器中，直到读取到了换行符时，将另一个容器临时存储的数据转成字符串返回，就形成了readLine()功能。\n\n\n也就是说在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。\n\n缓冲书写格式为BufferedXxx，按照数据类型分类：\n\n\n字节缓冲流：BufferedInputStream，BufferedOutputStream\n\n字符缓冲流：BufferedReader，BufferedWriter\n\n#### 1.2 字节缓冲流\n\n构造方法\npublic BufferedInputStream(InputStream in) ：创建一个新的缓冲输入流，注意参数类型为InputStream。\n\npublic BufferedOutputStream(OutputStream out)： 创建一个新的缓冲输出流，注意参数类型为\nOutputStream。\n\n构造举例代码如下：\n\n\n\n      public class BufferedDemo {\n        public static void main(String[] args) throws FileNotFoundException {\n            // 记录开始时间\n            long start = System.currentTimeMillis();\n            // 创建流对象\n            try (\n                    FileInputStream fis = new FileInputStream(\"py.exe\");//exe文件够大\n                    FileOutputStream fos = new FileOutputStream(\"copyPy.exe\")\n            ){\n                // 读写数据\n                int b;\n                while ((b = fis.read()) != -1) {\n                    fos.write(b);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            // 记录结束时间\n            long end = System.currentTimeMillis();\n            System.out.println(\"普通流复制时间:\"+(end - start)+\" 毫秒\");\n        }\n    }\n不好意思十分钟过去了还在玩命复制中...\n\n缓冲流，代码如下：\n\n       public class BufferedDemo {\n        public static void main(String[] args) throws FileNotFoundException {\n            // 记录开始时间\n            long start = System.currentTimeMillis();\n            // 创建流对象\n            try (\n                    BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"py.exe\"));\n                    BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"copyPy.exe\"));\n            ){\n                // 读写数据\n                int b;\n                while ((b = bis.read()) != -1) {\n                    bos.write(b);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            // 记录结束时间\n            long end = System.currentTimeMillis();\n            System.out.println(\"缓冲流复制时间:\"+(end - start)+\" 毫秒\");\n        }\n    }\n\n缓冲流复制时间:8016 毫秒\n\n有的童鞋就要说了，我要更快的速度！最近看速度与激情7有点上头，能不能再快些？答案是当然可以\n\n想要更快可以使用数组的方式，代码如下：\n\n\n     public class BufferedDemo {\n        public static void main(String[] args) throws FileNotFoundException {\n            // 记录开始时间\n            long start = System.currentTimeMillis();\n            // 创建流对象\n            try (\n                    BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"py.exe\"));\n                    BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"copyPy.exe\"));\n            ){\n                // 读写数据\n                int len;\n                byte[] bytes = new byte[8*1024];\n                while ((len = bis.read(bytes)) != -1) {\n                    bos.write(bytes, 0 , len);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            // 记录结束时间\n            long end = System.currentTimeMillis();\n            System.out.println(\"缓冲流使用数组复制时间:\"+(end - start)+\" 毫秒\");\n        }\n    }\n\n\n缓冲流使用数组复制时间:521 毫秒  \n\n#### 1.3 字符缓冲流\n\n构造方法\n\n相同的来看看其构造，其格式以及原理和字节缓冲流是一样一样的！\n\npublic BufferedReader(Reader in) ：创建一个新的缓冲输入流，注意参数类型为Reader。\n\npublic BufferedWriter(Writer out)： 创建一个新的缓冲输出流，注意参数类型为Writer。\n\n构造举例，代码如下：\n\n      // 创建字符缓冲输入流\n    BufferedReader br = new BufferedReader(new FileReader(\"b.txt\"));\n    // 创建字符缓冲输出流\n    BufferedWriter bw = new BufferedWriter(new FileWriter(\"b.txt\"));\n\n#### 字符缓冲流特有方法\n\n字符缓冲流的基本方法与普通字符流调用方式一致，这里不再阐述，我们来看字符缓冲流具备的特有方法。\n\n\nBufferedReader：public String readLine(): 读一行数据。 读取到最后返回null\n\nBufferedWriter：public void newLine(): 换行,由系统属性定义符号。\n\nreadLine方法演示代码如下：\n   \n\n      public class BufferedReaderDemo {\n        public static void main(String[] args) throws IOException {\n            // 创建流对象\n            BufferedReader br = new BufferedReader(new FileReader(\"a.txt\"));\n            // 定义字符串,保存读取的一行文字\n            String line  = null;\n            // 循环读取,读取到最后返回null\n            while ((line = br.readLine())!=null) {\n                System.out.print(line);\n                System.out.println(\"------\");\n            }\n            // 释放资源\n            br.close();\n        }\n    }\n\n\n\nnewLine方法演示代码如下：\n\n\n\n          public class BufferedWriterDemo throws IOException {\n        public static void main(String[] args) throws IOException  {\n            // 创建流对象\n            BufferedWriter bw = new BufferedWriter(new FileWriter(\"b.txt\"));\n            // 写出数据\n            bw.write(\"哥\");\n            // 写出换行\n            bw.newLine();\n            bw.write(\"敢\");\n            bw.newLine();\n            bw.write(\"摸屎\");\n            bw.newLine();\n            bw.write(\"你敢吗？\");\n            bw.newLine();\n            // 释放资源\n            bw.close();\n        }\n    }\n输出效果:\n哥\n\n敢\n\n摸屎\n\n你敢吗？\n\n----\n#### 1.4 字符缓冲流练习\n\n字符缓冲流练习啥捏？先放松一下吧各位，先欣赏欣赏我写的下面的诗篇\n\n\n6.你说你的程序叫简单，我说我的代码叫诗篇\n\n1.一想到你我就哦豁豁豁豁豁豁豁豁豁豁....哦nima个头啊，完全不理人家受得了受不了\n\n8.Just 简单你和我 ，Just 简单程序员\n\n3.约了地点却忘了见面 ，懂得寂寞才明白浩瀚\n\n5.沉默是最大的发言权\n\n2.总是喜欢坐在电脑前， 总是喜欢工作到很晚\n\n7.向左走 又向右走，我们转了好多的弯\n\n4.你从来就不问我，你还是不是那个程序员\n\n欣赏完了咩？没错咋们就练习如何使用缓冲流的技术把上面的诗篇归顺序，都编过号了就是前面的1到8的编号\n\n分析：首先用字符输入缓冲流创建个源，里面放没有排过序的文字，之后用字符输出缓冲流创建个目标接收，排序的过程就要自己写方法了哦，可以从每条诗词的共同点“.”符号下手！\n\n\n                public class BufferedTest {\n        public static void main(String[] args) throws IOException {\n            // 创建map集合,保存文本数据,键为序号,值为文字\n            HashMap<String, String> lineMap = new HashMap<>();\n\n            // 创建流对象  源\n            BufferedReader br = new BufferedReader(new FileReader(\"a.txt\"));\n            //目标\n            BufferedWriter bw = new BufferedWriter(new FileWriter(\"b.txt\"));\n\n            // 读取数据\n            String line  = null;\n            while ((line = br.readLine())!=null) {\n                // 解析文本\n                String[] split = line.split(\"\\\\.\");\n                // 保存到集合\n                lineMap.put(split[0],split[1]);\n            }\n            // 释放资源\n            br.close();\n\n            // 遍历map集合\n            for (int i = 1; i <= lineMap.size(); i++) {\n                String key = String.valueOf(i);\n                // 获取map中文本\n                String value = lineMap.get(key);\n                // 写出拼接文本\n                bw.write(key+\".\"+value);\n                // 写出换行\n                bw.newLine();\n            }\n            // 释放资源\n            bw.close();\n        }\n    }\n\n运行效果\n\n1.一想到你我就哦豁豁豁豁豁豁豁豁豁豁…哦nima个头啊，完全不理人家受得了受不了\n\n2.总是喜欢坐在电脑前， 总是喜欢工作到很晚\n\n3.约了地点却忘了见面 ，懂得寂寞才明白浩瀚\n\n4.你从来就不问我，你还是不是那个程序员\n\n5.沉默是最大的发言权\n\n6.你说你的程序叫简单，我说我的代码叫诗篇\n\n7.向左走 又向右走，我们转了好多的弯\n\n8.Just 简单你和我 ，Just 简单程序员\n\n\n----\n\n### 2、转换流【掌握】\n\n何谓转换流？为何由来？暂时带着问题让我们先来了解了解字符编码和字符集！\n\n![](https://img-blog.csdnimg.cn/2019101609401732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70)\n\n\n#### 2.1 字符编码与解码\n\n众所周知，计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为编码 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。\n\n简单一点的说就是：\n\n\n编码:字符(能看懂的)--字节(看不懂的)\n\n解码:字节(看不懂的)-->字符(能看懂的)\n\n代码解释则是\n\n\nString(byte[] bytes, String charsetName):通过指定的字符集解码字节数组\n\nbyte[] getBytes(String charsetName):使用指定的字符集合把字符串编码为字节数组\n\n\n编码:把看得懂的变成看不懂的\n\nString -- byte[]\n\n解码:把看不懂的变成看得懂的\n\nbyte[] -- String\n\n字符编码 Character Encoding: 就是一套自然语言的字符与二进制数之间的对应规则。\n\n而编码表则是生活中文字和计算机中二进制的对应规则\n\n字符集\n\n字符集 Charset：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。\n计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。\n\n![](https://img-blog.csdnimg.cn/20191016090127127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70)\n\n\n\n可见，当指定了编码，它所对应的字符集自然就指定了，所以编码才是我们最终要关心的。\n\n\n- ASCII字符集 ：\n\nASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。\n基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。\n\n- ISO-8859-1字符集：\n\n拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。\nISO-8859-1使用单字节编码，兼容ASCII编码。\n\n- GBxxx字符集：\n\nGB就是国标的意思，是为了显示中文而设计的一套字符集。\n\nGB2312：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的\"全角\"字符，而原来在127号以下的那些就叫\"半角\"字符了。\n\nGBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。\n\nGB18030：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。\n\n- Unicode字符集 ：\n\nUnicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。\n\n它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。\n\nUTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：\n\n128个US-ASCII字符，只需一个字节编码。\n\n拉丁文等字符，需要二个字节编码。\n\n大部分常用字（含中文），使用三个字节编码。\n\n其他极少使用的Unicode辅助字符，使用四字节编码。\n\n----\n#### 2.2 编码问题导致乱码\n\n在java开发工具IDEA中，使用FileReader 读取项目中的文本文件。由于IDEA的设置，都是默认的UTF-8编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。\n\n\n       public class ReaderDemo {\n        public static void main(String[] args) throws IOException {\n            FileReader fileReader = new FileReader(\"C:\\\\a.txt\");\n            int read;\n            while ((read = fileReader.read()) != -1) {\n                System.out.print((char)read);\n            }\n            fileReader.close();\n        }\n    }\n输出结果：���\n那么如何读取GBK编码的文件呢？ 这个时候就得讲讲转换流了！\n\n\n- 从另一角度来讲：字符流=字节流+编码表\n\n#### 2.3 InputStreamReader类-----(字节流到字符流的桥梁)\n\n转换流java.io.InputStreamReader，是Reader的子类，从字面意思可以看出它是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。\n\n构造方法\n\nInputStreamReader(InputStream in): 创建一个使用默认字符集的字符流。\n\nInputStreamReader(InputStream in, String charsetName): 创建一个指定字符集的字符流。\n\n\n构造代码如下：\n\nInputStreamReader isr = new InputStreamReader(new FileInputStream(\"in.txt\"));\n\nInputStreamReader isr2 = new InputStreamReader(new FileInputStream(\"in.txt\") , \"GBK\");\n\n使用转换流解决编码问题\n\n          public class ReaderDemo2 {\n        public static void main(String[] args) throws IOException {\n            // 定义文件路径,文件为gbk编码\n            String FileName = \"C:\\\\A.txt\";\n            // 创建流对象,默认UTF8编码\n            InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName));\n            // 创建流对象,指定GBK编码\n            InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , \"GBK\");\n            // 定义变量,保存字符\n            int read;\n            // 使用默认编码字符流读取,乱码\n            while ((read = isr.read()) != -1) {\n                System.out.print((char)read); // �����ʺ      \n            }\n            isr.close();\n\n            // 使用指定编码字符流读取,正常解析\n            while ((read = isr2.read()) != -1) {\n                System.out.print((char)read);// 哥敢摸屎\n            }\n            isr2.close();\n        }\n\n\n#### 2.4 OutputStreamWriter类-----(字符流到字节流的桥梁)\n\n转换流java.io.OutputStreamWriter ，是Writer的子类，字面看容易混淆会误以为是转为字符流，其实不然，OutputStreamWriter为从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。\n\n构造方法\n\nOutputStreamWriter(OutputStream in): 创建一个使用默认字符集的字符流。\n\nOutputStreamWriter(OutputStream in, String charsetName): 创建一个指定字符集的字符流。\n\n构造举例，代码如下：\n\nOutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream(\"a.txt\"));\n\nOutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream(\"b.txt\") , \"GBK\");\n\n指定编码构造代码\n\n          public class OutputDemo {\n    public static void main(String[] args) throws IOException {\n      \t// 定义文件路径\n        String FileName = \"C:\\\\s.txt\";\n      \t// 创建流对象,默认UTF8编码\n        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName));\n        // 写出数据\n      \tosw.write(\"哥敢\"); // 保存为6个字节\n        osw.close();\n      \t\n\t\t// 定义文件路径\n\t\tString FileName2 = \"D:\\\\A.txt\";\n     \t// 创建流对象,指定GBK编码\n        OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),\"GBK\");\n        // 写出数据\n      \tosw2.write(\"摸屎\");// 保存为4个字节\n        osw2.close();\n    }\n     }\n\n\n\n![](https://img-blog.csdnimg.cn/20191016100612927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70)\n\n\n\n\n为了达到最高效率，可以考虑在 BufferedReader 内包装 InputStreamReader\n\n\nBufferedReader in = new BufferedReader(new InputStreamReader(System.in))；\n\n\n### 3、序列化流【理解】\n\n(1)可以把对象写入文本文件或者在网络中传输\n\n(2)如何实现序列化呢?\n\n让被序列化的对象所属类实现序列化接口。\n\n该接口是一个标记接口。没有功能需要实现。\n\n(3)注意问题：\n\n把数据写到文件后，在去修改类会产生一个问题。\n\n如何解决该问题呢?\n\n在类文件中，给出一个固定的序列化id值。\n\n而且，这样也可以解决黄色警告线问题\n\n(4)面试题：\n\n什么时候序列化?\n如何实现序列化?\n什么是反序列化?\n\n#### 3.1 何谓序列化\nJava 提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。\n\n\n反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象。看图理解序列化：\n\n![](https://img-blog.csdnimg.cn/20191016100818120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70)\n\n\n\n#### 3.2 ObjectOutputStream类\n\njava.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。\n\n构造方法\n\npublic ObjectOutputStream(OutputStream out)： 创建一个指定OutputStream的ObjectOutputStream。\n\n构造代码如下：\n\nFileOutputStream fileOut = new FileOutputStream(\"aa.txt\");\n\nObjectOutputStream out = new ObjectOutputStream(fileOut);\n\n序列化操作\n\n一个对象要想序列化，必须满足两个条件:\n\n- 该类必须实现java.io.Serializable 接口，Serializable 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出NotSerializableException 。\n\n- 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient 关键字修饰。\n\n\n      public class Employee implements java.io.Serializable {\n        public String name;\n        public String address;\n        public transient int age; // transient瞬态修饰成员,不会被序列化\n        public void addressCheck() {\n            System.out.println(\"Address  check : \" + name + \" -- \" + address);\n        }\n        }\n\n\n#### 2.写出对象方法\n\npublic final void writeObject (Object obj) : 将指定的对象写出。\n\n\n      public class SerializeDemo{\n        public static void main(String [] args)   {\n            Employee e = new Employee();\n            e.name = \"zhangsan\";\n            e.address = \"beiqinglu\";\n            e.age = 20;\n            try {\n                // 创建序列化流对象\n                ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"employee.txt\"));\n                // 写出对象\n                out.writeObject(e);\n                // 释放资源\n                out.close();\n                fileOut.close();\n                System.out.println(\"Serialized data is saved\"); // 姓名，地址被序列化，年龄没有被序列化。\n            } catch(IOException i)   {\n                i.printStackTrace();\n            }\n        }\n    }\n输出结果：\nSerialized data is saved\n\n#### 3.3 ObjectInputStream类\n\nObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。\n\n构造方法\n\npublic ObjectInputStream(InputStream in)： 创建一个指定InputStream的ObjectInputStream。\n\n反序列化操作1\n\n如果能找到一个对象的class文件，我们可以进行反序列化操作，调用ObjectInputStream读取对象的方法：\n\n         public class DeserializeDemo {\n        public static void main(String [] args)   {\n            Employee e = null;\n            try {\n                // 创建反序列化流\n                FileInputStream fileIn = new FileInputStream(\"employee.txt\");\n                ObjectInputStream in = new ObjectInputStream(fileIn);\n                // 读取一个对象\n                e = (Employee) in.readObject();\n                // 释放资源\n                in.close();\n                fileIn.close();\n            }catch(IOException i) {\n                // 捕获其他异常\n                i.printStackTrace();\n                return;\n            }catch(ClassNotFoundException c)  {\n                // 捕获类找不到异常\n                System.out.println(\"Employee class not found\");\n                c.printStackTrace();\n                return;\n            }\n            // 无异常,直接打印输出\n            System.out.println(\"Name: \" + e.name);\t// zhangsan\n            System.out.println(\"Address: \" + e.address); // beiqinglu\n            System.out.println(\"age: \" + e.age); // 0\n        }\n    }\n\n对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 ClassNotFoundException 异常。\n\n\n反序列化操作2\n\n另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个InvalidClassException异常。发生这个异常的原因如下：\n\n\n1、该类的序列版本号与从流中读取的类描述符的版本号不匹配\n\n2、该类包含未知数据类型\n\n3、该类没有可访问的无参数构造方法\n\n\nSerializable 接口给需要序列化的类，提供了一个序列版本号。serialVersionUID 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。\n\n\n      public class Employee implements java.io.Serializable {\n        // 加入序列版本号\n        private static final long serialVersionUID = 1L;\n        public String name;\n        public String address;\n        // 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.\n        public int eid;\n\n        public void addressCheck() {\n            System.out.println(\"Address  check : \" + name + \" -- \" + address);\n        }\n    }\n\n\n#### 3.4 序列化集合练习\n\n将存有多个自定义对象的集合序列化操作，保存到list.txt文件中。\n\n反序列化list.txt ，并遍历集合，打印对象信息。\n\n案例分析\n\n把若干学生对象 ，保存到集合中。\n\n把集合序列化。\n\n反序列化读取时，只需要读取一次，转换为集合类型。\n\n遍历集合，可以打印所有的学生信息\n\n案例代码实现\n\n         public class SerTest {\n        public static void main(String[] args) throws Exception {\n            // 创建 学生对象\n            Student student = new Student(\"老王\", \"laow\");\n            Student student2 = new Student(\"老张\", \"laoz\");\n            Student student3 = new Student(\"老李\", \"laol\");\n\n            ArrayList<Student> arrayList = new ArrayList<>();\n            arrayList.add(student);\n            arrayList.add(student2);\n            arrayList.add(student3);\n            // 序列化操作\n            // serializ(arrayList);\n\n            // 反序列化  \n            ObjectInputStream ois  = new ObjectInputStream(new FileInputStream(\"list.txt\"));\n            // 读取对象,强转为ArrayList类型\n            ArrayList<Student> list  = (ArrayList<Student>)ois.readObject();\n\n            for (int i = 0; i < list.size(); i++ ){\n                Student s = list.get(i);\n                System.out.println(s.getName()+\"--\"+ s.getPwd());\n            }\n        }\n\n        private static void serializ(ArrayList<Student> arrayList) throws Exception {\n            // 创建 序列化流 \n            ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"list.txt\"));\n            // 写出对象\n            oos.writeObject(arrayList);\n            // 释放资源\n            oos.close();\n        }\n    }\n\n\n### 4、打印流【掌握】\n\n#### 4.1 何谓打印流\n\n平时我们在控制台打印输出，是调用print方法和println方法完成的，各位用了这么久的输出语句肯定没想过这两个方法都来自于java.io.PrintStream类吧，哈哈。该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。\n\n打印流分类：\n\n字节打印流PrintStream，字符打印流PrintWriter\n\n打印流特点：\n\n\nA:只操作目的地,不操作数据源\n\nB:可以操作任意类型的数据\n\nC:如果启用了自动刷新，在调用println()方法的时候，能够换行并刷新\n\nD:可以直接操作文件\n\n这个时候有同学就要问了，哪些流可以直接操作文件呢?答案很简单，如果该流的构造方法能够同时接收File和String类型的参数，一般都是可以直接操作文件的！\n\nPrintStream是OutputStream的子类，PrintWriter是Writer的子类，两者处于对等的位置上，所以它们的API是非常相似的。二者区别无非一个是字节打印流，一个是字符打印流。\n\n#### 4.2 字节输出打印流PrintStream复制文本文件\n\n\n      public class PrintStreamDemo {\n        public static void main(String[] args) throws IOException {\n            BufferedReader br=new BufferedReader(new FileReader(\"copy.txt\"));\n            PrintStream ps=new PrintStream(\"printcopy.txt\");\n            String line;\n            while((line=br.readLine())!=null) {\n                ps.println(line);\n            }\n            br.close();\n            ps.close();\n        }\n    }\n\n#### 4.3 字符输出打印流PrintWriter复制文本文件\n\n\n         public class PrintWriterDemo {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br=new BufferedReader(new FileReader(\"aa.txt\"));\n        PrintWriter pw=new PrintWriter(\"printcopyaa.txt\");\n        String line;\n        while((line=br.readLine())!=null) {\n            pw.println(line);\n        }\n        br.close();\n        pw.close();\n    }\n    }\n\n\n\n### 5、Properties属性类\n\n我想各位对这个Properties类多多少少也接触过了，首先Properties类并不在IO包下，那为啥要和IO流一起讲呢？原因很简单因为properties类经常和io流的联合一起使用。\n\n(1)是一个集合类，Hashtable的子类\n\n(2)特有功能\n\nA:public Object setProperty(String key,String value)\n\nB:public String getProperty(String key)\n\nC:public Set stringPropertyNames()\n\n(3)和IO流结合的方法\n\n把键值对形式的文本文件内容加载到集合中\n\npublic void load(Reader reader)\n\npublic void load(InputStream inStream)\n\n把集合中的数据存储到文本文件中\n\npublic void store(Writer writer,String comments)\n\npublic void store(OutputStream out,String comments)\n\n#### 5.1 Properties概述\njava.util.Properties 继承于Hashtable ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，System.getProperties 方法就是返回一个Properties对象。\n\n#### 5.2 Properties类\n\n构造方法\npublic Properties() :创建一个空的属性列表。\n\n基本的存储方法\n\npublic Object setProperty(String key, String value) ： 保存一对属性。\n\npublic String getProperty(String key) ：使用此属性列表中指定的键搜索属性值。\n\npublic Set<String> stringPropertyNames() ：所有键的名称的集合。\n\n          public class ProDemo {\n        public static void main(String[] args) throws FileNotFoundException {\n            // 创建属性集对象\n            Properties properties = new Properties();\n            // 添加键值对元素\n            properties.setProperty(\"filename\", \"a.txt\");\n            properties.setProperty(\"length\", \"209385038\");\n            properties.setProperty(\"location\", \"D:\\\\a.txt\");\n            // 打印属性集对象\n            System.out.println(properties);\n            // 通过键,获取属性值\n            System.out.println(properties.getProperty(\"filename\"));\n            System.out.println(properties.getProperty(\"length\"));\n            System.out.println(properties.getProperty(\"location\"));\n\n            // 遍历属性集,获取所有键的集合\n            Set<String> strings = properties.stringPropertyNames();\n            // 打印键值对\n            for (String key : strings ) {\n                System.out.println(key+\" -- \"+properties.getProperty(key));\n            }\n        }\n    }\n输出结果：\n\n{filename=a.txt, length=209385038, location=D:\\a.txt}\n\na.txt\n\n209385038\n\nD:\\a.txt\n\nfilename -- a.txt\n\nlength -- 209385038\n\nlocation -- D:\\a.txt\n\n\n#### 与流相关的方法\n\npublic void load(InputStream inStream)： 从字节输入流中读取键值对。\n\n参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。现在文本数据格式如下:\n\nfilename=Properties.txt\n\nlength=123\n\nlocation=C:\\Properties.txt\n\n             public class ProDemo {\n    public static void main(String[] args) throws FileNotFoundException {\n        // 创建属性集对象\n        Properties pro = new Properties();\n        // 加载文本中信息到属性集\n        pro.load(new FileInputStream(\"Properties.txt\"));\n        // 遍历集合并打印\n        Set<String> strings = pro.stringPropertyNames();\n        for (String key : strings ) {\n          \tSystem.out.println(key+\" -- \"+pro.getProperty(key));\n        }\n     }\n    }\n输出结果：\n\nfilename -- Properties.txt\n\nlength -- 123\n\nlocation -- C:\\Properties.txt\n\n文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。\n\n\n\n\n\n---------------\n\n完结撒花！\n","tags":["JAVA基础"]},{"title":"接口和抽象类的区别","url":"/2020/06/02/接口和抽象类的区别/","content":"\n\n### Java中接口和抽象类的区别？\n<!-- more-->\n## 抽象类\n抽象类必须用 abstract 修饰，子类必须实现抽象类中的抽象方法，如果有未实现的，那么子类也必须用 abstract 修饰。抽象类默认的权限修饰符为 public，可以定义为 public 或 procted，如果定义为 private，那么子类则无法继承。==抽象类不能创建对象==\n\n抽象类和普通类的区别\n抽象类必须用public、procted 修饰(如果为private修饰，那么子类则无法继承，也就无法实现其抽象方法）。默认缺省为 public\n\n抽象类无法创建对象，也就是不能new一个抽象类\n\n如果一个子类继承抽象类，那么必须实现其所有的抽象方法。如果有未实现的抽象方法，那么必须定义为 abstract\n\n### 接口\n接口中的变量隐式的使用 public static final 修饰，并且需要给出初始值。方法隐式的使用 public abstract 修饰(并且只能是 public ，如果是 private，procted，那么就编译报错)。接口中的方法默认不能有具体的实现（JDK1.8开始可以有默认的实现）\n\n### 接口和抽象类的区别\n一个类可以实现多个接口，但只能继承一个抽象类，接口本身可以通过extends关键字扩展多个接口\n\n接口和抽象类必须实现其中所有的方法，抽象类中如果有未实现的抽象方法，那么子类也需要定义为抽象类。抽象类中可以有非抽象的方法\n\n接口中的变量必须用 public static final 修饰，并且需要给出初始值。所以实现类不能重新定义，也不能改变其值。\n\n接口中的方法默认是 public abstract，也只能是这个类型。不能是 static，抽象类中允许有static 的方法\n\n从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是对行为的抽象，是一种行为规范\n\n\n\n      public interface Demo  extends Demo3{\n\n    int g=1;//接口中的变量隐式用 public static final修饰，必须给出初始值\n\n    int  add(int a);  //接口的方法默认是（隐式）public abstract修饰，不能是private protected ,也不能用static修饰\n    }\n\n\n-----------------------\n\n\n       public  abstract class DemoD {\n\n       static  int a=0;\n\n       public  abstract void eat();\n       public  abstract void fuck();\n       public  void drink(){\n\n      //抽象类中也可以有非抽象方法，但是要实现\n\n     }\n\n     public  static void fuckto(){\n      \n\n     }\n     }\n\n\n---\n\n    public    abstract  class D extends  DemoD  implements  Demo{\n    @Override\n    public void eat() {\n\n        //抽象类的子类必须实现抽象类中的所有抽象方法，如果不完全实现的话，那么子类就要用abstract修饰\n    }\n    \n    }\n\n----\n\n         public class D2 extends  D implements  Demo {\n    @Override\n    public int add(int a) {\n    //g++; g在接口中已经被修饰为 public satic final 了，不能被修改\n        return 0;\n    }\n\n    @Override\n    public void fuck() {\n\n    }\n    }\n\n\n","tags":["Java基础面试"]},{"title":"JVM学习笔记","url":"/2020/05/19/JVM学习笔记/","content":"\nJVM体系结构概览\n<!-- more-->\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/72785FD91D514ADDB0134D43276ED7E5/389)\n\n\n### 类加载器（Class loader）：\n\n负责加载class文件，class文件在文件开头有特定的文件标示，将class文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构并且ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定 \n\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/3C474F1A64594F35B61AD0245184688F/391)\n\n---\n\n类加载器的分类：\n\n启动类加载器（Bootstrap）C++\n\n\n扩展类加载器（Extension）Java\n\n应用程序类加载器（AppClassLoader）Java也叫系统类加载器，加载当前应用的classpath的所有类\n\n用户自定义加载器  Java.lang.ClassLoader的子类，用户可以定制类的加载方式\n\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/BB4939364DEB41CD9BCF754F7F1EC00B/393)\n\n\n双亲委派机制：\n\n当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。 \n\n采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object对象。\n\n\n\n        Object o=new Object();\n\n         System.out.println(o.getClass().getClassLoader()); //输出null,因为这个类的加载器是 启动类加载器（启动类加载器（Bootstrap）C++）\n        // System.out.println(o.getClass().getClassLoader().getParent());  //会报空异常，启动类加载器已经是最顶层了。\n\n         MyObject myObject=new MyObject();\n         System.out.println(myObject.getClass().getClassLoader());\n         //输出sun.misc.Launcher$AppClassLoader@18b4aac2  应用程序类加载器\n         //sun.misc.Launcher 它是一个java虚拟机的入口应用\n\n        System.out.println(myObject.getClass().getClassLoader().getParent());  //输出sun.misc.Launcher$ExtClassLoader@1540e19d  应用程序类加载器的上一层就是ExtClassLoader\n        System.out.println(myObject.getClass().getClassLoader().getParent().getParent());  //null .启动类加载器\n---\nnative:是一个关键字，表示调用本地函数库，在本地方法栈中执行\n\n---\n pc寄存器：存储下一条指令的地址\n\n---\n\n ### 方法区：\n\n供各线程共享的运行时内存区域。它存储了每一个类的结构信息，例如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容。上面讲的是规范，在不同虚拟机里头实现是不一样的，最典型的就是永久代(PermGen space)和元空间(Metaspace)。\n\n\n空调 k=new 格力();//左边叫规范，右边叫实现\n\nList l=new ArrayList();\n\nf  =new 永久代；\nf  =new 元空间\n\n实例变量是存在堆中的，和方法区无关。\n\n注意：jdk6的Class实例存放在方法区中，jdk7和jdk8的Class实例存放在堆空间中\n\n\n### 栈\n\n栈也叫栈内存，主管Java程序的运行，是在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束该栈就Over，生命周期和线程一致，是线程私有的。8种基本类型的变量+对象的引用变量+实例方法都是在函数的栈内存中分配。\n\n\n栈存什么？ 8种基本数据类型，对象引用，实例方法 ，实例方法的输入输出参数，实例方法中的变量，实例方法中的返回值\n\nStackOverflowError  栈溢出，不是异常，是错误 ，它是Error的子类\n\n每执行一个方法都会产生一个栈帧，保存到栈(后进先出)的顶部，顶部栈就是当前的方法，该方法执行完毕 后会自动将此栈帧出栈。\n\n\n\n#### 栈+堆+方法区的交互关系\n\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/712573E4450F4659B193B6DFC262A622/395)\n\n\n比如Person p1=new Person();\nPerson p2=new Person();\n\n左边是引用，右边是实例对象\n\n栈中存的就是引用，堆中存的是实例对象，那么栈就指向堆中的实例对象，\n在堆中同时也会存放访问类元数据的地址（也就是指向方法区中的Person中的类的结构数据，类模板的地址）\n\n---\n\n### 堆\n\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/78A68F0FE60148B0B710901E97E3E077/397)\n\n\n\n堆中存放的是new出来的对象实例，栈存的是引用，但是比如 String str=\"aaa\"，那么右边的对象实例存在字符串常量池中, String str=new String(\"aaa\")，那么右边的对象实例就存在堆中\n\n\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/D8E8041FBFD84A07805A303C76FFEE50/399)\n\n\n堆内存分为三部分：新生区 养老区   永久代（jdk7之前，之后叫元空间） 这是逻辑上的\n\n\n永久代的话呢\n\n用于存放JDK自身所携带的 Class,Interface 的元数据，（就是描述类的数据，也就是模板）\n也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭 JVM 才会释放此区域所占用的内存。\n\n\njdk7之前的永久代用的是堆内存，之后的元空间用的是物理内存,不用堆内存\n\n物理上：新生区（1/3） 养老区（2/3）\n\n新生区又分为 Eden（伊甸园区）  from(幸存者0区) to(幸存者1区)  占比是 8 ： 1 ： 1\n\n\n然后对象的创建和消亡是在Eden（伊甸园区）\n\n* GC过程：  当Eden区的对象创建满了的时候，触发第一次GC,然后在幸存的对象移到from区。清空Eden（伊甸园区）\n\n  当Eden（伊甸园区）又满了，那么触发第二次GC,然后就会扫描Eden（伊甸园区）和from区\n\n  （注意，相当于就是在Eden区就是战场，对Eden区和from区的数据进行GC，但是原来的from区的死不掉）进行GC\n\n  GC复制后有交换，谁空谁是to,\n\n  意思就是，这次GC后活下来的，就把eden连同from区的复制到to区，\n\n  然后清空eden和from那么这个时候原来的from区就变成了to,\n\n  原来的to就是from了（相对于下一次gc来说），\n\n  然后对象的年龄会加1，然后一直这样复制交换直到活过15岁，\n\n  那么满足这个条件的对象就会进入养老区,养老区满了后，养老区会执行Full GC\n\n  之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemoryError”。\n\n\n\n### 堆参数调优入门\n\n\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/2A979E2F9BDB4B6A81107B85CF18E159/401)\n\n\n\n\n---\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/40E0AD03CF2F4476A358EEB35C1FCA1A/403)\n\n\n      public class TYDemo {\n\n    //jvm参数调优入门\n\n\n     public static void main(String args[]) {\n\n        /* System.out.println(Runtime.getRuntime().availableProcessors()); //返回cpu的核数\n\n         long maxMemory=Runtime.getRuntime().maxMemory();// java虚拟机试图使用的最大内存量\n         long totalMemory=Runtime.getRuntime().totalMemory();//Java虚拟机中的内存总量\n\n         System.out.println(\"-Xmx:MAX_MEMORY=\"+maxMemory+\"(字节)丶\"+(maxMemory/(double)1024/1024)+\"MB\");\n         System.out.println(\"-Xms:TOTAL_MEMORY=\"+maxMemory+\"(字节)丶\"+(totalMemory/(double)1024/1024)+\"MB\");*/\n\n        String str=\"yjryjr\";\n        while (true){\n\n             str+=str+new Random().nextInt(888888)+new Random().nextInt(9999999);\n        }\n     }\n\n\n\n    }\n\n\n\n VM参数：\t-Xms1024m -Xmx1024m -XX:+PrintGCDetails\n\n ![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/F9CD0358DF2B4A4EA9787B850972890F/405)\n\n\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/9D0F1AA84C07433DB2DA169F4282AB9C/407)\n\n---\n1：GC类型 YoungGC \n\n2:YoungGC前新生代内存占用   \n\n3.YoungGC后新生代内存占用   \n\n4。新生代总共大小\n\n5.YoungGC前JVM内存占用 \n\n6.YoungGC后JVM内存占用  \n\n7:JVM堆总大小   \n\n8:YoungGC耗时   \n\n9:YoungGC用户耗时 \n\n10:YoungGC系统耗时  \n\n11:YoungGC实际耗时\n\n\n[Full GC (Allocation Failure) [PSYoungGen: 0K->0K(294400K)] [ParOldGen: 467602K->467582K(699392K)\n\n] 467602K->467582K(993792K), [Metaspace: 3505K->3505K(1056768K)], 0.0992225 secs] [Times: user=0.09 sys=0.00, real=0.09 secs]\n\n---\n\n gc类型Full GC        和上面一样的道理\n\n 规律：gc类型  gc前内存占用  gc后内存占用  该区内存总大小     （新生代  老年代   jvm堆总）\n\n---\n GC是什么(分代收集算法)\n\n 次数上频繁收集Young区\n\n 次数上较少收集Old区\n\n 基本不动元空间\n\n---\n\n### GC算法总体概述\n  JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。\n  \n  因此GC按照回收的区域又分了两种类型，一种是普通GC（minor GC），一种是全局GC（major GC or Full GC） \n  \n  Minor GC和Full GC的区别　\n  \n  普通GC（minor GC）：只针对新生代区域的GC,指发生在新生代的垃圾收集动作，因为大多数Java对象存活率都不高，所以Minor GC非常频繁，一般回收速度也比较快。 \n  \n  全局GC（major GC or Full GC）：指发生在老年代的垃圾收集动作，出现了Major GC，经常会伴随至少一次的Minor GC（但并不是绝对的）。Major GC的速度一般要比Minor GC慢上10倍以上   \n\n\n\n---GC四大算法：\n\n 引用计数法（一般不用）缺点：1.每次对对象赋值时均要维护引用计数器，且计数器本身也有一定的消耗    2.较难处理循环引用\n\n 复制算法：年轻代中的GC主要是这个算法，原理就是上面说的复制之后有交换，谁空谁是to。\n\n 复制算法优点不会产生内存碎片,但是耗空间\n\n 标记清除:老年代一般是由标记清除或者是标记清除与标记整理的混合实现,  分为标记和清除两个阶段，先标记出要回收的对象，再统一回收这些对象\n\n 标记清除的优点是不需要额外的空间，缺点是1.两次扫描，耗时严重 2.会产生内存碎片(也就是内存不连续)\n\n 标记压缩：标记存活的对象，然后所有存活对像都向一端移动，然后直接清除边界以外的内存。标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。\n\n 标记压缩的优点是不会产生内存碎片，但是效率不高\n\n 问？哪一种算法最好，答案不知道，分代收集算法，根据各个代不用的特性采用不同的算法，新生代是复制算法，老年代是标记清除或者是标记清除与标记整理的混合实现\n\n---\n\n 小总结\n\n   内存效率：复制算法>标记清除算法>标记整理算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）。\n   \n 内存整齐度：复制算法=标记整理算法>标记清除算法。 \n \n 内存利用率：标记整理算法=标记清除算法>复制算法。 \n \n  可以看出，效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存，而为了尽量兼顾上面所提到的三个指标，标记/整理算法相对来说更平滑一些，但效率上依然不尽如人意，它比复制算法多了一个标记的阶段，又比标记/清除多了一个整理内存的过程 　\n  \n  难道就没有一种最优算法吗？ 猜猜看，下面还有 \n  \n回答：无，没有最好的算法，只有最合适的算法。==========>分代收集算法。\n\n 年轻代(Young Gen)   年轻代特点是区域相对老年代较小，对像存活率低。 这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对像大小有关，因而很适用于年轻代的回收。\n \n 而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。 \n \n 老年代(Tenure Gen) 老年代的特点是区域较大，对像存活率高。 这种情况，存在大量存活率高的对像，复制算法明显变得不合适。一般是由标记清除或者是标记清除与标记整理的混合实现。 \n\n\n\n System.gc()  手动唤醒GC，但是GC并不会立即执行\n\n---\n ### JMM\n\nJMM:JVM内存模型  特征：原子性，可见性，有序性    volatile 保证可见性，不保证原子性  禁止指令重排\n\n JMM(Java内存模型Java Memory Model,简称JMM)本身是一种抽象的概念 并不真实存在,它描述的是一组规则或规范\n\n 通过规范定制了程序中各个变量(包括实例字段,静态字段和构成数组对象的元素)的访问方式.\n\n JMM关于同步规定:\n \n 1.线程解锁前,必须把共享变量的值刷新回主内存\n\n2.线程加锁前,必须读取主内存的最新值到自己的工作内存\n\n3.加锁解锁是同一把锁\n\n\n由于JVM运行程序的实体是线程,而每个线程创建时JVM都会为其创建一个工作内存(有些地方成为栈空间),\n\n工作内存是每个线程的私有数据区域,\n\n而Java内存模型中规定所有变量都存储在主内存,\n\n主内存是共享内存区域,\n\n所有线程都可访问,但线程对变量的操作(读取赋值等)必须在工作内存中进行,\n\n首先要将变量从主内存拷贝到自己的工作空间,然后对变量进行操作,操作完成再将变量写回主内存,\n\n不能直接操作主内存中的变量,各个线程中的工作内存储存着主内存中的变量副本拷贝,因此不同的线程无法访问对方的工作内存,\n\n此案成间的通讯(传值) 必须通过主内存来完成\n\n---\n\n\n    public static void main(String args[]) {\n      //这里要是什么都不写，那么就是有两个线程在执行，一个是main线程,一个是gc线程，需要gc的时候会自动gc\n\n\n     }\n\n\n\n---\n\n验证volatile的Demo\n\n        public class volatileDemo {\n\n\n     volatile int number=20;   //不加volatile main线程就一直运行着\n\n    public  void addNumber(){\n\n      this.number=200;\n\n     }\n\n      public static void main(String args[]) {\n\n\n    volatileDemo volatileDemo=new volatileDemo();\n\n\n    new Thread(()->{\n\n\n        System.out.println(Thread.currentThread().getName()+\"is coming...\");\n\n       try{TimeUnit.SECONDS.sleep(4);}catch(InterruptedException e){e.printStackTrace();}\n        volatileDemo.addNumber();\n\n        System.out.println(Thread.currentThread().getName()+\"update number\"+volatileDemo.number);\n\n    },\"A\").start();\n\n    while (volatileDemo.number==20){\n\n        //当number一直是20就一直转着\n\n\n    }\n\n\n\n    System.out.println(\"main is ok\");\n\n\n       }\n\n\n    }\n\n\n---\n### 加载代码：\n\n        public class CodeBlock03 {\n\n    //加载代码练习：\n    {\n        System.out.println(\"CodeBlock03的构造块4444\");\n    }\n    static {\n\n        System.out.println(\"CodeBlock03的静态代码块5555\");\n    }\n\n    public CodeBlock03() {\n       System.out.println(\"CodeBlock03的构造方法6666\");\n    }\n\n     public static void main(String args[]) {\n\n        //main是入口，先加载CodeBlock03的静态代码块，也就是先有类的模板（方法区）\n        //jvm规定：优先级  静态>构造块>构造方法   静态的只加载一次\n\n        System.out.println(\"我是美丽的分割线===================CodeBlock03的main方法77777\");\n        new CodeJr();\n        System.out.println(\"--------------\");\n        new CodeJr();\n        System.out.println(\"----------------\");\n        new  CodeBlock03();\n     }\n\n     }\n\n     class CodeJr{\n\n    public CodeJr(){\n\n        System.out.println(\"Code的构造方法11111\");\n    }\n    {\n        System.out.println(\"code的构造块2222\");\n    }\n\n    static {\n\n        System.out.println(\"code的静态代码块33333\");\n    }\n\n     }\n\n\n\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/18790C02500841D599C6E67ADD032F8F/409)   ","tags":["学习笔记"]},{"title":"详解Java内部类","url":"/2020/05/14/详解Java内部类/","content":"\n原文链接：https://blog.csdn.net/Hacker_ZhiDian/article/details/82193100","tags":["转载"]},{"title":"juc学习笔记07","url":"/2020/05/14/juc学习笔记07/","content":"\nJava8之流式计算复习\n<!-- more-->\n函数式接口 java.util.function\n\njava内置核心四大函数式接口\n\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/3C92CB6B91124909BFC0CF8A2E6624FF/381)\n\n\n---\n流(Stream) 到底是什么呢？是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。“集合讲的是数据，流讲的是计算！”\n\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/10DD479BBBFE4F789C580F77E218428C/383)\n\n代码：\n\n\n     import lombok.AllArgsConstructor;\n     import lombok.Data;\n     import lombok.experimental.Accessors;\n     import java.awt.print.Book;\n     import java.util.Arrays;\n     import java.util.Comparator;\n     import java.util.List;\n     import java.util.function.Consumer;\n     import java.util.function.Function;\n     import java.util.function.Predicate;\n     import java.util.function.Supplier;\n    import java.util.stream.Stream;\n\n    /*\n     @Data\n    @Accessors(chain = true)\n     class Book {\n\n    private  int age;\n    private  String name;\n\n\n\n\n    }\n    */\n    /*\n    题目：请按照给出的数据，找出同时满足以下条件的用户，也即以下条件全部满足\n    偶数ID且年龄大于24且用户名转为大写且用户名字母倒排序,只输出一个用户的名字。\n\n    */\n    @Data\n    @Accessors(chain =true)\n    @AllArgsConstructor\n     class  User{\n\n    private  int id;\n    private  int age;\n    private  String name;\n    }\n     public  class StreamDemo{\n\n\n     public static void main(String args[]) {\n\n         /*\n         Book book=new Book();\n         book.setAge(20).setName(\"张三\");\n\n         System.out.println(book);\n    */\n         User user1=new User(11,23,\"a\");\n         User user2=new User(12,24,\"b\");\n         User user3=new User(13,22,\"c\");\n         User user4=new User(14,28,\"d\");\n         User user5=new User(15,26,\"e\");\n\n         List<User> userList = Arrays.asList(user1, user2, user3, user4, user5);\n       userList.stream().filter((u) -> {\n             return u.getId() % 2 == 0;\n         }).filter((u)->{return u.getAge()>=24;}).map((u)->{return  u.getName().toUpperCase();}).sorted((o1,o2)->{return  o2.compareTo(o1);})/*.sorted(new Comparator<String>() {\n           @Override\n           public int compare(String o1, String o2) {\n               return -1;\n           }\n       })*/.limit(1).forEach(System.out::println);\n\n    /*\n\n        这是函数式接口的示范，Function<T, R>    R apply(T t)\n         Function<String, Integer> function = new Function<String, Integer>() {\n             @Override\n             public Integer apply(String s) {\n                 return 1024;\n             }\n         };\n         System.out.println(function.apply(\"abc\")); //1024\n    */\n\n\n\n\n         //lambodaExpress当参数只有一个时，可以省略参数类型,并且参数多个但是参数类型一样时也可以省略\n\n    /*  Function<String,Integer> function=(s)->{  return s.length();};\n     System.out.println( function.apply(\"abc\"));*/\n\n\n         /*Consumer<String> consumer=new Consumer<String>() {\n             @Override\n             public void accept(String s) {\n                 System.out.println(s);\n             }\n         };\n         consumer.accept(\"abc\");*/\n\n        /* Consumer<String> consumer=(s)->{\n             System.out.println(s);\n         };\n         consumer.accept(\"aaa\");*/\n\n         /*Supplier<Integer> supplier=new Supplier<Integer>() {\n             @Override\n             public Integer get() {\n                 return 1024;\n             }\n         };\n\n         System.out.println(supplier.get());*/\n    /*\n         Supplier<Integer> supplier=()->{return 1024;};\n         System.out.println(supplier.get());*/\n\n        /* Predicate<String> predicate=new Predicate<String>() {\n             @Override\n             public boolean test(String s) {\n                 return false;\n             }\n         };\n         System.out.println(predicate.test(\"a\"));*/\n\n         Predicate<String> predicate=(s)->{\n             return  false;\n         };\n        System.out.println( predicate.test(\"aaaa\"));\n     }\n\n\n    }\n\n    interface  MyInterface{\n\n    public  int myInt(int x);\n    public  String  myString(String str);\n\n    }\n\n\n---\n\n### 分支合并框架\n\nFork：把一个复杂任务进行分拆，大事化小\n\nJoin：把分拆任务的结果进行合并 \n\n相关类:\n\nForkJoinPool  分支合并池    类比=>   线程池\n\nForkJoinTask  ForkJoinTask    类比=>   FutureTask \n\nRecursiveTask  递归任务：继承后可以实现递归(自己调自己)调用的任务\n\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/11B2A45B77744682ABD9C4953CAF8A6A/385)\n\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/AF2631C7E05B49A39F5928365A7B72CB/387)\n\n---\n代码：\n\n     public class ForkJoinDemo {\n\n    //分支合并框架\n\n\n     public static void main(String args[]) throws Exception {\n\n         MyTask task=new MyTask(0,100);\n\n         // 创建包含Runtime.getRuntime().availableProcessors()返回值作为个数的并行线程的ForkJoinPool\n         ForkJoinPool forkJoinPool=new ForkJoinPool();\n\n\n         //第一种获得结果的方式：\n     /*    ForkJoinTask<Integer> submit = forkJoinPool.submit(task);  //提交任务  ForkJoinTask 实现Future接口\n         Integer integer = submit.get();\n         System.out.println(integer);*/\n\n       //第二种获得结果的方式\n         Integer invoke = forkJoinPool.invoke(task);\n         System.out.println(invoke);\n         forkJoinPool.shutdown();\n\n\n     }\n\n    }\n\n\n    //要是任务是没有返回值的，那么就要继承  RecursiveAction 这个抽象类\n    class  MyTask extends RecursiveTask<Integer> {\n    private static final  int VALUELIMT=10;\n    private  int begin;\n    private  int end;\n    private  int result;\n\n    @Override\n    protected Integer compute() {\n\n\n        //分解两个值begin和end已经满足范围要求了\n        if(end-begin<=VALUELIMT){\n            //计算\n            for(int i=begin;i<=end;i++){\n\n                result=result+i;\n\n            }\n\n\n        }\n\n        else {\n\n            int middle=(begin+end)/2;\n            MyTask task1=new MyTask(begin,middle);\n            MyTask task2=new MyTask(middle+1,end);\n            //并行执行的两个小任务\n            task1.fork();\n            task2.fork();\n            result=task1.join()+ task2.join(); //获取合并的结果\n        }\n\n        return result;\n    }\n\n\n\n    public MyTask(int begin, int end) {\n        this.begin = begin;\n        this.end = end;\n    }\n\n\n    }\n\n\n\n\n---\n\n### 异步回调\n\n\n代码：\n\n      public class CompletableFutureDemo {\n\n    //异步回调\n\n    //同步就是线程去获取结果时直到获取到了才完成，异步回调就是我继续走我的，我向你要结果，你搞完了再返回给我\n\n\n     public static void main(String args[]) throws ExecutionException, InterruptedException {\n\n\n         //这是没有返回值的异步回调，传入的是runable接口\n         CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {\n\n             System.out.println(Thread.currentThread().getName() + \"\\t\" + \"ok\");\n         });\n\n         future.get();\n\n\n\n\n         //这是有返回值的异步回调，传入的是供给型接口\n\n         CompletableFuture<Integer> integerCompletableFuture = CompletableFuture.supplyAsync(() -> {\n\n             System.out.println(Thread.currentThread().getName() + \"\\t\" + \"isok\");\n            //int age=10/0;\n             return 1024;\n         });\n\n         //当完成的时候.whenComplete()参数是 BiConsumer<T, U>，也就是两个参数的消费型接口\n         integerCompletableFuture.whenComplete((t,u)->{\n             System.out.println(\"******\"+t);  //这是执行成功的结果\n             System.out.println(\"******\"+u); //这是异常信息，执行成功的话为null\n         }).exceptionally((f)->{\n             //.exceptionally的参数是函数式接口，输出异常信息\n             System.out.println(\"***\"+f.getMessage());\n             return  444;\n         });\n\n\n     }\n\n","tags":["学习笔记"]},{"title":"juc学习笔记06","url":"/2020/05/14/juc学习笔记06/","content":"\n线程池\n<!-- more-->\n架构说明：\n\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/F382D0700ED640FC9BC0C0C5668C52AD/371)\n\n\nExecutors.newFixedThreadPool(int）执行长期任务性能好，创建一个线程池，\n一池有N个固定的线程，有固定线程数的线程\n\nExecutors.newSingleThreadExecutor() 一个任务一个任务的执行，一池一线程\n\nExecutors.newCachedThreadPool() 执行很多短期异步任务，线程池根据需要创建新线程，\n但在先前构建的线程可用时将重用它们。可扩容，遇强则强\n\n\n底层原理:\n\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/9E7B7D61A3DB4355B8A0E969A30F3E85/373)\n\n\n1、corePoolSize：线程池中的常驻核心线程数\n\n2、maximumPoolSize：线程池中能够容纳同时\n执行的最大线程数，此值必须大于等于1\n\n3、keepAliveTime：多余的空闲线程的存活时间\n当前池中线程数量超过corePoolSize时，当空闲时间\n达到keepAliveTime时，多余线程会被销毁直到\n只剩下corePoolSize个线程为止\n\n4、unit：keepAliveTime的单位\n\n5、workQueue：任务队列，被提交但尚未被执行的任务\n\n6、threadFactory：表示生成线程池中工作线程的线程工厂，\n用于创建线程，一般默认的即可\n\n7、handler：拒绝策略，表示当队列满了，并且工作线程大于\n等于线程池的最大线程数（maximumPoolSize）时如何来拒绝\n请求执行的runnable的策略\n\n---\n\n原理：****重要***\n\n1、在创建了线程池后，开始等待请求。\n\n2、当调用execute()方法添加一个请求任务时，线程池会做出如下判断：\n  \n  2.1如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；\n\n  2.2如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列；\n \n  2.3如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；  \n  \n  2.4如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。\n  \n3、当一个线程完成任务时，它会从队列中取下一个任务来执行。\n\n4、当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。 \n\n---\n\n线程池用哪个？生产中如设置合理参数\n\n等待队列已经排满了，再也塞不下新任务了同时，线程池中的max线程也达到了，无法继续为新任务服务。这个是时候我们就需要拒绝策略机制合理的处理这个问题。\n\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/85FD58EDB08C48B1977E8E4D1DD03108/375)\n\n以上内置拒绝策略均实现了\nRejectedExecutionHandle接口\n\n\n\n---\n\n在工作中单一的/固定数的/可变的三种创建线程池的方法哪个用的多？超级大坑\n\n答案是一个都不用，我们工作中只能使用自定义的\n\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/C0DDE614CCAF45369899522D0F7FEE6D/377)\n\n\n代码：\n\n\n     public class MyThreadPoolDemo {\n\n    public static void main(String[] args) {\n\n       //ExecutorService executorService = Executors.newFixedThreadPool(3);  //一个线程池固定有n个线程(3),常驻线程数corePoolSize3个，最大线程数maximumPoolSize3个\n\n        //ExecutorService executorService = Executors.newSingleThreadExecutor(); //一个线程池只有一个线程，常驻线程数corePoolSize1个，最大线程数maximumPoolSize1个\n\n\n\n        //一个池子有n个线程\n        //执行很多短期异步任务，线程池根据需要创建新线程，\n        //但在先前构建的线程可用时将重用它们。可扩容，遇强则强\n        //ExecutorService executorService = Executors.newCachedThreadPool(); //常驻线程数corePoolSize0个，最大线程数maximumPoolSizeInteger.MAX_VALUE\n\n        //工作中使用自定义线程池\n\n        /*\n        拒绝策略：\n        new ThreadPoolExecutor.AbortPolicy():默认，超过最大容纳数就抛异常\n        new ThreadPoolExecutor.CallerRunsPolicy():该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。（这里回退给main）\n        new ThreadPoolExecutor.DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加人队列中尝试再次提交当前任务。\n        new ThreadPoolExecutor.DiscardPolicy：该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。如果允许任务丢失，这是最好的一种策略\n\n         */\n        ExecutorService executorService=new ThreadPoolExecutor(3,5,2L,TimeUnit.SECONDS,new LinkedBlockingQueue<>(3),Executors.defaultThreadFactory(),new ThreadPoolExecutor.DiscardOldestPolicy());\n        try {\n         for(int i=1;i<=10;i++) {\n\n             //最大线程数maximumPoolSize,最大容纳数是maximumPoolSize + 阻塞队列的最大长度,AbortPolicy这个策略超过就抛异常\n            // try{TimeUnit.SECONDS.sleep(4);}catch(InterruptedException e){e.printStackTrace();}\n             executorService.execute(() -> {\n\n                 try {\n                     TimeUnit.SECONDS.sleep(4);\n                 } catch (InterruptedException e) {\n                     e.printStackTrace();\n                 }\n                 System.out.println(Thread.currentThread().getName() + \"\\t\" + \"办理业务\");\n             });\n         }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n\n            executorService.shutdown();\n\n        }\n\n    }\n\n     }\n\n","tags":["学习笔记"]},{"title":"juc学习笔记05","url":"/2020/05/14/juc学习笔记05/","content":"\nReentrantReadWriteLock\n读写锁\n<!-- more-->\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/9213FFC89EB24E9987B790A22A69B10F/363)\n\n读写锁\n\n  多个线程同时读取一个资源类没有任何问题，所以为了满足并发量，读取共享资源可以同时进行\n\n  但是如果一个线程想去写共享资源，就不应该有其他线程对该资源进行读或者写\n\n  总结：\n  读-读可共存\n\n  读-写不能共存\n\n  写-写不能共存\n\n\n\n代码：\n\n    public  class ReadWriteLockDemo{\n\n\n     /*\n     读写锁\n\n     多个线程同时读取一个资源类没有任何问题，所以为了满足并发量，读取共享资源可以同时进行\n\n    但是如果一个线程想去写共享资源，就不应该有其他线程对该资源进行读或者写\n\n    总结：\n    读-读可共存\n    读-写不能共存\n    写-写不能共存\n\n\n      */\n\n\n      public static void main(String args[]) {\n\n    MyCahe cahe=new MyCahe();\n    for(int i=1;i<=10;i++){\n\n     final  int tempInt=i;\n     new Thread(()->{\n\n      cahe.put(tempInt,tempInt);\n     },String.valueOf(i)).start();\n\n    }\n    for(int i=1;i<=10;i++){\n\n     final  int tempInt=i;\n     new Thread(()->{\n\n      cahe.get(tempInt);\n     },String.valueOf(i)).start();\n\n    }\n\n\n\n       }\n\n\n\n     }\n\n     class  MyCahe{\n\n     private  volatile Map<Integer,Integer> map=new HashMap<>();\n\n      private ReadWriteLock readWriteLock=new ReentrantReadWriteLock();\n\n\n\n      public  void put (int i,int j){\n\n      readWriteLock.writeLock().lock();  // readWriteLock.writeLock()返回写锁，即Lock对象\n\n          try{\n           System.out.println(\"写入数据\");\n           map.put(i,j);\n           System.out.println(\"写入成功\");\n\n           }catch(Exception e){\n\n            e.printStackTrace();\n\n\n          }finally{\n\n          readWriteLock.writeLock().unlock();\n\n          }\n\n\n\n      }\n      public  void get (int key){\n\n      readWriteLock.readLock().lock();\n\n          try{\n\n           System.out.println(\"读取数据\");\n           map.get(key);\n           System.out.println(\"读取成功\");\n           }catch(Exception e){\n\n            e.printStackTrace();\n\n\n          }finally{\n\n        readWriteLock.readLock().unlock();\n\n          }\n\n\n      }\n\n     }\n\n\n\n---\n\n\n### BlockingQueueDemo阻塞队列\n\n当队列是空的，从队列中获取元素的操作将会被阻塞\n\n当队列是满的，从队列中添加元素的操作将会被阻塞\n\n试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素\n\n试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增\n\n---\n用处：在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤起为什么需要BlockingQueue好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了在concurrent包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。\n\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/291A1D5F93504AD983B85E17E3A3236B/367)\n\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/65B39628201B46F7AB3853D00A676E01/369)\n\n\n代码：\n\n\n      public class BlockingQueueDemo {\n\n    //阻塞队列\n\n        /*\n       当队列是空的，从队列中获取元素的操作将会被阻塞\n       当队列是满的，从队列中添加元素的操作将会被阻塞\n      试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素\n      试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增\n     */\n\n     public static void main(String args[]) throws InterruptedException {\n\n         BlockingQueue<String> blocking =new ArrayBlockingQueue<>(3);  //容量3，默认访问策略\n\n     //         System.out.println(blocking.add(\"a\"));\n    //         System.out.println(blocking.add(\"a\"));\n    //         System.out.println(blocking.add(\"a\"));\n     //         System.out.println(blocking.add(\"a\"));  //队列满了多加一个会抛异常      IllegalStateException: Queue full\n\n\n     //       System.out.println(blocking.remove());\n    //         System.out.println(blocking.remove());\n        // System.out.println(blocking.remove());\n         //System.out.println(blocking.remove());   //队列为空的话移除会抛异常:java.util.NoSuchElementException\n         //System.out.println(blocking.element());  //查看队列头的元素，没有就抛java.util.NoSuchElementException\n\n\n    //         System.out.println(blocking.offer(\"a\"));\n    //         System.out.println(blocking.offer(\"a\"));\n     //         System.out.println(blocking.offer(\"a\"));\n       //  System.out.println(blocking.offer(\"a\"));  //队列满了就false\n\n    //         System.out.println(blocking.poll());  //队列没有元素就返回null\n    //         System.out.println(blocking.poll());\n    //         System.out.println(blocking.poll());\n\n         //System.out.println(blocking.peek());//队头没有就返回null\n\n\n         //blocking.put(\"a\");\n    //         blocking.put(\"a\");\n    //         blocking.put(\"a\");\n    //         blocking.put(\"a\"); //队列满了一直阻塞,直到队列中有位置可以放\n\n         //System.out.println(blocking.take()); //队列为空一直阻塞，直到队列中有数据可以取\n\n\n    //         System.out.println(blocking.offer(\"a\"));\n    //         System.out.println(blocking.offer(\"a\"));\n    //         System.out.println(blocking.offer(\"a\"));\n    //         System.out.println(blocking.offer(\"b\",3L, TimeUnit.SECONDS));  //超过3秒还不能加进对列 就返回false\n\n       //  System.out.println(blocking.poll(3L,TimeUnit.SECONDS));//超过3秒取不到就返回null;\n\n     }\n\n\n    }\n","tags":["学习笔记"]},{"title":"juc学习笔记04","url":"/2020/05/14/juc学习笔记04/","content":"\nCallable接口\n\n这是一个函数式接口，因此可以用作lambda表达式或方法引用的赋值对象。\n\n<!-- more-->\n\n面试题：获得多线程的方法几种？\n\n继承thread类\n\nrunnable接口\n\n如果只回答这两个你连被问到juc的机会都没有  \n\n正确答案如下： 传统的是继承thread类和实现runnable接口，java5以后又有实现callable接口和java的线程池获得\n\n\n---\n面试题:callable接口与runnable接口的区别？ \n\n 答：（1）是否有返回值       （2）是否抛异常       （3）落地方法不一样，一个是run，一个是call    \n\n\n  创建新类MyThread实现runnable接口\n\nclass MyThread implements Runnable{ \n @Override public void run() {  }\n       }\n\n新类MyThread2实现callable接口\n      \nclass MyThread2 implements Callable<Integer>{\n    \n @Override public Integer call() throws Exception {  return 200; } }  \n\n\n\n---\n\n 怎么用？\n\n thread类的构造方法根本没有Callable   \n\n 这像认识一个不认识的同学，我可以找中间人介绍。中间人是什么？\n \n java多态，一个类可以实现多个接口！！\n \n\nFutureTask：\n\n未来的任务，用它就干一件事，异步调用main方法\n就像一个冰糖葫芦，一个个方法由main串起来。但解决不了一个问题：正常调用挂起堵塞问题    例子：\n\n（1）老师上着课，口渴了，去买水不合适，讲课线程继续，我可以单起个线程找班长帮忙买水，水买回来了放桌上，我需要的时候再去get。\n\n（2）4个同学，A算1+20,B算21+30,C算31*到40,D算41+50，是不是C的计算量有点大啊，FutureTask单起个线程给C计算，我先汇总ABD，最后等C计算完了再汇总C，拿到最终结果\n\n（3）高考：会做的先做，不会的放在后面做 \n\n\n代码：\n\n      public class CallableDemo {\n\n    //获得多线程的第三中方式\n\n\n     public static void main(String args[]) throws Exception {\n\n\n         /*\n         FutureTask：在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给Future对象在后台完成，\n         当主线程将来需要时，就可以通过Future对象获得后台作业的计算结果或者执行状态。\n         比如 A计算 1+1， B计算1+2，C计算116*99 D计算 3+1,那么C比较耗时，主线程执行C会很耗时，那么C交给Future对象在后台完成，\n         等直接去执行D，等ABD都搞完了，再去要C的结果，get方法\n\n         get方法去要的时候会直到要到结果或者抛出异常才执行完成否则就一直阻塞着，所以get方法写在最后，减少耗时\n          */\n         FutureTask futureTask = new FutureTask(new Mythread());\n\n\n         new Thread(futureTask,\"A\").start();\n\n         new Thread(futureTask,\"B\").start();\n         /*\n         Thread的构造方法并没有传入Callable的形参，Runnable倒是有\n         那么就要用到java的多态性，可以往里面传Runnable接口的子接口，\n         跟要女孩微信一个道理,女孩微信号就是Callable，你可以通过中间人去问，即去找已经实现了Runnable接口的接口去要\n         Runnable接口的子接口有一个是RunnableFuture<V>,RunnableFuture<V>有一个实现类FutureTask<V>，FutureTask<V>\n         的构造函数有FutureTask(Callable<V> callable)。。。。。\n\n    */\n\n         /*\n         获得线程执行完后的返回值，用get方法\n          */\n      System.out.println( futureTask.get());\n\n\n     }\n\n\n\n\n\n    }\n\n    class  Mythread implements Callable<Integer> {\n\n\n    @Override\n    public Integer call() throws Exception {\n        System.out.println(Thread.currentThread().getName()+\"come in here\");\n        try{TimeUnit.SECONDS.sleep(4);}catch(InterruptedException e){e.printStackTrace();}\n        return 1024;\n    }\n    }\n\n---\n\n### JUC强大的辅助类讲解\n\n\nCountDownLatch\n减少计数\n\nCountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。 \n\n其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)， \n\n当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。\n\n\n代码：\n\n\n      public class CountDownLatchDemo {\n\n\n     public static void main(String args[]) throws InterruptedException {\n\n         //要求：6个线程执行离开教室的任务完后，main线程最后执行关灯操作。\n\n         /*\n        原理：* CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。\n         * 其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)，\n         * 当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。\n          */\n         CountDownLatch countDownLatch=new CountDownLatch(30); //计数6个线程\n         for (int i=1;i<=30;i++){\n\n             new Thread(()->{\n\n                 System.out.println(Thread.currentThread().getName()+\"\\t\"+\"离开教室\");\n                 countDownLatch.countDown();  //调用这个方法是一个线程进来执行之后计数器会减一\n             },String.valueOf(i)).start();\n\n         }\n         countDownLatch.await(); //调用这个后mian线程到这会阻塞，等到计数器为0 了就唤醒main线程\n\n         System.out.println(Thread.currentThread().getName()+\"\\t\"+\"main关灯\");\n     }\n\n\n    }\n\n\n\n---\n\nCyclicBarrier\n循环栅栏\n\n\n CyclicBarrier 的字面意思是可循环（Cyclic）使用的屏障（Barrier）。\n \n 它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞\n \n 直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。 \n \n 线程进入屏障通过CyclicBarrier的await()方法。\n\n\n 代码：\n\n      public class CyclicBarrierDemo {\n\n\n    /*\n     * CyclicBarrier的字面意思是可循环（Cyclic）使用的屏障（Barrier）。\n     * 它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，\n     *  直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。线程进入屏障通过CyclicBarrier的await()方法。\n     */\n\n\n     public static void main(String args[])  {\n\n         //实例：收集7颗龙珠后召唤神龙。\n\n         CyclicBarrier cyclicBarrier=new CyclicBarrier(7,()->{System.out.println(\"神龙出来了\");});\n\n         for(int i=1;i<=7;i++){\n\n             final int  tempInt=i;\n             new Thread(()->{System.out.println(Thread.currentThread().getName()+\"\\t\"+\"收集到第：\"+tempInt+\"颗龙珠\");\n\n                 try {\n                     cyclicBarrier.await();\n                     //每进来一个线程，都会进入屏障，当所有的线程都进入屏障的时候，cyclicBarrier.await();\n                     // 每进来一个线程，都会进入屏障，当所有的线程都进入屏障的时候， CyclicBarrier构造的runable接口的方法才会执行\n\n                 } catch (InterruptedException e) {\n                     e.printStackTrace();\n                 } catch (BrokenBarrierException e) {\n                     e.printStackTrace();\n                 }\n\n             },String.valueOf(i)).start();\n\n         }\n\n     }\n\n\n    }\n\n\n\n\n---\n\nSemaphore\n信号灯\n\n在信号量上我们定义两种操作： \n\n acquire（获取）： 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），要么一直等下去，直到有线程释放信号量，或超时。 \n \n release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。 \n \n信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。\n\n\n代码：\n\n      public class SemaphoreDemo {\n\n    //信号灯\n    /*\n\n    在信号量上我们定义两种操作： * acquire（获取） 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），\n      * 要么一直等下去，直到有线程释放信号量，或超时。\n      * release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。\n      * 信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。\n     */\n\n\n    public static void main(String args[]) {\n\n        Semaphore semaphore = new Semaphore(3);//模拟有三个车位\n\n        for(int i=1;i<=6;i++){\n\n\n            new Thread(()->{\n\n                try {\n                    semaphore.acquire();\n                    try{\n\n                    System.out.println(Thread.currentThread().getName()+\"\\t\"+\"抢占到了车位\");\n                    TimeUnit.SECONDS.sleep(4);}catch(InterruptedException e){e.printStackTrace();}\n                    System.out.println(Thread.currentThread().getName()+\"\\t\"+\"离开了车位\");\n\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    semaphore.release();\n                }\n\n            },String.valueOf(i)).start();\n\n        }\n\n\n\n\n    }\n\n\n    }\n\n\n","tags":["学习笔记"]},{"title":"juc学习笔记03","url":"/2020/05/14/juc学习笔记03/","content":"\n多线程锁(8种类型锁演示)\n<!-- more-->\n static锁的是Class类对象(全局)，普通的锁的是this对象，你只要判断不一样就说明是不冲突的\n\n\n代码：\n\n     public class Lock8Demo {\n    //8种情况下的锁演示\n\n    /*\n     标准访问\n    1.一个手机对象，A线程调用了该对象加锁的sendEmail,B线程调用了加锁的sendSms,先输出A,再输出B，\n      同一时间一个线程只能调用对象的一个方法，不能是同时A去sendEmail,B去sendSms，因为这个是对象实例被锁起来了。\n\n      2.sendEmail暂停4秒，还是这样按照标准访问，那么还是和 1 一样的道理\n\n      3.新增普通方法，A线程去调用sendEmail的时候，不影响普通方法的输出。\n\n      4.两个手机对象，phone1发邮件，phone2发信息，那么就不影响各自。各回各家，各找各妈,两个实例对象的锁不是同一把锁\n\n      5.两个静态同步方法，同一个手机对象，那么这个时候的锁对象是当前的Class类对象,A和B冲突,那么是先邮件后短信,所以A先搞完，再到B\n\n      6.两个静态同步方法，两个手机对象，那么这个时候的锁对象是当前的Class类对象,A和B冲突\n\n\n      7.一个静态同步方法，一个普通同步方法，同一个手机对象，那么两个锁的对象不一样，A是当前的Class类对象，B是当前的实例对象,所以A 和 B不冲突\n\n      8.一个静态同步方法，一个普通同步方法，两个手机对象，那么两个锁的对象，两个锁的对象是不一样，不冲突\n\n      static锁的是Class类对象(全局)，普通的锁的是this对象，你只要判断不一样就说明是不冲突的\n     */\n\n     public static void main(String args[]) throws InterruptedException {\n\n\n         Phone phone=new Phone();\n         Phone phone2=new Phone();\n\n         new Thread(()->{\n\n             try {\n                 phone.sendEmail();\n             } catch (Exception e) {\n                 e.printStackTrace();\n             }\n\n         },\"A\").start();\n\n       //  Thread.sleep(1000);\n         new Thread(()->{\n\n             try {\n                 phone.sendSms();\n             } catch (Exception e) {\n                 e.printStackTrace();\n             }\n\n         },\"B\").start();\n\n     }\n\n    }\n\n    class  Phone{\n\n    public static synchronized  void sendEmail() throws  Exception{\n        TimeUnit.SECONDS.sleep(4);\n        System.out.println(\"*****sendEmail\");\n    }\n    public   static  synchronized  void sendSms() throws  Exception{\n\n        System.out.println(\"*****sendSms\");\n    }\n    public void sayHello()throws Exception{\n        System.out.println(\"*****sayHello\");\n    }\n\n    }\n\n\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/504235B9228E43ED81CBE11AA5AD94DA/361)\n\n\n\n### 集合类的线程不安全\n\n请举例说明集合类是不安全的\n\njava.util.ConcurrentModificationException \n\n ArrayList在迭代的时候如果同时对其进行修改就会抛出java.util.ConcurrentModificationException异常\n \n 并发修改异常\n\n\n代码：\n\n     public class NoSafeDemo {\n\n\n    //写一个证明ArrayList线程不安全的实例\n\n    /*\n    面试知识点之ArrayList ：\n\n    1.new 一个 ArrayList的时候底层实际是new 了一个Object类型数组\n    2.以java8为例，new了一个ArrayList数组内存中默认的数组大小是10 ，hashMap默认大小是16\n    3.ArrayList扩容的时候扩容原值的一半，比如说第一次扩容到15，拷贝的方法是Arrays.copyOf()\n    4.第二次扩容的时候扩容到 15 +(15/2)=22; hashMap的扩容是原值的一倍,初始在内存的大小是16\n    5.ArrayList线程不安全 ,故障原因 java.util.ConcurrentModificationException\n    解决方法：1.  List<String> list=new Vector<>();\n              2. Collections.synchronizedList(new ArrayList<>());\n              3. List<String> list=new CopyOnWriteArrayList<>();  //写时复制技术\n\n\n     6.HashSet的底层由HashMap实现，HashSet的值存放在 HashMap的key上，底层HashMap的value统一为PRESENT\n\n\n       7.set不安全，最好用Set<String> set=new CopyOnWriteArraySet<String>();\n      8.Map不安全，最好用 Map<String,Integer> map=new ConcurrentHashMap<>();\n\n      9.HashMap的面试点总结 ：\n          HashMap初始创建的长度默认为16,默认的负载因子是 0.75 ，要想还成其他的可以用其他构造\n\n          一般负载因子是不会改的，扩容的话是比如第一次，装的长度到16*0.75=12就扩容原来的一倍，也就是最后总长度是32\n          以此类推\n\n         底层其实是Node<K,V> [] （数组+链表）,put元素时，先根据key的hashcode重新计算hash值，根据hash值得到在数组中的存储位置，\n         如果该位置已经放了，那么一链表的形式存放，新加入的元素放链头，最先加入的放链尾，如果数组中的位置为空就直接放\n\n         jdk8后优化，当链表的数据超过8个后，将以红黑树的形式存放，提高查询效率\n\n\n\n\n     */\n\n\n     public static void main(String args[]) {\n\n\n         listNotSafe();\n\n     }\n\n    public static void listNotSafe() {\n\n        List<String> list=new CopyOnWriteArrayList<>();\n\n    //        list.add(\"a\");\n    //        list.add(\"a\");\n    //        list.add(\"a\");\n    //        list.forEach(System.out::println);\n\n        for(int i=1;i<=30;i++){\n\n            new Thread(()->{\n                list.add(UUID.randomUUID().toString().substring(0,8));\n                System.out.println(list);\n            },String.valueOf(i)).start();\n        }\n\n\n    /*\n         Map<String,Integer> map=new ConcurrentHashMap<>();\n        for(int i=1;i<=30;i++){\n\n            new Thread(()->{\n                map.put(UUID.randomUUID().toString().substring(0,8),1);\n                System.out.println(map);\n            },String.valueOf(i)).start();\n        }\n        */\n\n\n        /*Set<String> set=new CopyOnWriteArraySet<String>();\n        for(int i=1;i<=30;i++){\n\n            new Thread(()->{\n                set.add(UUID.randomUUID().toString().substring(0,8));\n                System.out.println(set);\n            },String.valueOf(i)).start();\n        }\n    */\n        }\n\n    }\n\n\n\n\n---\n\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/E6BDDAE7257842168BF2C793AB6A1C03/365)\n\nCopyOnWrite容器：即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器Object[]添加，而是先将当前容器Object[]进行Copy，复制出一个新的容器Object[] newElements，然后向新的容器Object[] newElements里添加元素。添加元素后，再将原容器的引用指向新的容器setArray(newElements)。这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。 ","tags":["学习笔记"]},{"title":"juc学习笔记02","url":"/2020/05/14/juc学习笔记02/","content":"\n线程间的通信\n<!-- more-->\n\n### 生产者消费者模式\n\n口诀：判断 干活 通知\n\n多线程的交互之间 必须防止线程的虚假唤醒 只能用while,不能用if判断\n\n旧版生产者消费者：\n\n      /*\n\n    旧版生产者消费者\n    public synchronized void incr() throws InterruptedException {\n\n        while (number!=0){\n\n            //不能用if判断，因为假如有多个生产者的话，比如A,B都是生产者，当A完活后，它会唤醒所有等待的线程，\n            // 万一B抢到了，那么就会进来，处在等待状态中，然后这个时候的number就是1了，它在等待中，然后接着A又进来了，这个时候A和B都在等待\n            // 接着消费者进来消费掉一个后，唤醒等待线程，B线程就干活，num变为1，B完活了后，又唤醒线程，假如这个时候A醒了干活，那么num变为2，所以会\n            //造成多加的现象\n            //所以需要while拉回来判断。。。\n            //然后消费者唤醒所有等待线程，然后要是B醒了，num+1\n\n\n            this.wait();\n        }\n        number++;\n\n        System.out.println(Thread.currentThread().getName()+\"\\t\"+number);\n\n        this.notifyAll();\n    }\n    public synchronized void decr() throws InterruptedException {\n\n        while (number==0){\n\n            this.wait();\n        }\n        number--;\n\n        System.out.println(Thread.currentThread().getName()+\"\\t\"+number);\n\n        this.notifyAll();\n    }\n\n\n    }\n       */\n\n\n\n新版生产者消费者\n\n\n     class  Cake{\n\n    private  int number=0;\n\n    private Lock lock=new ReentrantLock();\n    private Condition condition=lock.newCondition();\n\n\n    public  void incr(){\n\n\n          lock.lock();\n\n              try{\n                      while (number!=0){\n\n                          condition.await();\n\n                      }\n                  number++;\n\n                  System.out.println(Thread.currentThread().getName()+\"\\t\"+number);\n\n                  condition.signalAll();\n\n\n              }catch(Exception e){\n\n                e.printStackTrace();\n\n\n              }finally{\n\n              lock.unlock();\n\n              }\n\n    }\n\n    public void decr() throws InterruptedException {\n\n\n           lock.lock();\n\n               try{\n                       while (number==0){\n\n                           condition.await();\n                       }\n                   number--;\n\n                   System.out.println(Thread.currentThread().getName()+\"\\t\"+number);\n\n                   condition.signalAll();\n                }catch(Exception e){\n\n                 e.printStackTrace();\n\n\n               }finally{\n\n               lock.unlock();\n\n               }\n    }\n    }\n\n\n---\nJava中notify和notifyAll的区别 - 何时以及如何使用\n\n链接：https://blog.csdn.net/u014658905/article/details/81035870\n\n\n1.如果我使用notify（），将通知哪个线程？\n\n无法保证，ThreadScheduler将从等待该监视器上的线程的池中选择一个随机线程。保证只有一个线程会被通知:（随机性）\n\n\n2.我怎么知道有多少线程在等待，所以我可以使用notifyAll（）？\n\n 它取决于程序逻辑，在编码时需要考虑一段代码是否可以由多个线程运行。理解线程间通信的一个很好的例子是在Java中实现生产者 - 消费者模式。\n\n 3.如何调用notify（）？\nWait（）和notify（）方法只能从synchronized方法或块中调用，需要在其他线程正在等待的对象上调用notify方法。\n\n\n### 线程间定制化调用通信\n\n例子： 三个线程启动\n\nAA打印5次，BB打印10次，CC打印15次\n接着\nAA打印5次，BB打印10次，CC打印15次\n...来10轮\n\n\n\n口诀：\n\n1.高内聚低耦合下 线程 操作 资源类\n\n2.判断 干活 通知  线程之间交互的情况下\n\n3.多线程的交互之间 必须防止线程的虚假唤醒 只能用while,不能用if判断\n\n4.标志位\n\n---\n1、有顺序通知，需要有标识位\n\n2、有一个锁Lock，3把钥匙Condition \n\n3、判断标志位 \n\n4、输出线程名+第几次+第几轮 \n\n5、修改标志位，通知下一个   \n\n\n代码：\n\n       class Resouce{\n\n    private Lock lock=new ReentrantLock();\n    private int number=1; //标志位，初始值默认1，  A线程 1 B线程 2  C线程 3\n\n    private Condition condition1=lock.newCondition();\n    private Condition condition2=lock.newCondition();\n    private Condition condition3=lock.newCondition();\n\n\n    public  void print5(){\n           lock.lock();\n\n               try{\n                   //如果轮不到1,就等待，因为要是比如B没打印完呢，这个调度到A了，number！=1，就先等着\n\n                   while (number!=1){\n\n\n                       condition1.await();\n                   }\n                   for(int i=0;i<5;i++){\n\n                       System.out.println(Thread.currentThread().getName()+\"\\t\"+\"AA\");\n                   }\n                   number=2;\n                   condition2.signal();\n\n                }catch(Exception e){\n\n                 e.printStackTrace();\n\n\n               }finally{\n\n\n               lock.unlock();\n\n               }\n\n\n\n    }\n    public  void print10(){\n           lock.lock();\n\n               try{\n\n                   while (number!=2){\n                       condition2.await();\n                   }\n                   for(int i=0;i<10;i++){\n\n                       System.out.println(Thread.currentThread().getName()+\"\\t\"+\"BB\");\n                   }\n                   number=3;\n\n                   condition3.signal();\n\n                }catch(Exception e){\n\n                 e.printStackTrace();\n\n\n               }finally{\n\n\n\n               lock.unlock();\n\n               }\n\n\n\n    }\n    public  void print15(){\n           lock.lock();\n\n               try{\n                   while (number!=3){\n\n                       condition3.await();\n                   }\n                   for(int i=0;i<15;i++){\n\n                       System.out.println(Thread.currentThread().getName()+\"\\t\"+\"CC\");\n                   }\n                   number=1;\n                   condition1.signal();\n\n                }catch(Exception e){\n\n                 e.printStackTrace();\n\n\n               }finally{\n\n\n               lock.unlock();\n\n               }\n\n\n\n    }\n\n\n\n    }\n\n","tags":["学习笔记"]},{"title":"juc学习笔记","url":"/2020/05/14/juc学习笔记/","content":"juc学习笔记部分，大部分口诀笔记都记在代码里面了\n\n<!-- more-->\n\n卖票程序:\n\n笔记：如何写出企业级的多线程代码\n\n固定的编程套路+模板?\n\n在高内聚低耦合的前提下， 线程 操作 资源类\n\n\n创建线程的三种方式:\n\n一、继承Thread类创建线程类\n\n（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。\n\n（2）创建Thread子类的实例，即创建了线程对象。\n\n（3）调用线程对象的start()方法来启动该线程。\n\n     package com.nf147.Constroller;\n\n    public class FirstThreadTest extends Thread {\n\n    int i = 0;\n\n    //重写run方法，run方法的方法体就是现场执行体\n    public void run() {\n        for (; i < 100; i++) {\n            System.out.println(getName() + \"  \" + i);\n        }\n    }\n\n    public static void main(String[] args) {\n\n        for (int i = 0; i < 100; i++) {\n            System.out.println(Thread.currentThread().getName() + \"  : \" + i);\n            if (i == 50) {\n                new FirstThreadTest().start();\n                new FirstThreadTest().start();\n            }\n        }\n    }\n\n\n    }\n\n\n\n上述代码中Thread.currentThread()方法返回当前正在执行的线程对象。GetName()方法返回调用该方法的线程的名字。\n\n---\n\n二、通过Runnable接口创建线程类\n\n \n\n（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。\n\n \n\n（2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。\n\n \n\n（3）调用线程对象的start()方法来启动该线程。\n\n\n    package com.nf147.Constroller;\n\n    public class RunnableThreadTest implements Runnable{\n        private int i;\n        public void run()\n        {\n            for(i = 0;i <100;i++)\n            {\n                System.out.println(Thread.currentThread().getName()+\" \"+i);\n            }\n        }\n        public static void main(String[] args)\n        {\n            for(int i = 0;i < 100;i++)\n            {\n                System.out.println(Thread.currentThread().getName()+\" \"+i);\n                if(i==20)\n                {\n                    RunnableThreadTest rtt = new RunnableThreadTest();\n                    new Thread(rtt,\"新线程1\").start();\n                    new Thread(rtt,\"新线程2\").start();\n                }\n            }\n\n        }\n    }\n\n\n---\n三、通过Callable和Future创建线程\n\n \n\n（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。\n\n \n\n（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对\n象的call()方法的返回值。\n\n \n\n（3）使用FutureTask对象作为Thread对象的target创建并启动新线程\n\n \n\n（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值\n\n     package com.nf147.Constroller;\n\n    import java.util.concurrent.Callable;\n    import java.util.concurrent.ExecutionException;\n    import java.util.concurrent.FutureTask;\n\n    public class CallableThreadTest implements Callable<Integer> {\n\n\n    public static void main(String[] args) {\n        CallableThreadTest ctt = new CallableThreadTest();\n        FutureTask<Integer> ft = new FutureTask<>(ctt);\n        for (int i = 0; i < 100; i++) {\n            System.out.println(Thread.currentThread().getName() + \" 的循环变量i的值\" + i);\n            if (i == 20) {\n                new Thread(ft, \"有返回值的线程\").start();\n            }\n        }\n        try {\n            System.out.println(\"子线程的返回值：\" + ft.get());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    @Override\n    public Integer call() throws Exception {\n        int i = 0;\n        for (; i < 100; i++) {\n            System.out.println(Thread.currentThread().getName() + \" \" + i);\n        }\n        return i;\n    }\n\n\n    }\n\n\n\n\n推荐的简便写法：\n\nnew Thread(new Runnable() {    @Override    public void run() {     }   }, \"your thread name\").start();  这种方法不需要创建新的类，可以new接口\n\nnew Thread(() -> {  }, \"your thread name\").start();   这种方法代码更简洁精炼\n\n\n\n### Lock接口\n\nLock接口的实现\nReentrantLock可重入锁\n\n部分代码:\n\n    class Ticket{\n\n    private  int number=30;\n\n    Lock lock=new ReentrantLock();\n\n    public void sale(){\n\n        lock.lock();\n\n            try{\n               if(number>0) {\n                   System.out.println(Thread.currentThread().getName() + \"卖出第\" + number-- + \"\\t\" + \"张票，还剩下:\" + number + \"张\");\n               }\n            }catch(Exception e){\n\n                e.printStackTrace();\n\n\n            }finally{\n\n                lock.unlock();\n\n            }\n    }\n\n    }\n\n\n\n---\n\n\n### Java8之lambda表达式复习\n\nlambda表达式，如果一个接口只有一个方法，我可以把方法名省略Foo foo = () -> {System.out.println(\"****hello lambda\");}; \n\n\n写法：拷贝小括号（），写死右箭头->，落地大括号{...}\n\n\nlambda表达式，必须是函数式接口，必须只有一个方法如果接口只有一个方法java默认它为函数式接口。\n\n为了正确使用Lambda表达式，需要给接口加个注解：@FunctionalInterface如有两个方法，立刻报错 \n\n\n部分代码:\n\n     \n\n    //       Foo foo=new Foo() {\n    //             @Override\n    //             public void sayHello() {\n    //                 System.out.println(\"哈哈哈哈\");\n    //             }\n    //         };\n    //       foo.sayHello();\n\n         /*\n         LambdaExprecess 笔记：拷贝小括号，写死中括号，落地大括号\n          @FunctionalInterface //声明是函数式接口\n           default //可以定义一个或多个有方法体的方法，直接在接口里面进行实现\n           static  //定义一个或多个静态方法，直接在接口里面实现，接口名调用 Foo .\n          */\n\n         Foo foo=(int x, int y)->{System.out.println(x+y);};\n         foo.add(20,1);\n         int mul = foo.mul(1, 2);\n         System.out.println(mul);\n\n         int i = Foo.mul4(20, 2);\n         System.out.println(i);\n     }\n\n\n    }\n\n    @FunctionalInterface\n     interface  Foo{\n\n    //public  void  sayHello();\n    public  void   add(int x,int y);\n\n    public  default  int mul(int x,int y){\n\n        return x*y;\n    }\n    public  default  int mul2(int x,int y){\n\n        return x*y;\n    }\n    public  default  int mul3(int x,int y){\n\n        return x*y;\n    }\n\n    public  static  int mul4(int x,int y){\n\n        return x+y;\n    }\n\n\n    }\n\n\n\n\n","tags":["学习笔记"]},{"title":"volatile关键字的作用","url":"/2020/05/10/volatile关键字的作用/","content":"原文地址：https://www.cnblogs.com/xd502djj/p/9873067.html\n\n<!-- more-->\nvolatile关键字的作用\n\n以前只是看过介绍volatile的文章，对其的理解也只是停留在理论的层面上，由于最近在项目当中用到了关于并发方面的技术，所以下定决心深入研究一下java并发方面的知识。网上关于volatile的文章非常多，但是并没有讲解非常详细的文章。（哪位要是有好的资料麻烦共享一份给我！）多数的都是一些理论讲解，没有实际的例子代码，就算有代码的也测试不出效果，总之理论总是与代码不匹配。后来在我不懈的努力之下总算研究出一些成果，在此分享给大家！如果大家发现有错误的地方欢迎大家指正，谢谢！\n\n在Java线程并发处理中，有一个关键字volatile的使用目前存在很大的混淆，以为使用这个关键字，在进行多线程并发处理的时候就可以万事大吉。\n\nJava语言是支持多线程的，为了解决线程并发的问题，在语言内部引入了 同步块(synchronized) 和 volatile 关键字机制。\n\n \n\nsynchronized(不做过多解释)\n\n同步块大家都比较熟悉，通过 synchronized 关键字来实现，所有加上synchronized 和 块语句，在多线程访问的时候，同一时刻只能有一个线程能够用\n\nsynchronized 修饰的方法 或者 代码块。\n\n \n\nvolatile\n\n用volatile修饰的变量，线程在每次使用变量的时候，都会读取变量修改后的最的值。volatile很容易被误用，用来进行原子性操作。\n\n \n\n如果要深入了解volatile关键字的作用，就必须先来了解一下JVM在运行时候的内存分配过程。\n\n \n\n在 java 垃圾回收整理一文中，描述了jvm运行时刻内存的分配。其中有一个内存区域是jvm虚拟机栈，每一个线程运行时都有一个线程栈，\n\n \n\n线程栈保存了线程运行时候变量值信息。当线程访问某一个对象时候值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后把堆内存\n\n \n\n变量的具体值load到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，\n\n \n\n在修改完之后的某一个时刻（线程退出之前），自动把线程变量副本的值回写到对象在堆中变量。这样在堆中的对象的值就产生变化了。下面一幅图\n\n \n\n描述这写交互！\n\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/FD6E4140F5BC4F259FE5810F6D2E7708/355)\n\n\n那么在了解完JVM在运行时候的内存分配过程以后，我们开始真正深入的讨论volatile的具体作用\n\n请看代码:\n\n     public class VolatileTest extends Thread {\n    \n    boolean flag = false;\n    int i = 0;\n    \n    public void run() {\n        while (!flag) {\n            i++;\n        }\n    }\n    \n    public static void main(String[] args) throws Exception {\n        VolatileTest vt = new VolatileTest();\n        vt.start();\n        Thread.sleep(2000);\n        vt.flag = true;\n        System.out.println(\"stope\" + vt.i);\n    }\n    }\n\n\n上面的代码是通过标记flag来控制VolatileTest线程while循环退出的例子!\n\n下面让我用伪代码来描述一下我们的程序\n\n首先创建 VolatileTest vt = new VolatileTest();\n\n然后启动线程 vt.start();\n\n暂停主线程2秒（Main） Thread.sleep(2000);\n\n这时的vt线程已经开始执行，进行i++;\n\n主线程暂停2秒结束以后将 vt.flag = true;\n\n打印语句 System.out.println(\"stope\" + vt.i); 在此同时由于vt.flag被设置为true,所以vt线程在进行下一次\nwhile判断 while (!flag) 返回假 结束循环 vt线程方法结束退出！\n\n主线程结束\n\n上面的叙述看似并没有什么问题，“似乎”完全正确。那就让我们把程序运行起来看看效果吧，执行mian方法。2秒钟以后\n控制台打印stope-202753974。\n\n可是奇怪的事情发生了 程序并没有退出。vt线程仍然在运行，也就是说我们在主线程设置的 vt.flag = true;没有起作用。\n\n\n在这里我需要说明一下，有的同学可能在测试上面代码的时候程序可以正常退出。那是因为你的JVM没有优化造成的！在DOC下面输入 java -version 查看 如果显示Java HotSpot(TM) ... Server 则JVM会进行优化。\n\n如果显示Java HotSpot(TM) ... Client 为客户端模式，需要设置成Server模式  设置方法问Google\n\n![](https://note.youdao.com/yws/public/resource/7ba83f20ea406abfc8aa41fa079c8ac9/xmlnote/12E5593C03904EA5A460756CC7C68860/357)\n\n\n问题出现了，为什么我在主线程（main）中设置了vt.flag = true; 而vt线程在进行判断flag的时候拿到的仍然是false?\n 那么按照我们上面所讲的 “JVM在运行时候的内存分配过程” 就很好解释上面的问题了。\n\n 首先 vt线程在运行的时候会把 变量 flag 与 i (代码3,4行)从“主内存”  拷贝到 线程栈内存（上图的线程工作内存）\n\n 然后 vt线程开始执行while循环 \n\n while (!flag)进行判断的flag 是在线程工作内存当中获取，而不是从 “主内存”中获取。\n\ni++; 将线程内存中的i++; 加完以后将结果写回至 \"主内存\"，如此重复。\n\n\n\n然后再说说主线程的执行过程。 我只说明关键的地方 \n\nvt.flag = true;\n\n主线程将vt.flag的值同样 从主内存中拷贝到自己的线程工作内存 然后修改flag=true. 然后再将新值回到主内存。\n\n这就解释了为什么在主线程（main）中设置了vt.flag = true; 而vt线程在进行判断flag的时候拿到的仍然是false。\n\n那就是因为vt线程每次判断flag标记的时候是从它自己的“工作内存中”取值，而并非从主内存中取值！\n\n这也是JVM为了提供性能而做的优化。那我们如何能让vt线程每次判断flag的时候都强制它去主内存中取值呢。这就是volatile关键字的作用。\n \n\n再次修改我们的代码\n\n    public class VolatileTest extends Thread {\n    \n    volatile boolean flag = false;\n    int i = 0;\n    \n    public void run() {\n        while (!flag) {\n            i++;\n        }\n    }\n    \n    public static void main(String[] args) throws Exception {\n        VolatileTest vt = new VolatileTest();\n        vt.start();\n        Thread.sleep(2000);\n        vt.flag = true;\n        System.out.println(\"stope\" + vt.i);\n    }\n    }\n\n\n\n在flag前面加上volatile关键字，强制线程每次读取该值的时候都去“主内存”中取值。在试试我们的程序吧，已经正常退出了。\n\n ","tags":["转载"]},{"title":"快速幂算法（从零到懂）","url":"/2020/05/09/快速幂算法（从零到懂）/","content":"\n快速幂算法详解：\n\n原文地址：https://blog.csdn.net/qq_19782019/article/details/85621386\n\n","tags":["转载"]},{"title":"letcode经典算法题目(简单难度)","url":"/2020/05/07/letcode经典算法题目-简单难度/","content":"\n* 0001 两数之和\n<!-- more-->\n\n链接：http://note.youdao.com/noteshare?id=91b608c71474de5a562c22fecb814c03\n\n\n    \n* 0020 有效的括号\n\n链接：http://note.youdao.com/noteshare?id=4841e01f5759f5c21504d8633cfc40f7    \n\n\n* 0021 合并两个有序链表\n\n链接：http://note.youdao.com/noteshare?id=e151f7b3f9d2b373d2a4c26079e05289\n\n\n* 0026 删除排序数组的重复项\n\n链接：http://note.youdao.com/noteshare?id=95d9a3f270f3b736c8abc912a719116c   ","tags":["算法刷题心得"]},{"title":"数据结构-常用的10种算法第六辑（完结）","url":"/2020/05/04/数据结构-常用的10种算法第六辑（完结）/","content":"\n骑士周游(马踏棋盘游戏的解法)\n<!-- more-->\n### 马踏棋盘算法\n\n1) 马踏棋盘算法也被称为骑士周游问题\n\n2) 将马随机放在国际象棋的 8×8 棋盘 Board[0～7][0～7]的某个方格中，马按走棋规则(马走日字)进行移动。要求 每个方格只进入一次，走遍棋盘上全部 64 个方格 \n \n3) 游戏演示: http://www.4399.com/flash/146267_2.htm\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/36DE9856E7C74FF2B2278505F5957B65/228)\n\n\n1) 马踏棋盘问题(骑士周游问题)实际上是图的深度优先搜索(DFS)的应用。\n\n 2) 如果使用回溯（就是深度优先搜索）来解决，假如马儿踏了 53 个点，如图：走到了第 53 个，坐标（1,0），发 现已经走到尽头，没办法，那就只能回退了，查看其他的路径，就在棋盘上不停的回溯…… ，思路分析+代码 实现\n\n\n ![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/3E4122B919C2448CAE8227870FB0E1C1/230)\n\n3) 分析第一种方式的问题，并使用贪心算法（greedyalgorithm）进行优化。解决马踏棋盘问题.\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/A64B48407C724172BFB09AF8BF299B5A/232)\n\n\n\n### 代码如下：\n\n         public class HorseChessboard {\n\n    public  static  int X=8; //8列(x坐标)\n    public  static  int Y=8; //8行（y坐标）\n     static   boolean  [] isVisited=new boolean[X*Y]; //记录已经访问的位置\n      static boolean finished=false;//是否已经完成\n\n     //马踏棋盘游戏\n    //问题描述：8*8国际象棋盘中，要求马走走遍棋盘的每一个方格，要怎么走\n    //马走日字，即只能是先横走或者竖走，然后再从横或者竖的地方向对角线走\n\n    /*\n    这个其实是图的深度优先遍历\n    就是说先从一个方向一直，不通再回溯去寻找其他\n\n    思路分析:\n    首先是棋盘，需要定义一个二维数组来设计\n\n    记录当前节点已经访问，计算马在当前位置还能走的地方(最多有8个位置)，用一个集合来存储，每走一步step+1\n    直到step等于棋盘的总格子数，遍历集合中存放的可以走的位置，先选择第一个一直递归下去，如果走的通就一直走，否则就回溯\n    每到一个方法，如果不能再走了，发现step没有达到数量，说明任务没有完成，那么就把当前这个方法的棋盘置为0\n\n     */\n\n\n     public static void main(String args[]) {\n\n       int row=1;\n       int col=1;\n       int [] []chess=new int [X][Y];\n       horseChessboard(chess,row-1,col-1,1);\n\n       //输出\n\n         for(int [] rows:chess){\n\n             System.out.println(Arrays.toString(rows));\n         }\n     }\n\n\n     //马踏棋盘核心方法\n\n    //row是当前是第几行，col是当前是第几列(row和col都是从0开始)\n    public static void  horseChessboard(int [] [] chess,int row,int col,int step ){\n      //row就相当于与y坐标，col代表x坐标\n\n\n        chess[row][col]=step;//每去到一个格子，就把step的值先赋给该格子，也就是初始为0，然后去到下一个格子就step为2了，\n                            //然后就把该格子的值置为1，后面会判断是否到达数量\n         //设置当前位置已经访问\n\n        isVisited[row * X +col]=true;\n\n        Point cur=new Point(col,row);\n        ArrayList<Point> next = next(cur);\n\n        sort(next);\n        while (!next.isEmpty()){\n\n            Point point = next.remove(0);\n\n            if(!isVisited[point.y*X + point.x]) {\n                horseChessboard(chess, point.y, point.x, step + 1);\n            }\n        }\n\n        if(step<X*Y && finished==false){\n\n            chess[row][col]=0; //到这说明该格子已经无路可走了，那么就要回溯，所以把该格子的值设为0，这样才不影响\n\n            isVisited[row* X+col]=false;\n\n        }\n        else{\n\n            finished=true;\n        }\n\n\n\n    }\n\n\n     //求得马在当前的位置还能走的位置的集合\n     public static  ArrayList<Point> next(Point curPoint){\n\n\n         ArrayList<Point> ps=new ArrayList<>();\n\n         Point p1=new Point();\n\n         //判断5这个位置\n         if((p1.x=curPoint.x-2)>=0 && (p1.y=curPoint.y-1)>=0){\n\n             ps.add(new Point(p1));\n\n         }\n\n         //6这个位置\n\n         if ((p1.x=curPoint.x-1)>=0 && (p1.y=curPoint.y-2)>=0){\n\n             ps.add(new Point(p1));\n         }\n\n         //7\n\n         if((p1.x=curPoint.x+1)<X &&(p1.y=curPoint.y-2)>=0){\n\n             ps.add(new Point(p1));\n         }\n\n         //0\n         if((p1.x=curPoint.x+2)<X &&(p1.y=curPoint.y-1)>=0){\n\n             ps.add(new Point(p1));\n         }\n\n         //1\n         if((p1.x=curPoint.x+2)<X && (p1.y=curPoint.y+1)<Y){\n\n             ps.add(new Point(p1));\n\n         }\n         //2\n         if((p1.x=curPoint.x+1)<X && (p1.y=curPoint.y+2)<Y){\n\n             ps.add(new Point(p1));\n         }\n\n         //3\n         if((p1.x=curPoint.x-1)>=0 && (p1.y=curPoint.y+2)<Y){\n\n             ps.add(new Point(p1));\n         }\n         //4\n         if((p1.x=curPoint.x-2)>=0 &&(p1.y=curPoint.y+1)<Y){\n\n             ps.add(new Point(p1));\n         }\n\n     return  ps;\n\n\n\n     }\n\n\n     //运用贪心算法进行优化，每次选择该点可走位置的下一个可走位置的最小的数量的，就是选择一个走的位置，让马走到这个位置（3）后，同时马\n    //在该位置（3）的下一个可选位置的数量是相比之前选择的其他位置的数量少。\n     public static void sort(ArrayList<Point> ps){\n\n         //进行一个非递减排序，也就是升序但是数据可重复\n         //比如：1 2 2 3 4 5 5 5 6\n\n         ps.sort(new Comparator<Point>() {\n             @Override\n             public int compare(Point o1, Point o2) {\n                 if(next(o1).size()>next(o2).size()){\n\n                     return 1;\n                 }\n                 else if(next(o1).size()<next(o2).size()){\n\n                     return -1;\n                 }\n                 else {\n                     return 0;\n                 }\n             }\n         });\n\n\n\n     }\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n完结撒花！\n\n给自己的忠告：无他，唯手熟尔！\n","tags":["学习笔记"]},{"title":"数据结构-常用的10种算法第五辑","url":"/2020/05/04/数据结构-常用的10种算法第五辑/","content":"\n求图的某一个顶点到其他顶点的最短距离的问题\n\n<!-- more-->\n\n### 迪杰斯特拉算法\n\n看一个应用场景和问题:\n\n ![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/09CB878D9164492E8F503B773743FE32/212)\n\n 1) 战争时期，胜利乡有 7 个村庄(A, B, C, D, E, F, G) ，现在有六个邮差，从 G 点出发，需要分别把邮件分别送到 A, B, C , D, E, F 六个村庄 \n \n 2) 各个村庄的距离用边线表示(权) ，比如 A – B 距离 5 公里 \n \n 3) 问：如何计算出 G 村庄到 其它各个村庄的最短距离? 4) 如果从其它点出发到各个点的最短距离又是多少?\n\n\n #### 迪杰斯特拉(Dijkstra)算法介绍\n\n 迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个结点到其他结点的最短路径。它的主要特点是以 起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。\n\n 1) 设置出发顶点为 v，顶点集合 V{v1,v2,vi...}，v 到 V 中各顶点的距离构成距离集合 Dis，Dis{d1,d2,di...}，Dis 集合记录着 v 到图中各顶点的距离(到自身可以看作 0，v 到 vi 距离对应为 di) \n \n 2) 从 Dis 中选择值最小的 di 并移出 Dis 集合，同时移出 V 集合中对应的顶点 vi，此时的 v 到 vi 即为最短路径\n\n 3) 更新 Dis 集合，更新规则为：比较 v 到 V 集合中顶点的距离值，与 v 通过 vi 到 V 集合中顶点的距离值，保留 值较小的一个(同时也应该更新顶点的前驱节点为 vi，表明是通过 vi 到达的) \n \n 4) 重复执行两步骤，直到最短路径顶点为目标顶点即可结束\n\n ![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/C1C54EF20B3D4F0FA4C873CC72112643/214)\n\n---\n ### 代码实现\n\n          public class DijkstraAlgorithm {\n\n    public static void main(String[] args) {\n\n       // 迪杰斯特拉算法\n\n        /*\n        求一个点到其他点的最短路径。\n        三个数组，一个用来记录顶点的访问情况，一个用来记录顶点的前驱节点，一个用来记录从出发点到各个顶点的最短距离\n         */\n        char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' };\n        int[][] matrix = new int[vertex.length][vertex.length];\n        final int  N=65535;\n        matrix[0]=new int[]{N,5,7,N,N,N,2};\n        matrix[1]=new int[]{5,N,N,9,N,N,3};\n        matrix[2]=new int[]{7,N,N,N,8,N,N};\n        matrix[3]=new int[]{N,9,N,N,N,4,N};\n        matrix[4]=new int[]{N,N,8,N,N,5,4};\n        matrix[5]=new int[]{N,N,N,4,5,N,6};\n        matrix[6]=new int[]{2,3,N,N,4,6,N};\n\n        Graph graph=new Graph(vertex.length,vertex,matrix);\n\n        //graph.showGraph();\n       // graph.update(6);\n        graph.dijkstraAlgorithm(6);\n        System.out.println(Arrays.toString(graph.vv.arr_already));\n        System.out.println(Arrays.toString(graph.vv.arr_pre));\n        System.out.println(Arrays.toString(graph.vv.arr_dis));\n\n        graph.print(6);\n    }\n\n     }\n\n\n     class  Graph{\n\n    int vertexs;//顶点个数\n    char [] data;//顶点数组\n    int [] [] weight;//邻接矩阵\n     VisitedVertex vv;\n    public Graph(int vertexs, char[] data, int[][] weight) {\n        this.vertexs = vertexs;\n        this.data = data;\n        this.weight = weight;\n    }\n\n      //遍历图\n    public void showGraph(){\n\n        for(int i=0;i<vertexs;i++){\n\n            for(int j=0;j<vertexs;j++){\n\n\n                System.out.printf(\"%12d\",weight[i][j]);;\n\n            }\n            System.out.println();\n        }\n\n    }\n\n    //先把从第一个节点出发后的情况写出来\n\n    //index是出发点的坐标\n    public  void update(int index){\n\n\n        //遍历图\n        int len=0;\n\n\n            for(int j=0;j<vertexs;j++){  //只要在每一行的列中寻找就可以了,所以就是遍历每一行的列就可以了\n\n                len=vv.getDis(index)+weight[index][j]; //len就是从出发点到某一个该index的距离+从该index的点到某一个顶点的距离\n                                                        //比如说现在的index是0（A），j是2（B），那么从G点（假设是出发点）出发到\n                                                       //B点，可能的情况是可以直接从G点到B点，也可以能是从G 到  A 再到 B\n                                                       //那么从G点到B点的最短距离，就要拿着两种可能的情况进行比较谁小。。\n                if(vv.isV(j)==false &&  len< vv.getDis(j)){\n\n                    //进行更新\n                    vv.updateDis(j,len);\n\n                    vv.updatePre(j,index);\n\n                }\n\n\n        }\n\n    }\n\n\n\n     //写一个方法获取下一个访问的顶点，比如说从G点访问完后，就需要选取G点到哪一个点的距离是最小的，就选取该点作为下一个访问的节点\n\n    public  int updateArr(){\n\n\n        int min=65535;\n        int index=0;\n        for(int i=0;i<vertexs;i++){\n\n\n            if(!vv.isV(i) && vv.getDis(i)<min){\n\n                min=vv.getDis(i);\n                index=i;\n            }\n\n        }\n        vv.arr_already[index]=1;\n        return  index;\n\n    }\n\n    //核心方法\n    public  void dijkstraAlgorithm(int index){\n        vv=new VisitedVertex(vertexs,index);\n           update(index);\n\n        for(int i=1;i<vertexs;i++){\n            index=updateArr();\n            update(index);\n        }\n\n\n\n\n    }\n\n    public  void print(int index){\n\n        char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' };\n\n        for(int i=0;i<vv.arr_dis.length;i++){\n    if(vv.arr_dis[i]!=65535 && i!=index){\n\n    System.out.println(\"从\"+vertex[index]+\"点到\"+vertex[i]+\"点的最短距离是\"+vv.arr_dis[i]);\n         }\n    else {\n\n        System.out.println(\"从该点到其他点为无效距离！\");\n    }\n\n        }\n\n\n\n    }\n    }\n\n    class  VisitedVertex{\n\n     int [] arr_already;//记录访问情况\n      int [] arr_pre; //记录顶点的前驱节点\n      int [] arr_dis; //记录从出发点到各个顶点的最短距离\n\n\n    //vertex代表顶点的个数，index代表出发点\n    public   VisitedVertex(int vertex,int index){\n\n        arr_already=new int [vertex];\n\n        arr_already[index]=1; //出发点记为已经访问\n        arr_pre=new int[vertex];\n\n        arr_dis=new int [vertex];\n\n        Arrays.fill(arr_dis,65535);\n        arr_dis[index]=0; //记录最短距离的数组,设置出发点到出发点的距离为0\n\n\n\n    }\n\n    //判断顶点是否被访问\n\n    public  boolean isV(int index){\n\n        return  arr_already[index]==1;\n\n    }\n\n    //获取从出发点到某个顶点的最短距离\n\n    public  int getDis(int index){\n\n        return  arr_dis[index];\n\n    }\n\n    //更新顶点的前驱节点\n\n    //index表示是去到了哪个顶点，j表示该顶点的前驱节点是j\n    public  void updatePre(int index,int j){\n\n\n        arr_pre[index]=j;\n\n    }\n\n    //更新从出发点到某个顶点的最短距离\n    //index表示是去到了哪个顶点，j表示当前从出发点到该顶点的最短距离\n    public  void updateDis(int index,int j){\n\n        arr_dis[index]=j;\n\n    }\n\n    }\n\n\n\n\n\n\n\n\n### 弗洛伊德算法\n\n1) 和 Dijkstra 算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法 名称以创始人之一、1978 年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名 \n\n2) 弗洛伊德算法(Floyd)计算图中各个顶点之间的最短路径 \n\n3) 迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。 \n\n4) $\\color{green}{弗洛伊德算法 VS 迪杰斯特拉算法：迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点 的最短路径；弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每 一个顶点到其他顶点的最短路径}$\n\n\n#### 弗洛伊德(Floyd)算法图解分析\n\n1) 设置顶点 vi 到顶点 vk 的最短路径已知为 Lik，顶点 vk 到 vj 的最短路径已知为 Lkj，顶点 vi 到 vj 的路径为 Lij， 则 vi 到 vj 的最短路径为：min((Lik+Lkj),Lij)，vk 的取值为图中所有顶点，则可获得 vi 到 vj 的最短路径 \n\n2) 至于 vi 到 vk 的最短路径 Lik 或者 vk 到 vj 的最短路径 Lkj，是以同样的方式获得\n\n3) 弗洛伊德(Floyd)算法图解分析-举例说明\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/20AF2ABE1D744C76B14AA82BED9A5E2B/216)\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/6E565F0052774F28A02309631E35C229/218)\n\n\n\n弗洛伊德算法的步骤： 第一轮循环中，以 A(下标为：0)作为中间顶点【即把 A 作为中间顶点的所有情况都进行遍历, 就会得到更新距离表 和 前驱关系】， 距离表和前驱关系更新为：\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/CFECB3895CBD4348869CEAFC1F99E2BB/220)\n\n分析如下： \n\n1) 以 A 顶点作为中间顶点是，B->A->C 的距离由 N->12，同理 C 到 B；C->A->G 的距离由 N->9，同理 G 到 C \n\n2) 更换中间顶点，循环执行操作，直到所有顶点都作为中间顶点更新后，计算结束\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/4EB94EE8825A46F69AB6F98A73C0CA4D/222)\n\n\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/AF3F40A12A8347348B614C18549C6D13/224)\n\n\n\n应用：\n\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/56612CDC20DE419A99C50234C02BFEFD/226)\n\n\n#### 代码实现：\n\n\n      public class FloydAlgorithm {\n\n    //弗洛伊德算法\n    //该算法是求一个无向图中所有的顶点到其他顶点的最小距离，就是以图中的每一个点都要作为出发点，\n    // 都会的到每一个顶点到其他顶点的最小的距离\n\n    //思路分析：分别以图中的每一个顶点为中间节点,比如以A为中间顶点， 比如说有B-A-C的距离为9，如果9小于原来邻接矩阵中B-C的距离\n     //那么就把9赋给邻接矩阵中B-C对应的权值。同时会有一个邻接矩阵，是存着顶点的前驱节点的，比如 A-A 就是A，A-B 。。。就是A\n    //B-C就是B。。。 那么就要同时更新前驱节点，所以这个时候B-C的前驱节点就是A(中间节点)。\n\n    //用程序来实现就是三层for循环，第一层是遍历所有节点作为中间节点，第二层是遍历所有节点作为出发点，第三层是遍历所有节点作为终点\n\n     public static void main(String args[]) {\n\n\n         char[] data = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};\n         int[][] matrix = new int[data.length][data.length];\n         final int N = 65535;\n         matrix[0] = new int[]{0, 5, 7, N, N, N, 2};\n         matrix[1] = new int[]{5, 0, N, 9, N, N, 3};\n         matrix[2] = new int[]{7, N, 0, N, 8, N, N};\n         matrix[3] = new int[]{N, 9, N, 0, N, 4, N};\n         matrix[4] = new int[]{N, N, 8, N, 0, 5, 4};\n         matrix[5] = new int[]{N, N, N, 4, 5, 0, 6};\n         matrix[6] = new int[]{2, 3, N, N, 4, 6, 0};\n\n         Graph graph=new Graph(data,matrix);\n         graph.floydAlgorithm();\n         graph.print();\n     }\n     }\n\n    class  Graph{\n\n    int [] [] dis;//用来存放各个顶点到其他顶点最小的距离的邻接矩阵，最后的结果就是这个\n    int [][]  pre;//用来存放前驱节点\n    char [] data; //字符数组\n    int [][] martix;//邻接矩阵\n\n    public Graph(char[] data, int[][] martix) {\n        this.data = data;\n        this.martix = martix;\n        this.dis=martix;//初始化dis数组\n        this.pre=new int [data.length] [data.length];\n        for(int i=0;i<dis.length;i++){\n\n            for(int j=0;j<dis.length;j++){\n\n                pre[i][j]=i;\n\n            }\n\n        }\n    }\n\n\n    //输出图\n\n    public  void print(){\n\n        for(int i=0;i<dis.length;i++){\n\n\n            for(int k=0;k<dis.length;k++){\n\n                System.out.printf(\"%12d\",pre[i][k] );\n\n            }\n            System.out.println();\n            for(int j=0;j<dis.length;j++){\n\n\n                System.out.printf(data[i]+\"点到\"+data[j]+\"点的最小距离为:\"+dis[i][j]+\" \");\n\n            }\n\n            System.out.println();\n\n\n\n        }\n\n\n    }\n\n\n\n    //弗洛伊德算法核心方法\n\n    public  void  floydAlgorithm(){\n        int len=0;\n        //最外层是中间顶点\n        for(int k=0;k<dis.length;k++){\n\n            //第二层是出发顶点\n            for(int i=0;i<dis.length;i++){\n\n                //第三层是终点\n                for(int j=0;j<dis.length;j++){\n\n                  len=dis[i][k]+dis[k][j];\n\n                  if(len<dis[i][j]){\n\n                      dis[i][j]=len; //更新dis矩阵对应坐标的权值\n\n                      pre[i][j]=pre[k][j];//前驱矩阵赋值\n                  }\n\n\n                }\n\n\n            }\n\n\n\n        }\n\n\n\n\n    }\n\n     }\n","tags":["学习笔记"]},{"title":"数据结构-常用的10种算法第四辑","url":"/2020/05/04/数据结构-常用的10种算法第四辑/","content":"\n求最小生成树的问题\n\n<!-- more-->\n\n### 普利姆算法应用场景\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/AAD4FFD31A0642B3BD31833414D82614/198)\n\n\n1) 有胜利乡有 7 个村庄(A, B, C, D, E, F, G) ，现在需要修路把 7 个村庄连通 \n\n2) 各个村庄的距离用边线表示(权) ，比如 A – B 距离 5 公里 \n\n3) 问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短? \n\n4) 求最小生成树的算法主要是普里姆算法和克鲁斯卡尔算法\n思路: 将 10 条边，连接即可，但是总的里程数不是最小. 正确的思路，就是尽可能的选择少的路线，并且每条路线最小，保证总里程数最少\n\n\n修路问题本质就是就是最小生成树问题， 先介绍一下最小生成树(Minimum Cost Spanning Tree)，简称 MST。 给定一个带权的无向连通图,如何选取一棵生成树,使树上所有边上权的总和为最小,这叫最小生成树 \n\n1) N 个顶点，一定有 N-1 条边 \n\n2) 包含全部顶点 \n\n3) N-1 条边都在图中\n\n\n### 普里姆算法介绍\n\n直接图解吧，文字太难理解了\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/5F89FAC9BC104E1595ACBB7AD51995FB/200)\n\n\n\n代码如下:\n\n\n       public class PrimAlgorithm {\n\n\n     public static void main(String args[]) {\n\n\n         //普利姆算法：求一个无向图的最小生成树时，从图上的一个点出发，先求出该点直接相连的最短的路径，\n         // 比如说是A->B,然后去到B点，再求出该点与其他点直接相连的最小路径（已经走过的路径不要再走）\n\n         char [] data={'A','B','C','D','E','F','G'};\n\n         int [][]weight=new int[][]{\n                 {10000,5,7,10000,10000,10000,2},\n                 {5,10000,10000,9,10000,10000,3},\n                 {7,10000,10000,10000,8,10000,10000},\n                 {10000,9,10000,10000,10000,4,10000},\n                 {10000,10000,8,10000,10000,5,4},\n                 {10000,10000,10000,4,5,10000,6},\n                 {2,3,10000,10000,4,6,10000},};\n         MGraph mGraph = cerateMGraph(data.length, weight, data);\n\n         primAlgorithm(mGraph,1);\n\n\n\n\n     }\n\n     //普利姆算法核心\n\n    public  static  void  primAlgorithm(MGraph mGraph,int index){\n\n         int  visited[]=new int [mGraph.vertexs];  //定义一个数组，比如说1索引的值为1就代表第二个顶点已经被访问\n         int weight=10000;\n         int h1=-1;  //定义行坐标\n         int h2=-1; //定义列坐标\n\n         visited[index]=1;//表示传进来的顶点已经被访问\n\n\n        for(int k=1;k<mGraph.vertexs;k++) {   //第一层for是因为最小生成树有N-1条边，N表示顶点的个数\n\n\n            for (int i = 0; i < mGraph.vertexs; i++) {\n\n                for (int j = 0; j < mGraph.vertexs; j++) {\n\n                    //也就是在图的邻接矩阵的一行中寻找进来的顶点与其他顶点的最小距离\n\n                    //这个条件表示只有已经访问的顶点并且该顶点已经去过的顶点不能再去,比如A->B，后,B就不能到A了\n                    if (visited[i] == 1 && visited[j] == 0 && mGraph.edges[i][j] < weight) {\n\n                        weight = mGraph.edges[i][j];\n                        h1 = i;  //当前的顶点，也就是当前邻接矩阵的行\n                        h2 = j; //j是当前顶点到某个顶点x的距离最小的那个顶点的行，也就是在邻接矩阵中要定位到哪一行\n\n\n                    }\n                }\n\n            }\n            visited[h2] = 1;  //循环结束后，h2的值就是表示h1坐标对应的顶点到h2对应的顶点的距离是最小的，这个时候要让\n                              //h2对应的顶点设为已经访问\n            System.out.println(\"从\" + mGraph.data[h1] + \"点到\" + mGraph.data[h2] + \"点的最短路径为\" + weight);\n\n            //重新赋为初始值，避免下一条的最小路径是拿上一条的最小路径比较出来的\n            weight = 10000;\n\n        }\n\n    }\n\n     public static void  showGraph(MGraph mGraph){\n\n\n         for(int [] link: mGraph.edges){\n\n             System.out.println(Arrays.toString(link));\n         }\n\n     }\n     //生成一个图\n\n    public static MGraph cerateMGraph(int vertexs,int [][] egeds,char [] data){\n\n         MGraph mGraph=new MGraph(vertexs);\n\n         for(int i=0;i<vertexs;i++){\n\n             mGraph.data[i]=data[i];\n             for(int j=0;j<vertexs;j++){\n\n                 mGraph.edges[i][j]=egeds[i][j];\n\n\n             }\n\n         }\n\n         return  mGraph;\n    }\n\n     }\n\n     //定义一个图\n     class  MGraph{\n\n     int vertexs;//顶点的个数\n     char [] data;//顶点数组\n     int [] [] edges;//邻接矩阵\n\n\n\n    public MGraph(int vertexs) {\n        this.vertexs = vertexs;\n\n        data=new char[vertexs];\n        edges=new int [vertexs][vertexs];\n    }\n    }\n\n\n---\n### 克鲁斯卡尔算法\n\n应用场景-公交站问题\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/845EBC620ADB4B2095229BCBA2E8C112/202)\n\n1) 某城市新增 7 个站点(A, B, C, D, E, F, G) ，现在需要修路把 7 个站点连通 \n\n2) 各个站点的距离用边线表示(权) ，比如 A – B 距离 12 公里 3) 问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短?\n\n\n 基本思想:\n\n1) 克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。 \n\n2) 基本思想：按照权值从小到大的顺序选择 n-1 条边，并保证这 n-1 条边不构成回路 \n\n3) 具体做法：首先构造一个只含 n 个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森 林中不产生回路，直至森林变成一棵树为止\n\n\n#### 克鲁斯卡尔算法图解说明\n\n在含有 n 个顶点的连通图中选择 n-1 条边，构成一棵极小连通子图，并使该连通子图中 n-1 条边上权值之和达到 最小，则称其为连通网的最小生成树。\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/FABF51074B9F400CB20ED4F976AD4EF6/204)\n\n例如，对于如上图 G4 所示的连通网可以有多棵权值总和不相同的生成树。\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/8F87941721D04CBBBE54BF13C09B5091/206)\n\n\n\n\n\n\n##### 克鲁斯卡尔算法图解\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/EC57BE37F329404496AE2DFA67A1385E/208)\n\n第 1 步：将边<E,F>加入 R 中。 边<E,F>的权值最小，因此将它加入到最小生成树结果 R 中。 \n\n第 2 步：将边<C,D>加入 R 中。 上一步操作之后，边<C,D>的权值最小，因此将它加入到最小生成树结果 R 中。 \n\n第 3 步：将边<D,E>加入 R 中。 上一步操作之后，边<D,E>的权值最小，因此将它加入到最小生成树结果 R 中。\n\n\n第 4 步：将边<B,F>加入 R 中。 上一步操作之后，边<C,E>的权值最小，但<C,E>会和已有的边构成回路；因此，跳过边<C,E>。同理，跳 过边<C,F>。将边<B,F>加入到最小生成树结果 R 中。 \n\n第 5 步：将边<E,G>加入 R 中。 上一步操作之后，边<E,G>的权值最小，因此将它加入到最小生成树结果 R 中。 \n\n第 6 步：将边<A,B>加入 R 中。 上一步操作之后，边<F,G>的权值最小，但<F,G>会和已有的边构成回路；因此，跳过边<F,G>。同理，跳 过边<B,C>。将边<A,B>加入到最小生成树结果 R 中。\n\n\n 此时，最小生成树构造完成！它包括的边依次是：<E,F> <C,D> <D,E> <B,F> <E,G> <A,B>。\n\n\n问题分析：\n\n根据前面介绍的克鲁斯卡尔算法的基本思想和做法，我们能够了解到，克鲁斯卡尔算法重点需要解决的以下两个问题：\n\n问题一 对图的所有边按照权值大小进行排序。 \n\n问题二 将边添加到最小生成树中时，怎么样判断是否形成了回路。 \n\n\n问题一很好解决，采用排序算法进行排序即可。\n\n问题二，处理方式是：记录顶点在\"最小生成树\"中的终点，顶点的终点是\"在最小生成树中与它连通的最大顶点\"。 然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。\n\n\n那么如何判断是否构成回路呢？\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/BD8F10C562BD4BEF8A1B46CAE2C947BA/210)\n\n\n在将<E,F> <C,D> <D,E>加入到最小生成树 R 中之后，这几条边的顶点就都有了终点： \n\n(01) C 的终点是 F。\n\n(02) D 的终点是 F。 \n \n(03) E 的终点是 F。 \n \n(04) F 的终点是 F。 关于终点的说明： \n\n1) 就是将所有顶点按照从小到大的顺序排列好之后；某个顶点的终点就是\"与它连通的最大顶点\"。 \n\n2) 因此，接下来，虽然<C,E>是权值最小的边。但是 C 和 E 的终点都是 F，即它们的终点相同，因此，将<C,E> 加入最小生成树的话，会形成回路。这就是判断回路的方式。也就是说，我们加入的边的两个顶点不能都指向同一 个终点，否则将构成回路。【后面有代码说明】\n\n\n### 代码实现\n\n            public class KruskalCase {\n\n\n    private  int vertexs;//图中顶点的个数\n    private  int edgNum;//图中边的个数\n    private  char [] data;//顶点字符数组\n    private  int [][] weight;//邻接矩阵\n    private  static  final int  INF=Integer.MAX_VALUE;\n     public static void main(String args[]) {\n\n\n         //克鲁斯卡尔算法\n\n         //基本思路分析：就是把一个带权图N个顶点，构成一颗边为N-1的极小连通图。\n         /*\n         把图中的边按照权值进行排序，从小到大，依次连接，但是不能构成回路。\n\n         构成回路的条件是当前加入的边的两个顶点的终点不能一样。顶点的终点是一个顶点所能连通的最大顶点。\n\n          */\n\n\n         char[] data = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};\n\n         int matrix[][] = {\n                 /*A*//*B*//*C*//*D*//*E*//*F*//*G*/\n                 /*A*/ {   0,  12, INF, INF, INF,  16,  14},\n                 /*B*/ {  12,   0,  10, INF, INF,   7, INF},\n                 /*C*/ { INF,  10,   0,   3,   5,   6, INF},\n                 /*D*/ { INF, INF,   3,   0,   4, INF, INF},\n                 /*E*/ { INF, INF,   5,   4,   0,   2,   8},\n                 /*F*/ {  16,   7,   6, INF,   2,   0,   9},\n                 /*G*/ {  14, INF, INF, INF,   8,   9,   0}};\n\n\n\n           KruskalCase kruskalCase=new KruskalCase(data,matrix);\n\n\n\n\n\n\n         kruskalCase.kruskalCase();\n\n     }\n\n     public  void  kruskalCase(){\n\n         //定义一个接收结果的Edge集合\n         Edge [] rest=new Edge[this.edgNum];\n         int index=0;//接收数组的下标\n         int [] end=new int [this.edgNum];//存放当前最小生成树的每一个顶点的终点值，【1,2,3】代表第一个字符的终点是1索引对应的字符\n\n         Edge[] edges = getEdges();\n         sortEdges(edges);\n         //遍历边的集合，依次连接，不能有回路\n         for(int i=0;i<edges.length;i++){\n\n             int m=getPosition(edges[i].start);//获取当前边的起点下标\n\n             int n=getPosition(edges[i].end);//获取当前边的末点下标\n\n\n             //获取起点的终点\n             int end1 = getEnd(end,m);\n\n             //获取末点的终点\n             int end2=getEnd(end,n);\n\n             if(end1!=end2){\n                 //说明可以添加\n\n                end[end1]=end2;//\n\n                 rest[index++]=edges[i];\n             }\n\n         }\n\n         print(rest,index);\n     }\n\n     //初始化字符数组和邻接矩阵\n\n    public  KruskalCase(char [] data, int [] [] weight){\n\n         this.vertexs=data.length;\n\n         this.data=new char[vertexs];\n         this.weight=new int [vertexs] [vertexs];\n         //初始化字符数组\n         for(int i=0;i<vertexs;i++){\n\n             this.data[i]=data[i];\n\n         }\n\n         //初始化邻接矩阵\n        for(int i=0;i<vertexs;i++){\n\n\n            for (int j=0;j<vertexs;j++){\n\n                this.weight[i][j]=weight[i][j];\n            }\n        }\n\n        //统计边的个数\n\n        for(int i=0;i<vertexs;i++){\n\n            for (int j=i+1;j<vertexs;j++){\n\n                if(weight[i][j]!=INF) {\n                    this.edgNum++;\n                }\n            }\n\n        }\n\n\n    }\n\n    public  void print(Edge [] rest,int index){\n\n         for(int i=0;i<index;i++){\n\n             System.out.println(rest[i]);\n         }\n\n\n    }\n\n    //定位一个顶点在数组中的下标\n\n    public  int getPosition(char c){\n\n         for(int i=0;i<this.data.length;i++){\n\n             if(c==this.data[i]){\n\n                 return  i;\n             }\n\n         }\n         return  -1;\n\n    }\n\n\n    //存放某个顶点的终点\n\n    public  int getEnd(int [] end,int a){\n\n      while (end[a]!=0){\n\n          //如果当前顶点在终点数组中有对应的终点，但是可能这个终点值是局部的，那么就继续去它的终点值对应的索引去寻找下一个终点值\n          //直到没有发现终点值了就返回\n          //比如说啊，在加入了边 E,F  C,D  D,E 后数组就会变成 0 0 3 5 5 0 0...\n          //那么加入C,E后,因为之前C的位置有个局部终点是3，那么就去到3的索引找到一个值是5，还是不等于0，那么就去到5这个索引发现值为0了，那么\n          //就返回5,那么进行比较的时候就回路\n          a=end[a];\n      }\n      return  a; //如果如果循环不执行，那么说明数组中没有该点的终点，就先认为该点的终点是本身\n\n    }\n\n\n    //获取边的集合\n    public  Edge[] getEdges(){\n         Edge[] edges=new Edge[edgNum];\n         int index=0;\n         for(int i=0;i<vertexs;i++){\n\n             for (int j=i+1;j<vertexs;j++){\n\n                 if( this.weight[i][j]!=INF ){\n\n                     edges[index++]=new Edge(this.data[i],this.data[j],weight[i][j]);\n\n                 }\n             }\n\n         }\n\n         return  edges;\n\n    }\n\n    //对边的集合进行排序\n\n    public  void sortEdges(Edge [] edges){\n\n         //这里采用冒泡排序\n\n\n        for(int i=0;i<edges.length-1;i++){\n\n            for (int j=0;j<edges.length-i-1;j++){\n\n                if(edges[j].weight>edges[j+1].weight){\n\n                    Edge temp=edges[j];\n                    edges[j]=edges[j+1];\n                    edges[j+1]=temp;\n\n                }\n\n            }\n\n        }\n\n\n    }\n    }\n\n    //边类\n    class  Edge{\n\n     char start;//起始点\n     char end;//末位点\n     int weight;//边的权值\n\n\n    public Edge(char start, char end, int weight) {\n        this.start = start;\n        this.end = end;\n        this.weight = weight;\n    }\n\n    @Override\n    public String toString() {\n        return \"Edge{\" +\n                \"start=\" + start +\n                \", end=\" + end +\n                \", weight=\" + weight +\n                '}';\n    }\n    }\n\n\n    ","tags":["学习笔记"]},{"title":"数据结构-常用的10种算法第三辑","url":"/2020/05/04/数据结构-常用的10种算法第三辑/","content":"\n贪心算法的应用：\n<!-- more-->\n### 贪心算法 应用场景-集合覆盖问题\n\n假设存在下面需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有的地区 都可以接收到信号\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/D1B764E1283345BE9F37E0FA4BA4FDF1/194)\n\n\n1) 贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而 希望能够导致结果是最好或者最优的算法\n\n2) 贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果\n\n\n使用贪婪算法，效率高:\n\n 1) 目前并没有算法可以快速计算得到准备的值， 使用贪婪算法，则可以得到非常接近的解，并且效率高。选择策略上，因为需要覆盖全部地区的最小集合: \n \n 2) 遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台(此电台可能包含一些已覆盖的地区，但没有关 系） \n \n 3) 将这个电台加入到一个集合中(比如 ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。 \n \n 4) 重复第 1 步直到覆盖了全部的地区\n\n ![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/A8DD2B7D1606403BB8EEB572B8F4855B/196)\n\n\n---\n 代码实现：\n\n        public class GreedyAlgorithm {\n\n\n     public static void main(String args[]) {\n\n         //贪心算法：每次寻找最优解\n\n         //问题:\n         /*\n         有付费广播覆盖：\n\n              k1      北京，上海，天津\n              k2      广州，北京，深圳\n              k3      成都，上海，杭州\n              k4      上海，天津\n              k5      杭州，大连\n\n              选择最少的广播电台，覆盖这里的所有地区\n          */\n\n         /*\n         思路分析：首先需要一个把所有的地区全都放进一个集合里面，方便进行对照在选择一个电台后哪些地区已经被覆盖，\n         然后可以把这些地区从集合中干掉，直到最后没有了就说明ok了\n\n         用一个hashMap<String,hashSet<String>>来存放  \"k1      北京，上海，天津\"这种结构，\n\n         需要遍历每一个广播的地区，然后呢把地区放在一个临时的Arrlist集合里面,去与所有地区的集合求交集，把结果赋到这个临时集合里面\n          一个for循环遍历每一个广播的地区，定义一个maxKey，进来后首先指向遍历的第一个广播，然后判断下一个广播覆盖的地区是否比\n          maxKey指向的多，多的话maxKey就指向新的,要是小于或者等于就不用改变指向\n\n          */\n\n         HashSet<String> hashSet1=new HashSet<>();\n         HashSet<String> hashSet2=new HashSet<>();\n         HashSet<String> hashSet3=new HashSet<>();\n         HashSet<String> hashSet4=new HashSet<>();\n         HashSet<String> hashSet5=new HashSet<>();\n\n         hashSet1.add(\"北京\");\n         hashSet1.add(\"上海\");\n         hashSet1.add(\"天津\");\n\n         hashSet2.add(\"广州\");\n         hashSet2.add(\"北京\");\n         hashSet2.add(\"深圳\");\n\n         hashSet3.add(\"成都\");\n         hashSet3.add(\"上海\");\n         hashSet3.add(\"杭州\");\n\n         hashSet4.add(\"上海\");\n         hashSet4.add(\"天津\");\n\n         hashSet5.add(\"杭州\");\n         hashSet5.add(\"大连\");\n\n         HashMap<String, HashSet<String>> map=new HashMap<>();\n\n         map.put(\"k1\",hashSet1);\n         map.put(\"k2\",hashSet2);\n         map.put(\"k3\",hashSet3);\n         map.put(\"k4\",hashSet4);\n         map.put(\"k5\",hashSet5);\n\n\n         //需要一个集合来存放全部的地区\n\n         List<String>  allAreas  =new ArrayList<>();\n\n         allAreas.add(\"北京\");\n         allAreas.add(\"上海\");\n         allAreas.add(\"天津\");\n         allAreas.add(\"广州\");\n         allAreas.add(\"深圳\");\n         allAreas.add(\"成都\");\n         allAreas.add(\"杭州\");\n         allAreas.add(\"大连\");\n\n\n         greedyAlgorithm(map,allAreas);\n     }\n\n     public static void  greedyAlgorithm(Map<String,HashSet<String>> map, List<String> allAreas){\n\n         //定义一个临时的集合，存放该广播对应的地区\n         List<String> temp=new ArrayList<>();\n\n         //定义一个存放结果集的集合\n         List<String> selected=new ArrayList<>();\n\n           String maxKey=null;\n           int MaxTempSize=0;\n         //遍历传进来的map集合,得到每一个广播\n         while (allAreas.size()>0){\n             //因为每次添加一个广播就要删掉allAreas集合中该广播对应的覆盖地区，最后这个集合长度为0了就完了\n\n             //每遍历完一次全部的广播得到一个广播结果集的时候，就要把maxKey置空，\n             // 让它下次遍历全部广播的时候maxKey先指向第一个\n             maxKey=null;\n         for(String key:map.keySet()) {\n\n             //每次遍历到一个广播就清空以前的temp集合\n\n             temp.clear();\n\n             //得到该广播对应的覆盖地区\n             HashSet<String> hashSet = map.get(key);\n\n              for(String area: hashSet){\n\n                  temp.add(area);\n\n              }\n\n              temp.retainAll(allAreas);//求交集，把交集的值重新赋给temp集合\n\n             if(temp.size()>MaxTempSize){\n\n                 MaxTempSize=temp.size();\n\n             }\n\n              //判断temp的长度\n\n             if(temp.size()>0 && (maxKey==null || temp.size()>MaxTempSize)){\n\n                 //把key赋为maxKey\n                 maxKey=key;\n             }\n\n\n         }\n\n         if(maxKey!=null){\n\n             selected.add(maxKey);\n\n             allAreas.removeAll(map.get(maxKey));\n         }\n\n\n\n         }\n\n\n\n\n\n\n         //输出结果集\n\n         for(String s:selected){\n\n             System.out.println(\"放入广播\"+s);\n         }\n\n     }\n\n\n    }\n\n\n","tags":["学习笔记"]},{"title":"数据结构-常用的10种算法第二辑","url":"/2020/05/04/数据结构-常用的10种算法第二辑/","content":"KMP算法\n<!-- more-->\n\n### KMP算法介绍\n\n#### 应用场景-字符串匹配问题\n\n 字符串匹配问题：： \n\n1) 有一个字符串 str1= \"\"硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好\"\"，和一个子串 str2=\"尚硅谷你尚硅 你\" \n\n2) 现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1\n\n\n##### 暴力匹配算法\n\n如果用暴力匹配的思路，并假设现在 str1 匹配到 i 位置，子串 str2 匹配到 j 位置，则有: \n\n1) 如果当前字符匹配成功（即 str1[i] == str2[j]），则 i++，j++，继续匹配下一个字符\n\n 2) 如果失配（即 str1[i]! = str2[j]），令 i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为 0。 \n \n 3) 用暴力方法解决的话就会有大量的回溯，每次只移动一位，若是不匹配，移动到下一位接着判断，浪费了大量 的时间。(不可行!)\n\n\n\n 代码实现：\n\n        public class ViolenceMatch {\n\n    //暴力匹配算法\n\n\n    //i指向原串，从0开始，j指向子串，从0开始。\n    //如果i对应的字符等于j对应的字符，两者++,遇到不匹配j=0;i=i-(j-1),j=子串长度就代表匹配完成 ,对应原串的开始索引i-j\n\n\n\n     public static void main(String args[]) {\n\n         String str1=\"硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好\";\n         String str2=\"尚硅谷你尚硅你~\";\n\n         System.out.println(violenceMatch(str1,str2));\n\n\n\n\n     }\n\n\n     public static int  violenceMatch(String str1,String str2){\n\n\n         char[] c1 = str1.toCharArray();\n         char[] c2 = str2.toCharArray();\n\n         int i=0;//原串指针\n         int j=0;//子串指针\n\n         int s1=str1.length();\n         int s2=str2.length();\n\n         while (i<s1 &&j<s2){\n\n\n             if(c1[i]==c2[j]){\n\n                 i++;\n                 j++;\n             }\n             else{\n\n                 i=i-(j-1);\n\n                 j=0;\n\n\n             }\n\n             if(j==s2){\n\n              return i-j;\n\n             }\n\n\n\n\n         }\n\n     return  -1;\n\n     }\n\n\n    }\n\n\n----\n\n#### KMP 算法最佳应用-字符串匹配问题\n\n 字符串匹配问题：： \n\n1) 有一个字符串 str1= \"BBC ABCDAB ABCDABCDABDE\"，和一个子串 str2=\"ABCDABD\" \n\n2) 现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1 3) 要求：使用 KMP 算法完成判断，不能使用简单的暴力匹配算法\n\n\n思路分析图解\n\n\n举例来说，有一个字符串 Str1 = “BBC ABCDAB ABCDABCDABDE”，判断，里面是否包含另一个字符串 Str2 = “ABCDABD”？\n\n 1.首先，用 Str1 的第一个字符和 Str2 的第一个字符去比较，不符合，关键词向后移动一位\n\n ![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/39377DF32B7B4EF380941F507948038A/168)\n\n 2.重复第一步，还是不符合，再后移\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/830B1A4A396F48ABA96654E99B88C776/170)\n\n3.一直重复，直到 Str1 有一个字符与 Str2 的第一个字符符合为止\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/13DBB550DBF2406BB0ACAF12B73056BF/172)\n\n4.接着比较字符串和搜索词的下一个字符，还是符合\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/D361F33C7C0C4532B35D1340BB003B23/174)\n\n5.遇到 Str1 有一个字符与 Str2 对应的字符不符合。\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/FB83AFD8F1AB4E9E98BD27B2A6B8DD0C/176)\n\n6.这时候，想到的是继续遍历 Str1 的下一个字符，重复第 1 步。(其实是很不明智的，因为此时 BCD 已经比较过了， 没有必要再做重复的工作，一个基本事实是，当空格与 D 不匹配时，你其实知道前面六个字符是”ABCDAB”。 KMP 算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这 样就提高了效率。)\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/DFB2060BE1BC434CB4BD207CEB75A907/178)\n\n7.怎么做到把刚刚重复的步骤省略掉？可以对 Str2 计算出一张《部分匹配表》，这张表的产生在后面介绍\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/C40B3787E8E9463686382ED940DB2C31/180)\n\n\n8.已知空格与 D 不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符 B 对应的”部分 匹配值”为 2，因此按照下面的公式算出向后移动的位数： 移动位数 = 已匹配的字符数 - 对应的部分匹配值 因为 6 - 2 等于 4，所以将搜索词向后移动 4 位。 \n\n9.因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为 2（”AB”），对应的”部分匹配值” 为 0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移 2 位。\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/F9A27F3FDB78415DB1A60E7867813A95/182)\n\n10.因为空格与 A 不匹配，继续后移一位。\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/4C6AD1998AAB4E19A468788752ED252D/184)\n\n11.逐位比较，直到发现 C 与 D 不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动 4 位。\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/8993D2734CC24CE8AFB31FC0A4A119F3/186)\n\n12.逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配）， 移动位数 = 7 - 0，再将搜索词向后移动 7 位，这里就不再重复了。\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/12DB3FE6D5FE467F970EA18603169236/188)\n\n\n13.介绍《部分匹配表》怎么产生的 先介绍前缀，后缀是什么\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/BB0579E15B40492095B600AD13EBC3E5/190)\n\n“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例，\n\n －”A”的前缀和后缀都为空集，共有元素的长度为 0；\n \n  －”AB”的前缀为[A]，后缀为[B]，共有元素的长度为 0； \n  \n  －”ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度 0； \n  \n  －”ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为 0； \n  \n  －”ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为 1； \n  \n  －”ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”， 长度为 2； \n  \n  －”ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为 0。\n\n\n  14.”部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么 它的”部分匹配值”就是 2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动 4 位（字符串长度- 部分匹配值），就可以来到第二个”AB”的位置。\n\n  ![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/A5DCC0DAE7C94F0DB5AA0551E55E6771/192)\n\n\n\n----\n\n---\n---\n代码实现：\n\n             public class KMPAlgorithm {\n\n    //kmp算法：\n\n    //核心思想：根据子串的部分匹配表，计算出当原串的字符和子串不匹配时，应该从哪个位置开始比较最佳\n\n    //部分匹配表，如   A B C D A B D   ,就是每一个字符串从A开始，直到ABCDABD，字符串的前缀和后缀的共有元素的长度\n      //                   0 0 0 0 1 2 0\n\n\n\n    //部分匹配表的规律是：定义一个j,从0开始，i作为这个next数组的下标，i=0时，next[0]=0;i从1开始，当\n    // i对应的字符与j对应的字符相等的时候，那么j++,并且next[i]=j;\n    //当j>0 && i对应的字符和j不相等的时候，那么j=next[j-1],循环判断，直到条件不满足退出。。。\n\n    //i指向原串，从0开始++，j指向子串初始等于0，当i对应的字符与j对应的字符不相等的时候，i一直++,直到遇到两者相等，那么j++,\n    //当j>0的时候，要是遇到当i对应的字符与j对应的字符不相等，那么j=neext[j-1],循环判断直到不满足条件退出\n\n\n\n     public static void main(String args[]) {\n\n\n         String str1=\"BBC ABCDAB ABCDABCDABDE\";\n         String str2=\"ABCDABD\";\n         int[] tab = partialmatchTab(str2);\n\n         System.out.println(Arrays.toString(tab));\n\n         int i = kMPAlgorithm(str1, str2, tab);\n         System.out.println(i);\n\n     }\n\n\n\n     //生成部分匹配表，传入参数是子串\n     public static int [] partialmatchTab(String dest){\n\n         int [] next=new int[dest.length()];\n\n         next[0]=0;\n\n         for(int i=1,j=0;i<dest.length();i++){\n\n\n             while (j>0 && dest.charAt(i)!=dest.charAt(j)){\n\n                 j=next[j-1];\n             }\n\n             if(dest.charAt(i)==dest.charAt(j)){\n\n                 j++;\n             }\n\n             next[i]=j;\n\n\n         }\n\n         return  next;\n\n     }\n\n     //kmp字符匹配，传入原串和子串，以及子串部分匹配表\n     public  static  int kMPAlgorithm (String str1,String str2,int [] next){\n\n\n\n         int j=0;//指向子串\n\n         for(int i=0;i<str1.length();i++){ //遍历原串\n\n\n             while (j>0 && str1.charAt(i)!=str2.charAt(j)){\n\n                 j=next[j-1];\n\n             }\n\n             if(str1.charAt(i)==str2.charAt(j)){\n\n                 j++;\n             }\n\n             if(j==str2.length()){\n\n                 return  i-j+1;\n             }\n\n\n         }\n         return  -1;\n\n     }\n\n     }\n\n\n       \n\n","tags":["学习笔记"]},{"title":"数据结构-常用的10种算法第一辑","url":"/2020/05/04/数据结构-常用的10种算法第一辑/","content":"\n二分查找算法（非递归）\n\n<!-- more-->\n### 二分查找算法（非递归）\n\n二分查找算法(非递归)介绍 \n\n1) 前面我们讲过了二分查找算法，是使用递归的方式，下面我们讲解二分查找算法的非递归方式 \n\n2) 二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找 \n\n3) 二分查找法的运行时间为对数时间 O(㏒₂n) ，即查找到需要的目标位置最多只需要㏒₂n 步，假设从[0,99]的 队列(100 个数，即 n=100)中寻到目标数 30，则需要查找步数为㏒₂100 , 即最多需要查找 7 次( 2^6 < 100 < 2^7)\n\n\n代码实现：\n\n        package com.yjr.Algorithm.binarysearchnorecursion;\n\n    public class BinarysearchnorecursionDemo {\n\n    //二分查找的算法的非递归实现\n\n\n     public static void main(String args[]) {\n\n         int [] arr={1,3, 8, 10, 11, 67, 100};\n\n         int i = binarysearchnorecursion(arr, 0, arr.length - 1, 100);\n         System.out.println(i);\n\n     }\n\n\n    public static   int binarysearchnorecursion(int [] arr,int left,int right,int temp){\n\n         while (left<=right){\n\n             int mid=(left+right)/2;\n\n             if(arr[mid]==temp){\n\n                 return  mid;\n             }\n             else if(arr[mid]>temp){\n\n                 //左边\n\n                 right=mid-1;\n\n             }\n\n             else {\n\n                 //右边\n                 left=mid+1;\n             }\n\n\n\n         }\n\n         return -1;\n\n    }\n\n\n    }\n\n\n\n\n---\n### 分治算法\n\n#### 分治算法介绍 \n\n1) 分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或 相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题 的解的合并。\n\n这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变 换)…… \n\n2) 分治算法可以求解的一些经典问题 \n\n 二分搜索\n\n 大整数乘法\n \n 棋盘覆盖 \n\n 合并排序 \n\n 快速排序 \n\n 线性时间选择 \n\n 最接近点对问题 \n\n 循环赛日程表 \n\n 汉诺塔 \n\n 分治算法的基本步骤 分治法在每一层递归上都有三个步骤： \n \n 1) 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题 \n \n 2) 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题\n\n 3) 合并：将各个子问题的解合并为原问题的解。\n\n\n\n\n\n### 分治算法的实践-汉诺塔\n\n1) 如果是有一个盘， A->C ，如果我们有 n >= 2 情况，我们总是可以看做是两个盘：最下边的盘和上面的盘 \n    \n2) 先把 最上面的盘 A->B \n\n3) 把最下边的盘 A->C \n\n4) 把 B 塔的所有盘 从 B->C\n\n\n代码如下：\n\n     package com.yjr.Algorithm.dac;\n\n    public class Hanoitower {\n\n    //汉诺塔\n\n    //三个柱子，第一个柱子放着n个圆盘，从上往下形状从小到大放。要求每一次只能移动一个圆盘，并且大盘不能放在小盘上\n    //,最后所有圆盘移动到第三个柱子上,也是从上往下形状从小到大放。\n\n    //思路分析：分治算法。分解成小问题试试：如果只有两个盘，柱子是a,b,c 那么最上面的盘先移动到b柱，然后就剩一个盘了，\n\n    //最下面的盘直接移动到c,最后第一个盘从b柱移动到c柱\n\n\n    //所以n个盘可以分为 1到n-1个盘和第n个盘，n-1个盘a->b,第n个盘a->c,n-1个盘b->c,  n-1个盘也是递归这种操作。\n\n\n\n     public static void main(String args[]) {\n\n         hanoitower(10,\"a盘\",\"b盘\",\"c盘\");\n     }\n\n\n     //n个盘， a,b,c柱\n     public static void  hanoitower (int n,String aP ,String bP,String cP){\n\n\n         //只有一个盘（就是第一个盘）\n         if(n==1){\n\n             System.out.println(\"第1个盘从\"+aP+\"移动到\"+cP);\n         }\n\n         else{\n\n             //多个盘\n             //那么就把第1到n-1个盘a-b。\n             hanoitower(n-1,aP,cP,bP);  //a到b,借助于c\n\n             System.out.println(\"第\"+n+\"个盘从\"+aP+\"移动到\"+cP);\n             hanoitower(n-1,bP,aP,cP); //b到c，借助于a\n\n         }\n\n\n     }\n\n    }\n\n\n\n\n### 动态规划算法\n\n背包问题： 有一个背包，容量为 4 磅 ， 现有如下物品\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/A110409EFE134759A45F23C3D445C0FF/164)\n\n1) 要求达到的目标为装入的背包的总价值最大，并且重量不超出 \n\n2) 要求装入的物品不能重复\n\n\n### 动态规划算法介绍\n\n1) 动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解 的处理算法 \n\n2) 动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这 些子问题的解得到原问题的解。 \n\n3) 与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。 ( 即下一个子 阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 ) \n\n4) 动态规划可以通过填表的方式来逐步推进，得到最优解.\n \n\n\n背包问题思路分析:\n\n\n1) 背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价 值最大。其中又分 01 背包和完全背包(完全背包指的是：每种物品都有无限件可用) \n\n2) 这里的问题属于 01 背包，即每个物品最多放一个。而无限背包可以转化为 01 背包。\n\n3) 算法的主要思想，利用动态规划来解决。每次遍历到的第 i 个物品，根据 w[i]和 v[i]来确定是否需要将该物品 放入背包中。即对于给定的 n 个物品，设 v[i]、w[i]分别为第 i 个物品的价值和重量，C 为背包的容量。再令 v[i][j] 表示在前 i 个物品中能够装入容量为 j 的背包中的最大价值。则我们有下面的结果：\n\n\n(1) v[i][0]=v[0][j]=0; //表示 填入表 第一行和第一列是 0 \n\n(2) 当 w[i]> j 时：v[i][j]=v[i-1][j] // 当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个 单元格的装入策略 \n\n(3) 当 j>=w[i]时： v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]} \n\n// 当 准备加入的新增的商品的容量小于等于当前背包的容量, \n\n// 装入的方式: v[i-1][j]： 就是上一个单元格的装入的最大值\n\n v[i] : 表示当前商品的价值\n\n v[i-1][j-w[i]] ： 装入 i-1 商品，到剩余空间 j-w[i]的最大值 \n \n 当 j>=w[i]时： v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]} :\n\n ![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/FF6A4E4F5CB74C12844D507644DDFA78/166)\n\n\n 代码如下:\n\n        public class KnapsackProblem {\n\n    //01背包问题\n\n    //动态规划算法\n\n    // 思路分析：\n    /*\n     // v[i]表示商品的价值，w[i]表示商品的重量。(v[i]和w[i]的i是从1开始)\n      所以需要定义一个int[] v存放商品的价值，定义int [] w存放商品的重量\n\n      v[i][j]表示前i个商品能够装入j容量的背包中的最大价值。（这里的i和j都是从0开始的）\n\n      v[i][j],i代表第i个商品,j代表第j种背包容量,i,j从0开始\n      推导公式：v[i][0]=v[0][j]=0,代表v这个二维数组的所属 第一行和第一列的最大价值都是0；\n\n      当w[i]>j，v[i][j]=v[i-1][j] 。代表如果加进来的商品的重量是大于当前的背包容量的，那么就取前i-1个商品装入j的值\n\n      当w[i]<=j,v[i][j]=max(v[i-1][j],v[i]+v[i-1][j-w[i]])\n      */\n\n\n       public static void main(String args[]) {\n\n\n       int [] v={1500,3000,2000}; //商品的价值\n       int [] w={1,4,3};//商品的重量\n       int m=v.length; //商品的数量\n       int n=4;//背包的容量\n       int [][] val=new int [m+1] [n+1]; //这个二维数组val相当于v[i][j]\n       int [] [] path=new int [m+1][n+1];\n       knapsackProblem(v,w,val,path);\n\n    //       for(int [] a:val){\n    //\n     //           System.out.println(Arrays.toString(a));\n    //\n     //       }\n\n      }\n\n\n      public static void knapsackProblem(int [] v,int [] w,int [][] val,int [] [] path){\n\n\n       //对二维数组val进行一些设置值,v[i][0]=v[j][0]=0\n    //     for(int i=0;i<val.length;i++){\n    //\n    //         for(int j=0;j<val[0].length;j++){\n    //\n    //             if(i==0){\n    //\n    //                 val[i][j]=0;\n    //             }\n    //             if(j==0){\n    //\n    //                 val[i][j]=0;\n    //             }\n      //\n       //         }\n     //\n    //\n    //     }\n\n\n       for(int i=0;i<val.length;i++){\n\n           val[i][0]=0;\n       }\n       for(int j=0;j<val[0].length;j++){\n\n           val[0][j]=0;\n       }\n     //因为val的v[i][0]=v[j][0]=0已经设置了，那么我下面的遍历就从1开始\n\n     for(int i=1;i<val.length;i++){\n\n         for(int j=1;j<val[0].length;j++){\n\n\n             if(w[i-1]>j){\n\n                 val[i][j]=val[i-1][j];\n\n             }\n\n             else {\n\n\n\n                 //val[i][j]=Math.max(val[i-1][j],v[i-1]+val[i-1][j-w[i-1]]);\n\n                 if(v[i-1]+val[i-1][j-w[i-1]]>val[i-1][j]){\n\n                     val[i][j]=v[i-1]+val[i-1][j-w[i-1]];\n\n                     path[i][j]=1;  //为什么在这里才记录呢，因为只有这里才是放了东西，其他地方都是引用上一级的\n                 }\n                 else {\n\n                     val[i][j]=val[i-1][j];\n                 }\n\n             }\n\n\n\n         }\n\n     }\n\n\n     //遍历path,明了哪几个商品应放进背包\n\n\n       int i=v.length;\n       int j=val[0].length-1;\n\n       while (i>0&&j>0){\n\n          if(path[i][j]==1) {\n              System.out.println(\"第\" + i + \"个商品放在背包\");\n              j = j - w[i - 1];\n          }\n          i--;\n       }\n\n\n       }\n    \n     }\n\n","tags":["学习笔记"]},{"title":"数据结构-图","url":"/2020/05/04/数据结构-图/","content":"\n图的实现与操作，表示多对多关系时就用到了图\n\n<!-- more-->\n### 图的常用概念\n\n1) 顶点(vertex) \n\n2) 边(edge)\n\n3) 路径 \n\n4) 无向图:顶点的之间的连接没有方向\n\n5) 有向图:顶点之间的连接有方向\n\n6) 带权图:图的边有权值\n\n\n### 图的表示方式\n\n图的表示方式有两种：二维数组表示（邻接矩阵）；链表表示（邻接表）。\n\n#### 邻接矩阵\n\n邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于 n 个顶点的图而言，矩阵是的 row 和 col 表示的是 1....n 个点\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/48D82D4BC1B641549CB5D60E500AF4BC/158)\n\n#### 邻接表\n\n1) 邻接矩阵需要为每个顶点都分配 n 个边的空间，其实有很多边都是不存在,会造成空间的一定损失. \n\n2) 邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成 \n\n3) 举例说明\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/AA61ADA300F34BAFB3A4E338552BE82B/160)\n\n\n### 图的快速入门\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/AE3ABC6007F34132820386D9AA0BA93B/162)\n\n\n### 图的深度优先遍历介绍\n\n1) 访问初始结点 v，并标记结点 v 为已访问。\n\n2) 查找结点 v 的第一个邻接结点 w。\n \n3) 若 w 存在，则继续执行 4，如果 w 不存在，则回到第 1 步，将从 v 的下一个结点继续。\n  \n4) 若 w 未被访问，对 w 进行深度优先遍历递归（即把 w 当做另一个 v，然后进行步骤 123）。 \n   \n5) 查找结点 v 的 w 邻接结点的下一个邻接结点，转到步骤 3。\n\n\n### 图的广度优先遍历\n\n1) 访问初始结点 v 并标记结点 v 为已访问。\n\n2) 结点 v 入队列\n\n3) 当队列非空时，继续执行，否则算法结束。 \n\n4) 出队列，取得队头结点 u。 \n\n5) 查找结点 u 的第一个邻接结点 w。\n\n6) 若结点 u 的邻接结点 w 不存在，则转到步骤 3；否则循环执行以下三个步骤：\n \n   6.1 若结点 w 尚未被访问，则访问结点 w 并标记为已访问。 \n  \n   6.2 结点 w 入队列 \n  \n   6.3 查找结点 u 的继 w 邻接结点后的下一个邻接结点 w，转到步骤 6\n\n\n\n\n### 代码汇总\n\n      package com.yjr.graph;\n\n    import java.util.ArrayList;\n    import java.util.Arrays;\n    import java.util.LinkedList;\n\n    public class GraphDemo {\n\n    //图：为处理多对多的关系\n\n\n    public static void main(String args[]) {\n\n        String[] st = {\"A\", \"B\", \"C\", \"D\", \"E\"};\n\n        Graph graph = new Graph(5);\n        for (String s : st) {\n\n            graph.addVertex(s);\n        }\n\n        //添加边的关系\n\n        graph.addEdges(0, 1);\n        graph.addEdges(0, 2);\n        graph.addEdges(1, 2);\n        graph.addEdges(1, 3);\n        graph.addEdges(1, 4);\n\n\n        //查看矩阵的详情\n        graph.showAdjacencyMatrix();\n\n\n        //graph.dfs();\n\n        graph.bfs();\n    }\n\n\n    }\n\n    class Graph {\n\n    //用邻接矩阵来存储图\n    //ArrayList<String>来存储顶点,int [][] edges来存储矩阵中边的对应关系，1表示有连接，0表示无连接\n    private ArrayList<String> vertexList;\n    private int[][] edges;\n    int edgesNum = 0;\n    boolean isVisited[];\n\n    public Graph(int n) {\n\n        //参数是表示图有多少个顶点\n\n        vertexList = new ArrayList<>();\n        edges = new int[n][n];//初始化二维数组\n        isVisited = new boolean[n];\n    }\n\n    //添加顶点\n\n    public void addVertex(String vertex) {\n\n        vertexList.add(vertex);\n\n    }\n\n    //添加对应边的关系\n    //参数 v1 v2是顶点原素对应的下标\n    public void addEdges(int v1, int v2) {\n\n        //这里是实现的是无向图，所以两边都要连起来\n        edges[v1][v2] = 1;\n        edges[v2][v1] = 1;\n\n        //边的数量加1\n        edgesNum++;\n\n    }\n\n    //图的常用方法\n    //根据顶点索引获取顶点的具体值\n    public String getVertexByIndex(int index) {\n\n        return vertexList.get(index);\n    }\n\n    //获取图中顶点的个数\n\n    public int getVertexNum() {\n        return vertexList.size();\n    }\n\n    //查看两个顶点之间的对应的权值（1还是0）\n    public int getVertexWeight(int v1, int v2) {\n\n        return edges[v1][v2];\n\n    }\n\n    //查看图中边的个数\n    public int getEdgesNum() {\n\n        return edgesNum;\n    }\n\n    //查看图的邻接矩阵\n    public void showAdjacencyMatrix() {\n\n        //遍历二维数组\n        for (int[] e : edges) {\n\n            System.out.println(Arrays.toString(e));\n        }\n\n    }\n\n    //查看当前遍历的节点的下一个邻接节点（第一个）\n\n\n    public int getFirstNeighbor(int index) {\n\n        //返回邻接节点的下标，传进当前节点的下标\n\n        for (int i = 0; i < vertexList.size(); i++) {\n\n            if (edges[index][i] > 0) {\n\n                return i;\n            }\n\n        }\n        return -1;\n\n    }\n\n    //返回当前节点的下一个邻接节点（第一个）的下一个邻接节点，这种情况是第一邻接节点已经被访问过\n\n    //传入的参数是当前的节点的索引,以及当前索引的第一个邻接节点的索引\n    public int getNextNeighbor(int index, int w) {\n\n        for (int i = w + 1; i < vertexList.size(); i++) {\n\n            if (edges[index][i] > 0) {\n\n                return i;\n            }\n        }\n        return -1;\n\n    }\n\n\n    //图的深度优先遍历\n\n    //基本思路分析，从第一个顶点开始，输出该节点，记录为已访问，然后去寻找顶点的下一个（第一个）邻接节点，\n    //找不到就退出循环，找到了就去到下一个顶点（1）。找到了判断是否已经被访问了，已经被访问了就去寻找（1）的下一个邻接\n    //未被访问就输出该节点，记录为已访问，然后继续下一个邻接节点，就这样循环。\n\n\n    /*\n    深度优先遍历说的直观一点就是在二维数组的第一行上先找到第一个顶点，输出出来，然后去找该顶点的下一个邻接节点（第一个）\n    看这个邻接节点的列的索引是在哪个位置，那就定位到行为该索引的行下。如果第一个邻接节点已经被使用过了，那么就去到该邻接节点的\n    再下一个邻接节点，继续定位行。。就这样循环输出，如果一个行中找不到邻接节点，那么就直接定位到下一行\n     */\n    //第一个参数是记录访问与否,index是当前顶点的索引\n    public void dfs(boolean isVisited[], int index) {\n\n\n        System.out.printf(vertexList.get(index) + \"=>\");\n\n        isVisited[index] = true;\n        int w = getFirstNeighbor(index);\n        while (w != -1) {\n\n            //如果找不到该顶点的邻接节点了循环就退出\n            if (!isVisited[w]) {\n\n                //说明没有被访问过\n\n    //                System.out.printf(vertexList.get(w)+\"=>\");\n    //\n    //                isVisited[w]=true;\n                //递归的过程\n                dfs(isVisited, w);\n\n            }\n\n            w = getNextNeighbor(index, w);\n\n\n        }\n\n\n    }\n\n\n    public void dfs() {\n\n\n        for (int i = 0; i < vertexList.size(); i++) {\n\n            if (!isVisited[i]) {\n\n\n                dfs(isVisited, i);\n\n            }\n\n\n        }\n\n    }\n\n    //图的广度优先遍历\n\n    public void bfs(boolean[] isVisited, int index) {\n\n        //思路分析：\n        /*\n        广度优先遍历的话就是先在一行中把该遍历的遍历完，再去下一行。不像深度优先遍历一样，是一行中找到一个就去到下一行\n\n        所以需要有一个队列，用来记录你当前的访问的行是在第几行\n\n        首先是遍历第一个节点，输出该节点，记录为已经访问，然后该节点的索引入队列，这样的话就知道是第一行了，然后出队，然后寻找该顶点的下一个\n        第一个邻接节点，如果找不到，就去寻找该行中的下下一个邻接节点。找到了就判断是否已经被访问过了，已经被访问过的话就退出循环去\n        找下一个邻接节点。一直找不到就去下一行。未被访问过的话就输出该节点，并入队列。\n         */\n\n        int u = 0;//就是队列的头\n        int w = 0;//邻接节点的索引\n\n\n        System.out.printf(vertexList.get(index) + \"=>\");\n\n        isVisited[index] = true; //记录为已经访问\n\n        //创建一个队列\n        LinkedList linkedList = new LinkedList();\n\n        linkedList.addLast(index);//入队\n\n        while (!linkedList.isEmpty()) {\n\n            //队列不为空的情况下就执行根据队列的头元素去寻找\n\n            //出队，就是得到队列中的头值，就可以定位在哪个行\n            u = (Integer) linkedList.removeFirst();\n\n            //然后在u行中继续寻找邻接节点\n\n            w = getFirstNeighbor(u);\n\n            while (w != -1) {\n\n\n                if (!isVisited[w]) {\n                    //没有被访问过\n                    System.out.printf(vertexList.get(w) + \"=>\");\n                    isVisited[w] = true;\n                    //入队。\n                    linkedList.addLast(w);\n\n                }\n\n                //已经被访问过，那就寻找该邻接节点的下一个邻接节点,之前未访问过上面的逻辑执行完了，也是走这里继续寻找下一个\n                w = getNextNeighbor(u, w);//还是这一行去寻找\n\n\n            }\n\n\n        }\n\n\n    }\n\n\n    public void bfs() {\n\n        for (int i = 0; i < getVertexNum(); i++) {\n\n            if (!isVisited[i]) {\n\n                bfs(isVisited, i);\n\n            }\n\n        }\n\n    }\n\n\n    }\n\n\n\n\n","tags":["学习笔记"]},{"title":"数据结构-平衡二叉树AVL","url":"/2020/04/30/数据结构-平衡二叉树AVL/","content":"\n平衡二叉树问题解决：\n<!-- more-->\n\n给你一个数列{1,2,3,4,5,6}，要求创建一颗二叉排序树(BST), 并分析问题所在.\n\n  左边 BST 存在的问题分析: \n  \n  1) 左子树全部为空，从形式上看，更像一个单链表.\n  \n   2) 插入速度没有影响 \n   \n   3) 查询速度明显降低(因为需要依次比较), 不能发挥 BST的优势，因为每次还需要比较左子树，其查询速度比 单链表还慢 \n   \n   4) 解决方案-平衡二叉树(AVL)\n\n\n   #### 基本介绍\n\n1) 平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为 AVL 树， 可以保证查询效率较高。\n\n 2) 具有以下特点：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵 平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。 \n \n 3) 举例说明, 看看下面哪些 AVL 树, 为什么?\n\n ![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/CD89E82E03154C8ABF7E458040FD5F7D/150)\n\n\n\n #### 左旋转\n\n  给你一个数列，创建出对应的平衡二叉树.数列 {4,3,6,5,7,8}\n\n  ![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/757CF8B5D79042A58E94E77591B0D127/152)\n\n\n  #### 右旋转\n\n  给你一个数列，创建出对应的平衡二叉树.数列 {10,12, 8, 9, 7, 6}\n\n  ![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/ED3C037A9EE14B88A409F7AA76419E52/154)\n\n\n  #### 双旋转\n\n  前面的两个数列，进行单旋转(即一次旋转)就可以将非平衡二叉树转成平衡二叉树,但是在某些情况下，单旋转 不能完成平衡二叉树的转换。比如数列 int[] arr = { 10, 11, 7, 6, 8, 9 }; 运行原来的代码可以看到，并没有转成 AVL 树\n\n  ![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/217D68B2E2F546C5B4D8E626E038FE85/156)\n\n\n   解决思路分析 \n   \n   1. 当符号右旋转的条件时 \n   \n   2. 如果它的左子树的右子树高度大于它的左子树的高度\n\n   3. 先对当前这个结点的左节点进行左旋转 \n   \n   4. 在对当前结点进行右旋转的操作即可\n\n\n   全部代码:\n\n         public class AVLTreeDemo {\n\n    //平衡二叉树\n\n    //规定：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵 平衡二叉树。\n\n    public static void main(String args[]) {\n\n       // int[] arr = {4,3,6,5,7,8};\n        //int[] arr = { 10, 12, 8, 9, 7, 6 };\n        int[] arr = { 10, 11, 7, 6, 8, 9 };\n        AVLTree avlTree=new AVLTree();\n\n        for(int i=0; i < arr.length; i++) {\n            avlTree.add(new Node(arr[i]));\n        }\n\n\n        System.out.println(\"中序遍历\");\n        avlTree.inOrder();\n        System.out.println(\"当前树的高度\"+avlTree.getRoot().height());\n        System.out.println(\"当前左子树的高度\"+avlTree.getRoot().leftHeight());\n        System.out.println(\"当前右子树的高度\"+avlTree.getRoot().rightHeight());\n\n\n    }\n\n\n    }\n\n\n       class  AVLTree{\n\n       private  Node root;\n\n       public Node getRoot() {\n           return root;\n       }\n\n       public void setRoot(Node root) {\n           this.root = root;\n       }\n\n       //添加\n       public  void add(Node node){\n\n           if(root!=null){\n\n               root.add(node);\n\n\n           }\n\n           else{\n\n\n               root=node;\n\n           }\n\n\n       }\n\n\n       //中序遍历\n\n       public  void inOrder(){\n\n           if(root!=null){\n\n               root.inOrder(root);\n\n           }\n           else{\n\n               System.out.println(\"二叉树为空，无法遍历！\");\n           }\n\n\n       }\n      }\n\n    class  Node {\n\n    int value;\n    Node left;\n    Node right;\n\n    public Node(int value) {\n        this.value = value;\n    }\n\n    public int getValue() {\n        return value;\n    }\n\n    public void setValue(int value) {\n        this.value = value;\n    }\n\n    public Node getLeft() {\n        return left;\n    }\n\n    public void setLeft(Node left) {\n        this.left = left;\n    }\n\n    public Node getRight() {\n        return right;\n    }\n\n    public void setRight(Node right) {\n        this.right = right;\n    }\n\n    @Override\n    public String toString() {\n        return \"Node{\" +\n                \"value=\" + value +\n                '}';\n    }\n\n\n    //添加节点（二叉排序树）\n\n    public  void add(Node node){\n\n\n        if(node==null){\n\n            return;\n        }\n\n        //判断加进来的节点应该去到当前节点的哪一边\n        //左边\n        if(this.value>node.getValue()){\n\n            if(left!=null){\n\n                //那就要递归去找了\n                left.add(node);\n            }\n            else{\n\n                //直接挂在左节点\n                left=node;\n            }\n\n        }\n\n        else{\n\n\n            //说明是在右边\n\n            if(right!=null){\n\n                right.add(node);\n            }\n            else{\n\n                right=node;\n            }\n\n        }\n        //添加完节点后\n\n        if(rightHeight()-leftHeight()>1 ){\n\n            //满足根节点的右节点(1)的高度-根节点的左节点的高度 >,那就满足向左旋转的整体要求\n            // (高度，举例：这个高度就是从(1)这个节点开始，选一条路径最长直到叶子节点的路径，其中有几个节点高度就是几)\n\n            if( right!=null&&right.leftHeight()>right.rightHeight()){\n\n                //重点是只要>就行了，不是整体判断条件的 >1!!!!!!\n                //这里满是根节点的右节点的左节点的高度>根节点的右节点的右节点的高度,那么先进行局部右旋转(重点是只要>就行了，不是整体判断条件的>1!!!!!!)\n                //向右旋转\n                right.rightSpin();  //就是以当前根节点的右节点作为根节点去旋转\n\n                //再向左旋转\n                leftSpin(); //这个还是整体旋转了，就以原根节点进行旋转\n            }\n            else {\n\n                //不满足局部要求\n                //整体向左旋转\n\n                leftSpin();\n            }\n\n            return;\n        }\n\n        if(leftHeight()-rightHeight()>1){\n\n            if(left!=null && left.rightHeight()>left.leftHeight()){\n\n\n                left.leftSpin();\n\n                rightSpin();\n\n            }\n            else{\n\n                rightHeight();\n            }\n\n\n        }\n\n\n\n    }\n\n\n    //中序遍历\n\n    public  void inOrder(Node node){\n\n        if(node.getLeft()!=null){\n\n            inOrder(node.getLeft());\n\n        }\n\n        System.out.println(node);\n\n        if(node.getRight()!=null){\n\n            inOrder(node.getRight());\n\n        }\n\n\n\n    }\n\n    //写一个方法：输出以该节点为根节点的树的高度\n\n    public  int height(){\n\n\n        //重点是后面的加1，就是说当一个代码回退的时候每一层都会带着1回来，逐步递增\n        return Math.max(left==null ? 0:left.height(),right==null ? 0:right.height())+1;\n\n\n    }\n\n    //求一个节点作为根节点的左子树的高度\n\n    public  int leftHeight(){\n\n            if(left!=null) {\n                return left.height();\n            }\n            else {\n                return 0;\n            }\n    }\n\n    //求一个节点作为根节点的右子树的高度\n    public  int rightHeight(){\n\n         if(right!=null) {\n             return right.height();\n         }\n         else {\n             return  0;\n         }\n    }\n\n\n    //左旋转\n\n    public  void leftSpin(){\n\n\n        //当做高度和深度概念一样，从1开始\n        //即右子树的高度 - 左子树的高度大于1 (右子树最外层)\n\n        //需要一个新的节点，值是当前节点（从根节点开始的，所以值是根节点）\n\n        Node newNode=new Node(this.value);\n\n        //然后新节点的左节点指向当前节点的左节点\n\n        newNode.left=left;\n\n        //新节点的右节点指向当前节点的右节点的左节点。\n\n        newNode.right=right.left;\n\n        //当前节点的值换为当前右节点的值\n\n        this.value=right.value;\n\n        //把当前节点的右节点设为当前节点的右节点的右节点\n\n        right=right.right;\n\n        //把当前节点的左节点设为新的节点\n\n        left=newNode;\n\n\n    }\n\n    public  void rightSpin(){\n\n\n        //左子树的高度-右子树的高度>1（左子树最外层）\n\n\n         //创建一个新的节点值为根节点\n       Node newNode=new Node(this.value);\n        //新节点的右子树是当前节点的右子树\n      newNode.right=right;\n        //新节点的左子树是当前节点的左子树的右子树\n      newNode.left=left.right;\n        //当前节点的值设为左节点的值\n\n       this.value=left.value;\n        //当前节点的左子树设为当前节点的左子树的左子树\n\n        left=left.left;\n        //当前节点的右子树设为当前新的节点\n\n        right=newNode;\n    }\n\n\n    }","tags":["学习笔记"]},{"title":"数据结构-二叉排序树","url":"/2020/04/30/数据结构-二叉排序树/","content":"\n二叉排序树可以解决高效的完成对数据的查询和添加，如对数列 (7, 3, 10, 12, 5, 1, 9)\n\n<!-- more-->\n\n二叉排序树：BST: (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当 前节点的值小，右子节点的值比当前节点的值大。 \n\n特别说明：如果有相同的值，可以将该节点放在左子节点或右子节点\n\n比如针对前面的数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/9B6B197E448F4D83AC0F8342DF4C1F20/148)\n\n\n#### 二叉排序树创建和遍历\n\n#### 二叉排序树的删除\n\n//对删除结点的各种情况的思路分析: \n\n第一种情况: 删除叶子节点 (比如：2, 5, 9, 12) 思路:\n\n(1) 需求先去找到要删除的结点 targetNode \n\n(2) 找到 targetNode 的 父结点 parent \n\n(3) 确定 targetNode 是 parent 的左子结点 还是右子结点 \n\n(4) 根据前面的情况来对应删除 左子结点 parent.left = null 右子结点 parent.right = null; \n\n\n---\n第二种情况: 删除只有一颗子树的节点 比如 1 思路:\n\n(1) 需求先去找到要删除的结点 targetNode \n\n(2) 找到 targetNode 的 父结点 parent \n\n(3) 确定 targetNode 的子结点是左子结点还是右子结点 \n\n(4) targetNode 是 parent 的左子结点还是右子结点 \n\n(5) 如果 targetNode 有左子结点\n\n5.1 如果 targetNode 是 parent 的左子结点\n\nparent.left = targetNode.left;\n\n5.2 如果 targetNode 是 parent 的右子结点\n\n parent.right = targetNode.left;\n \n(6) 如果 targetNode 有右子结点 \n  \n  6.1 如果 targetNode 是 parent 的左子结点 \n  \n  parent.left = targetNode.right;\n  \n   6.2 如果 targetNode 是 parent 的右子结点 \n   \n   parent.right = targetNode.right\n\n\n ---  \n 情况三 ： 删除有两颗子树的节点. (比如：7, 3，10 ) 思路:\n \n (1) 需求先去找到要删除的结点 targetNode \n \n (2) 找到 targetNode 的 父结点 parent \n \n (3) 从 targetNode 的右子树找到最小的结点 \n \n (4) 用一个临时变量，将 最小结点的值保存 temp = 11 \n \n (5) 删除该最小结点 \n \n (6) targetNode.value = temp\n\n\n---\n 代码如下：\n\n      public class BinarySortDemo {\n\n    //二叉排序树\n\n\n     public static void main(String args[]) {\n\n\n         //二叉排序树的任何一个非叶子节点，要求左子节点的值比当 前节点的值小，右子节点的值比当前节点的值大。\n\n    int [] arr={7, 3, 10, 12, 5, 2, 9,1};\n    BinarySortTree binarySortTree=new BinarySortTree();\n\n         for(int i=0;i<arr.length;i++){\n\n\n        binarySortTree.add(new Node(arr[i]));\n\n    }\n\n         System.out.println(\"删除前\");\n         binarySortTree.inOrder();\n         System.out.println(\"删除后\");\n\n\n         binarySortTree.delete(binarySortTree.getNodeByValue(3));\n         binarySortTree.inOrder();\n\n\n\n    }\n\n\n\n\n\n    }\n\n    class  BinarySortTree{\n\n    private  Node root;\n\n    public Node getRoot() {\n        return root;\n    }\n\n    public void setRoot(Node root) {\n        this.root = root;\n    }\n\n    //添加\n    public  void add(Node node){\n\n        if(root!=null){\n\n            root.add(node);\n\n\n        }\n\n        else{\n\n\n         root=node;\n\n        }\n\n\n    }\n\n    //删除\n\n    public  void delete(Node node){\n\n        //二叉排序树的删除\n\n        /*\n        分情况讨论：\n        1.删除的节点是叶子节点\n\n           1）找到要被删除的节点targetNode\n           2)找到targetNode的父节点\n           3)targetNode是其父节点的左节点还是右节点\n           4）是左节点：parent.left=null;\n           5）是右节点:parent.right=null;\n\n        2.删除的节点的只有左或者右子树。\n\n           1）找到targetNode\n           2)找到targetNode的父节点\n           3）targetNode的子树是在左节点：\n\n               targetNode是父节点的左节点:parent.left=targetNode.left\n               targetNode是父节点的右节点:parent.right=targetNode.left\n\n           4)targetNode的子树是在右节点：\n\n               targetNode是父节点的左节点:parent.left=targetNode.right\n               targetNode是父节点的右节点:parent.right=targetNode.right\n\n          3.删除的节点左右两颗子树\n\n             1）找到targetNode\n             2)找到targetNode的父节点\n             3）向右子树中找到最小的节点值，临时变量记录该值\n             4）删除该最小节点\n             5)将最小节点的值赋给targetNode\n\n         */\n\n        if(node==null){\n\n            return;\n        }\n\n        if(root==node){\n\n            root=null;\n        }\n        else {\n            //先找到要删除的节点\n\n            Node delNode = root.searchDelNode(node);\n\n            if (delNode == null) {\n\n                return;\n            }\n\n            //再去寻找要删除节点的父节点\n            Node parentNode = root.searDelParentNode(node);\n\n\n            //删除的是叶子节点\n            if (node.getLeft() == null && node.getRight() == null) {\n\n\n                if (parentNode.getLeft() == node) {\n\n                    parentNode.left = null;\n\n                } else {\n\n                    parentNode.right = null;\n\n                }\n\n            } else if (node.getLeft() != null && node.getRight() != null) {\n\n                //删除的节点是有左和右两颗子树\n\n                //向右子树寻找最小值\n\n                Node minNode = node.searchMinNode(node.getRight());\n                int temp = 0;\n                if (minNode != null) {\n                    temp = minNode.getValue();\n                }\n                delete(minNode);\n\n                node.value = temp;\n\n            } else {\n\n                //删除的节点只有左或者右子树\n\n                if (node.getLeft() != null) {\n\n                    //targetNode的子树在左节点\n\n                    if (parentNode.getLeft() == node) {\n\n                        //其父节点的左节点是targetNode\n\n                        parentNode.left = node.left;\n\n                    } else {\n                        //其父节点的右节点是targetNode\n                        parentNode.right = node.left;\n                    }\n\n\n                } else {\n\n                    //targetNode的子树在右节点\n\n                    if (parentNode.getLeft() == node) {\n\n                        //其父节点的左节点是targetNode\n\n                        parentNode.left = node.right;\n                    } else {\n\n                        //其父节点的右节点是targetNode\n\n                        parentNode.right = node.right;\n                    }\n\n\n                }\n\n\n            }\n\n        }\n\n    }\n\n    public  Node getNodeByValue(int vaule){\n\n        if(root!=null){\n\n           return root.getNodeByValue(vaule);\n        }\n        else{\n\n            return null;\n        }\n\n\n\n    }\n\n\n\n    //中序遍历\n\n    public  void inOrder(){\n\n        if(root!=null){\n\n            root.inOrder(root);\n\n        }\n        else{\n\n            System.out.println(\"二叉树为空，无法遍历！\");\n        }\n\n\n    }\n\n\n\n\n    }\n    \n    class  Node {\n\n      int value;\n      Node left;\n     Node right;\n\n    public Node(int value) {\n        this.value = value;\n    }\n\n    public int getValue() {\n        return value;\n    }\n\n    public void setValue(int value) {\n        this.value = value;\n    }\n\n    public Node getLeft() {\n        return left;\n    }\n\n    public void setLeft(Node left) {\n        this.left = left;\n    }\n\n    public Node getRight() {\n        return right;\n    }\n\n    public void setRight(Node right) {\n        this.right = right;\n    }\n\n    @Override\n    public String toString() {\n        return \"Node{\" +\n                \"value=\" + value +\n                '}';\n    }\n\n\n    //添加节点（二叉排序树）\n\n    public  void add(Node node){\n\n\n        if(node==null){\n\n            return;\n        }\n\n        //判断加进来的节点应该去到当前节点的哪一边\n        //左边\n        if(this.value>node.getValue()){\n\n            if(left!=null){\n\n                //那就要递归去找了\n                left.add(node);\n            }\n            else{\n\n                //直接挂在左节点\n                left=node;\n            }\n\n        }\n\n        else{\n\n\n            //说明是在右边\n\n            if(right!=null){\n\n                right.add(node);\n            }\n            else{\n\n                right=node;\n            }\n\n        }\n\n    }\n\n\n    //给你一个节点的值，找到该节点\n\n    public  Node getNodeByValue(int value){\n\n        if(this.value==value){\n\n            return this;\n        }\n\n        else if(this.value>value){\n\n            return left.getNodeByValue(value);\n\n        }\n        else  if(this.value<value){\n\n            return  right.getNodeByValue(value);\n        }\n        else {\n\n            return  null;\n        }\n\n\n\n\n    }\n\n\n    //写一个方法，找到以该节点为根节点的下面的最小值\n\n    public  Node searchMinNode(Node node){\n\n        if(node==null){\n\n            return null;\n        }\n\n        //向左递归\n        if(node.getLeft()!=null){\n\n           return searchMinNode(node.getLeft());\n\n        }\n        else {\n\n            return  node;\n\n        }\n\n\n\n\n    }\n\n    //写一个方法：找到要被删除的节点\n\n    public  Node searchDelNode(Node node){\n\n        if(node==null){\n            return null;\n        }\n\n        if(node.getValue()==this.value){\n\n            //就是当前节点\n            return  this;\n        }\n\n        else if( left!=null && this.value>node.getValue() ){\n\n            //去左子树寻找\n\n                return  left.searchDelNode(node);\n\n        }\n        else if(right!=null && this.value<node.getValue()){\n\n            //去右子树寻找\n\n                return  right.searchDelNode(node);\n\n        }\n        else {\n\n            //找不到\n            return  null;\n\n        }\n\n\n\n    }\n\n    //找到被删除节点的父节点\n\n    public  Node searDelParentNode(Node node){\n\n        if(node==null){\n\n            return null;\n        }\n\n        if((left!=null && left.value==node.value) ||(right!=null && right.value==node.value)){\n\n            //当前节点就是父节点\n            return  this;\n\n        }\n\n       else {\n\n\n           if(this.value>node.value){\n\n               //想左边递归寻找\n\n              return left.searDelParentNode(node);\n\n           }\n           else{\n\n              return right.searDelParentNode(node);\n\n           }\n\n\n\n        }\n\n\n    }\n\n\n    //中序遍历\n\n    public  void inOrder(Node node){\n\n        if(node.getLeft()!=null){\n\n            inOrder(node.getLeft());\n\n        }\n\n        System.out.println(node);\n\n        if(node.getRight()!=null){\n\n            inOrder(node.getRight());\n\n        }\n\n\n\n    }\n\n    }\n     ","tags":["学习笔记"]},{"title":"Comparable接口的理解与使用","url":"/2020/04/30/Comparable接口的理解与使用/","content":"java comparator 升序、降序、倒序从源码角度理解\n<!-- more-->\n\n链接：https://blog.csdn.net/u013066244/article/details/78997869?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1\n\n\ncomparable接口实际上出自java.lang包，它有一个compareTo(Object obj)方法进行排序\n\ncomparator接口实际上出自java。util包，它有一个compare(Object obj1,Object obj2)方法进行排序\n\n(速记：接口名称不带t,那么实现的方法带t,只有一个参数(联想为踢了就剩一个))\n\n\n\n- 对于compare(Object obj1,Object obj2)方法，返回1代表前者权重较大，后值权重较小，权重按升序排序，返回-1就反之\n\n- 比如 4<6 返回1，那么4的权重较大，所以4在6的后面,所以就是降序，比如 6>4返回-1，那么4的权重大，所以4排在6的后面，也就是降序，记住这个规律，返回什么只是判断那一方的权重较大，较大的权重排后面就完事了。\n\n个人理解:\n\n举个例子：Node2节点类要对权重进行排序\n\n     class  Node2  implements  Comparable<Node2>{\n\n    private  Byte data; //数据\n    private  int weight; //权重\n    private  Node2 left;//左节点\n    private  Node2 right;//右节点\n\n\n   \n\n    @Override\n    public int compareTo(Node2 o) {\n\n\n        return this.weight-o.weight;\n    }\n\n\n  \n\n    }\n\n\n\n\n---\n\n\n\ncompare这个方法：（举例）\n\n    this.age相当于参数o1,o.age相当于参数o2,但是在源码中o1,o2是调过来的\n\n    比如说 1,2,6,5,4,3\n\n    当你设置if(this.age>o.age){\n\n                    return 1;\n                }\n                else if(this.age<o.age){\n\n                    return -1;\n                }\n                else {\n\n                    return 0;\n                }\n    你设置this.age的时候是当前age嘛，(比如1和2比较)所以就是1（o1），那么o.age就是2(o2)，\n    \n    但是在源码中 2其实是o1,1其实是o2,那么你在源码中是o1>o2的，所以就返回的是1,既然返回1了，源码的执行就\n    \n    会去到升序的方法，循环找，一直找到返回-1的，就是o1<o2,然后就记录o1的位置，然后进行二分插入升序排序\n\n    升序的也可以写成  return this.age-o.age;\n\n    当你设置 if(this.age>o.age){\n\n                    return -1;\n                }\n                else if(this.age<o.age){\n\n                    return 1;\n                }\n                else {\n\n                    return 0;\n                }\n\n         ）\n    比如1,2比较，源码中1是o2,2是o1,这个时候o1>o2返回的是-1，那么就会进入降序的方法，直到找到返回1的，就\n    \n    是o1<o2,然后就反转o2前面的数据，即从o2位置到开始位置反转过来，然后再进行二分降序排序。\n   \n    \n    降序的话可以写成o.age-this.age(举个例子:o.age-this.age>0的时候其实就是this.age-o.age<0的时候，也\n    \n    就是说你o.age-this.age>0返回的值就是this.age-o.age <0的时候返回的值，比如说o.age-this.age=1 >0\n    \n    （返回1），那么this.age-o.age<0返回的也是1，这样就去到了降序)\n","tags":["随笔"]},{"title":"数据结构-赫夫曼树和赫夫曼编码","url":"/2020/04/30/数据结构-赫夫曼树和赫夫曼编码/","content":"树结构的应用-赫夫曼树和编码\n<!-- more-->\n### 赫夫曼树\n\n\n1) 给定 n 个权值作为 n 个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为 最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。 \n\n2) 赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近\n\n### 赫夫曼树几个重要概念和举例说明\n\n 1) 路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路\n  中分支的数目称为路径长度。若规定根结点的层数为 1，则从根结点到第 L 层结点的路径长度为 L-1\n\n \n2)  结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结 点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积\n\n3) 树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为 WPL(weighted path length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。\n\n4) WPL 最小的就是赫夫曼树\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/F1FD1E2938364AB88A22EADAF4F083A8/144)\n\n---\n### 赫夫曼树创建思路图解\n\n1) 从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树 \n\n2) 取出根节点权值最小的两颗二叉树 \n\n3) 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和\n\n4) 再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数 据都被处理，就得到一颗赫夫曼树\n\n\n---\n代码如下:\n\n     public class HuffmanTree {\n\n    //哈夫曼树\n\n    //要求：给你一个数列，比如说：{13, 7, 8, 3, 29, 6, 1}，把它转成哈夫曼树\n\n\n\n     public static void main(String args[]) {\n\n         //测试生成哈夫曼树\n         int arr[] = { 13, 7, 8, 3, 29, 6, 1 };\n         Node hafumanRoot = toHuffmanTree(arr);\n\n         preOrder(hafumanRoot);\n\n     }\n\n\n     public  static  void preOrder(Node root){\n\n         if(root!=null){\n\n             root.preOrder(root);\n         }\n         else{\n\n             System.out.println(\"二叉树为空！\");\n         }\n\n\n     }\n\n       public static  Node toHuffmanTree(int [] arr){\n\n         //对于传进来的数组，先把它进行遍历，把用每一个数据生成节点放进List集合中，方便操作\n\n       List<Node> nodes=new ArrayList<>();\n       for(int value:arr){\n\n           nodes.add(new Node(value));\n\n       }\n\n\n       //接着就是生成哈夫曼树的操作\n\n       //基本思路就是，先用排序后的两个节点组成一个二叉树，根节点是两个节点的值的和，\n       // 再拿这个新的二叉树的根节点值与剩下的排序，再拿前两个的数据组成新的二叉树，依此循环下去，\n       // 直到数组中就剩最后一个哈夫曼树的根节点\n\n\n       while (nodes.size()>1){\n\n           //因为就剩最后一个哈夫曼树的根节点的话就表示完成\n\n\n           //对集合中的Node排序\n           Collections.sort(nodes);\n\n           //取集合中第一个当左节点\n\n           Node nodeLeft = nodes.get(0);\n           Node nodeRight = nodes.get(1);\n\n           //组成新的二叉树\n\n           Node parent=new Node(nodeLeft.getData()+nodeRight.getData());\n\n           parent.setLeft(nodeLeft);\n           parent.setRight(nodeRight);\n\n           //然后删除被取出的两个节点\n\n           nodes.remove(nodeLeft);\n           nodes.remove(nodeRight);\n\n           //把组成的二叉树的节点放进集合中\n\n           nodes.add(parent);\n       }\n\n       //循环结束，返回哈夫曼树的根节点\n       return nodes.get(0);\n\n\n\n       } \n\n\n     \n    }\n\n    \n    //节点类，每一个数据都是一个二叉树的节点  实现 Comparable可以对Node进行排序\n    class  Node  implements  Comparable<Node>{\n\n    private  int data; //数据\n    private  Node left;//指向左边节点\n    private  Node right;//指向右节点\n\n    public Node(int data) {\n        this.data = data;\n    }\n\n    public int getData() {\n        return data;\n    }\n\n    public void setData(int data) {\n        this.data = data;\n    }\n\n    public Node getLeft() {\n        return left;\n    }\n\n    public void setLeft(Node left) {\n        this.left = left;\n    }\n\n    public Node getRight() {\n        return right;\n    }\n\n    public void setRight(Node right) {\n        this.right = right;\n    }\n\n    @Override\n    public String toString() {\n        return \"Node{\" +\n                \"data=\" + data +\n                '}';\n    }\n\n    @Override\n    public int compareTo(Node o) {\n\n\n        //这里是从小到大排序\n\n        return this.data-o.data;\n    }\n\n\n    //前序遍历\n\n    public  void preOrder(Node node){\n\n        System.out.println(node);\n\n        if(node.getLeft()!=null){\n\n            preOrder(node.getLeft());\n\n        }\n        if(node.getRight()!=null){\n\n            preOrder(node.getRight());\n        }\n\n    }\n    }\n\n\n\n\n\n\n---\n---\n### 赫夫曼编码\n\n1) 赫夫曼编码也翻译为 哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法 \n\n2) 赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。 \n\n3) 赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在 20%～90%之间 \n\n4) 赫夫曼码是可变字长编码(VLC)的一种。Huffman 于 1952 年提出一种编码方法，称之为最佳编码\n\n\n\n传输的 字符串 \n\n1) i like like like java do you like a java \n\n2) d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 :9 // 各个字符对应的个数 \n\n---\n\n 按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值 步骤： 构成赫夫曼树的步骤：\n\n 1) 从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树 \n \n 2) 取出根节点权值最小的两颗二叉树 \n \n 3) 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 \n \n 4) 再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理， 就得到一颗赫夫曼树\n\n ![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/20914A1479374FEAA42D4BCD9FB50A38/146)\n\n 根据赫夫曼树，给各个字符,规定编码 (前缀编码)， 向左的路径为 0 向右的路径为 1 ， 编码 如下:\n \n  o: 1000 u: 10010 d: 100110 y: 100111 i: 101 a : 110 k: 1110 e: 1111 j: 0000 v: 0001 l: 001 \n  \n   : 01 \n  \n  \n  按照上面的赫夫曼编码，我们的\"i like like like java do you like a java\" 字符串对应的编码为 (注 意这里我们使用的无损压缩) 10101001101111011110100110111101111010011011110111101000011000011100110011110000110 01111000100100100110111101111011100100001100001110\n\n  注意, 这个赫夫曼树根据排序方法不同，也可能不太一样，这样对应的赫夫曼编码也不完全一样，但是 wpl 是 一样的，都是最小的, 最后生成的赫夫曼编码的长度是一样\n\n\n\n  全部代码（压缩，解压，文件压缩，文件解压）\n\n\n       public class HafumanCode {\n\n\n    static  Map<Byte,String> hfumaCodeTa=new HashMap<>();\n\n     public static void main(String args[]) {\n\n         //测试生成哈夫曼树\n\n         String str=\"i like like like java do you like a java\";\n\n         byte[] strBytes = str.getBytes();\n\n    //         List<Node2> node2s = auxiliarycreatehafuManTree(strBytes);\n    //\n    //         Node2 hafumanRoot = createhafuManTree(node2s);\n    //\n    ////         System.out.println(hafumanRoot);\n    ////\n    ////         System.out.println(\"看看前序遍历\");\n    //        preOrder(hafumanRoot);\n\n\n    //         //测试生成的哈夫曼码表Map<Byte,String>\n    //       StringBuilder builder=new StringBuilder();\n    //         createHafumanTab(hafumanRoot,\"\",builder);\n    //\n    //         Map<Byte, String> hafumanTabb = createHafumanTab(strBytes);\n    //         for (Map.Entry<Byte,String> map: hafumanTabb.entrySet()){\n    //\n    //             System.out.println(map.getKey()+\":\"+map.getValue());\n    //\n    //         }\n\n\n         //测试压缩\n\n    //         byte[] hafumanCompression = hafumanCompression(strBytes);\n\n    //             for (byte b:hafumanCompression){\n    //\n    //             System.out.println(b);\n    //         }\n\n         //测试解压\n\n    //         byte[] decode = decode(hafumanCompression, createHafumanTab(strBytes));\n\n\n    //         for(byte a:decode){\n    //             System.out.println(a);\n    //         }\n\n    //         System.out.println(new String(decode));\n\n         //测试压缩文件\n\n    //         String sourceFilePath=\"D://测试压缩.txt\";\n    //         String comPreFilePath=\"D://测试压缩.zip\";\n    //\n    //         Filecompression(sourceFilePath,comPreFilePath);\n    //         System.out.println(\"压缩成功\");\n\n\n         //测试解压\n         String sourceComPreFilePath=\"D://测试压缩.zip\";\n       String unzipFilePath=\"D://测试压缩2.txt\";\n       Unzipfile(sourceComPreFilePath,unzipFilePath);\n       System.out.println(\"解压完成\");\n\n     }\n\n\n\n\n\n\n\n\n\n    /*\n     首先呢，先进行压缩操作，就是把一个字符串中的所有的字符出现的次数作为权值（对应每一个字符），\n     构建成哈夫曼树，左边的节点路径为0，右边的节点路径为1。\n    形成类似的\n    比如字符串：i like like like java do you like a java\n    形成类似的东西o: 1000 u: 10010 d: 100110 y: 100111 i: 101 a : 110 k: 1110 e: 1111 j: 0000 v: 0001 l: 001 : 01\n    这种哈夫曼表的结构可以用 Map<byte,String> 来存储\n\n\n\n    */\n\n\n    //实现文件的压缩（给你一张图片，无损压缩）\n\n    public static  void  Filecompression(String sourceFilePath,String comPreFilePath){\n\n        //sourceFilePath原文件的路径，comPreFilePath解压后的文件的路径\n\n        //创建文件输入流\n\n        FileInputStream fileInputStream=null;  //文件输入流，读取源文件\n        ObjectOutputStream  objectOutputStream=null;//对象输出流，将压缩后的字节数组和哈夫曼编码对照表写入\n        OutputStream outputStream=null; //文件输出流，写入压缩文件\n\n\n        try {\n\n            fileInputStream=new FileInputStream(sourceFilePath);\n\n            byte [] bytes=new byte[fileInputStream.available()];\n            fileInputStream.read(bytes);\n\n            byte[] bytes1 = hafumanCompression(bytes);//压缩完后得到的字节数组\n\n            Map<Byte, String> hafumanTab = createHafumanTab(bytes);//哈夫曼编码表\n\n            outputStream=new FileOutputStream(comPreFilePath);\n            objectOutputStream=new ObjectOutputStream(outputStream);\n\n            objectOutputStream.writeObject(bytes1); //对象输出流将压缩后的字节数组写入压缩文件\n            objectOutputStream.writeObject(hafumanTab);//对象输出流将哈夫曼码表写入压缩文件\n\n\n\n\n\n\n        }\n        catch (Exception e){\n\n            System.out.println(e.getMessage());\n        }\n\n        finally {\n\n\n            try {\n                fileInputStream.close();\n                outputStream.close();\n                objectOutputStream.close();\n\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n        }\n\n    }\n\n\n    //文件解压\n\n    public  static  void Unzipfile(String sourceComPreFilePath,String unzipFilePath){\n\n        FileInputStream fileInputStream=null;//读取原压缩文件\n\n        FileOutputStream fileOutputStream=null;//写入解压文件\n\n        ObjectInputStream objectInputStream=null;//读取压缩文件的哈夫曼编码表和字节数组\n\n\n        try {\n            fileInputStream=new FileInputStream(sourceComPreFilePath);\n\n            objectInputStream=new ObjectInputStream(fileInputStream);\n\n            byte [] bytes= (byte [])objectInputStream.readObject(); //读取压缩后的字节数组\n            Map<Byte,String> map  =(Map<Byte,String>)objectInputStream.readObject();//读取编码表\n\n            //解压\n            byte[] decode = decode(bytes, map);\n\n            fileOutputStream=new FileOutputStream(unzipFilePath);\n            fileOutputStream.write(decode);\n\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        finally {\n\n            try {\n                fileInputStream.close();\n                objectInputStream.close();\n                fileOutputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n        }\n\n\n    }\n\n\n    //解压数据\n    //思路分析：首先呢，是需要把压缩后形成的字节数组遍历出来，每遍历到一个值，就把该值转成int,然后利用Integer的包装类\n    //转成二进制（需要注意的是，原来生成哈夫曼编码表的map集合中的每一个叶子节点对应的编码在压缩成字节的时候，\n    // 其实那个编码（比如说10101000）就看成是补码,转成byte类型的数据的时候是先把补码转成原码后的十进制值才是压缩后形成yte数组中的值。）\n    //，然后，当你用包装类把byte数组中的值转成功二进制的时候，会是32位（int是4个字节），那么就要截取后8位，形成的值就是原来的编码。\n    //假如byte数组中的值是正数的话，它转成二进制后，位数后不够8位，比如77，转成后变成了1001101，那么就要补高位，就是与256（100000000）相与就可以了\n    //然后要是最后一个字节的话，就不用补高位了，它转成后是啥就是啥，但是它要是负数的话就要截取后8位了。\n\n\n    //flag是判断是否是最后一个字节，如果是的话，就不用补高位,temp是遍历压缩后的字节数组的每一个元素\n    public static String toBitStr(boolean flag,byte b){\n\n        String s=null;\n        int a=b;\n        if(flag){\n\n           // 不是最后一个字节\n            a|=256;  //按位或，如果是负数的话保持不变，如果是正数的话就会补齐位数。（如1001101会变成101001101,后面再截取8位就可以了）\n             s = Integer.toBinaryString(a);\n\n            s = s.substring(s.length() - 8);//截取后8位\n\n        }\n\n        else{\n            s=Integer.toBinaryString(a);\n\n            if(a<0){\n\n                s=s.substring(s.length()-8);\n\n            }\n\n        }\n     return  s;\n\n    }\n\n\n    //解压的方法，需要一个压缩后生成的字节数组，还有哈夫曼编码对照表\n    public  static  byte[]  decode(byte[] byteHafumanCode,Map<Byte,String> hfumaCodeTa ){\n\n        StringBuilder builder=new StringBuilder();\n        for(int i=0;i<byteHafumanCode.length;i++){\n\n            boolean flag=(i==byteHafumanCode.length-1);\n\n            String s = toBitStr(!flag, byteHafumanCode[i]);\n\n            builder.append(s);\n        }\n\n        Map<String,Byte> map=new HashMap<String,Byte>();//用一个map来存放，比如key:100010 value:97，方便还原\n        //接下来要把哈夫曼编码对照表的数据调过来\n\n        for (Map.Entry<Byte,String> m:hfumaCodeTa.entrySet()){\n\n            map.put(m.getValue(),m.getKey());\n\n        }\n\n\n        //接下来就是比对了\n\n        List<Byte> list=new ArrayList<>(); //定义这个集合来存放匹配到的数据\n\n        //遍历字符串\n\n        for(int i=0;i<builder.length();){\n\n            //定义一个计数器，从i开始的位置，匹配到了就退出\n\n            int count=1;\n            boolean f=true;\n            while (f){\n\n                String substring = builder.substring(i, i+count);\n\n                if(map.get(substring)==null){\n\n                    //如果对照表中没有这个串对应的值，count++\n                    count++;\n\n                }\n                else{\n\n                    //说明匹配到了\n\n                    list.add(map.get(substring));\n                    f=false;\n\n                }\n\n\n            }\n\n            i=i+count;\n\n\n        }\n\n\n        //循环结束，list集合中就存在着对应的匹配值，现在把list转成byte[]\n\n        byte [] decodeHafuman=new byte[list.size()];\n        for (int i=0;i<list.size();i++){\n\n            decodeHafuman[i]=list.get(i);\n\n        }\n\n        return  decodeHafuman;\n\n    }\n\n\n    //数据压缩，把类似100000100...每8位一个字节，转化成十进制数(byte类型),得到一个Byte[]数组，这就是哈夫曼的压缩\n\n    //参数是原来的字符串字节数组\n    public static byte[]  hafumanCompression(byte[] strByte){\n\n        Map<Byte, String> hafumanTab = createHafumanTab(strByte);\n        //需要按照字符串顺序，把它们的对应的编码这些东西存到StringBulider中，然后进行截取。。\n        StringBuilder builder=new StringBuilder();\n        for(byte b:strByte){\n\n            builder.append(hfumaCodeTa.get(b));\n\n        }\n    //System.out.println(builder.toString());\n        //然后进行每8位截取求值\n        //定义一个接收字节数组\n        int len=0;\n        if(builder.length()%8==0){\n\n            len=builder.length()/8;\n\n        }\n        else{\n\n            len=builder.length()/8+1;\n        }\n        byte[] byteHafumanCode=new byte[len];\n        int index=0;\n        Byte a=null;\n        for(int i=0;i<builder.length();i+=8){\n\n            // i 0 8 16 24\n            //首先判断截取的8位是否是在字符串的长度之内\n\n            if(i+8>builder.length()){\n\n                 a=(byte)Integer.parseInt(builder.substring(i),2);//直接截取从该位置到最后的字符,\n                                                             // 输出该字符串的二进制转成10进制再强转byte的数据\n\n            }\n            else{\n\n                //满足8位\n                 a=(byte)Integer.parseInt(builder.substring(i,i+8),2);//从i 开始，到i+8前一位截取，不包括i+8\n                                                                // 输出该字符串的二进制转成10进制再强转byte的数据\n\n                //byte转int后，byte是1字节，int是4字节，所以取int的该十进制的值的后8位，第一位当符号位。符号位如果是1的话，\n                // 记住，负数用补码来存储，转成原码是符号位除外，其他为取反，再加1\n            }\n\n            byteHafumanCode[index]=a;\n            index++;\n\n\n        }\n\n\n\n        return  byteHafumanCode;\n\n\n\n\n\n    }\n\n\n\n    //重载生成哈夫曼编码Map<Byte,String>的方法，方便调用\n\n    //参数是原字符串的字节数组\n    public  static Map<Byte,String>createHafumanTab(byte [] strByte) {\n\n        //生成哈夫曼树得到哈夫曼的根节点\n        Node2 root = createhafuManTree(auxiliarycreatehafuManTree(strByte));\n      StringBuilder builder=new StringBuilder();\n        if(root!=null){\n\n            createHafumanTab(root,\"\",builder);\n\n            return hfumaCodeTa;\n        }\n\n        else{\n\n            return  null;\n        }\n\n\n    }\n    //现在需要得到哈夫曼表，像这样o: 1000 u: 10010 d: 100110 y: 100111 i: 101 a : 110 k: 1110 e: 1111 j: 0000 v: 0001 l: 001 : 01\n\n    //参数：hafumanRoot哈夫曼树的根节点，code(左边为0,右边为1，stringBuilder拼接路径code)\n\n\n    public  static void createHafumanTab(Node2 hafumanRoot,String code,StringBuilder stringBuilder){\n\n        //分别从根节点的左边和右边进行递归直到找到叶子节点\n\n        StringBuilder builder=new StringBuilder(stringBuilder);\n            builder.append(code);\n        if(hafumanRoot.getData()==null){\n\n               //说明不是叶子节点\n\n            //向左递归寻找\n            if(hafumanRoot.getLeft()!=null) {\n                createHafumanTab(hafumanRoot.getLeft(), \"0\", builder);\n            }\n            if(hafumanRoot.getRight()!=null) {\n                createHafumanTab(hafumanRoot.getRight(), \"1\", builder);\n            }\n        }\n        else{\n\n\n\n\n            hfumaCodeTa.put(hafumanRoot.getData(),builder.toString());\n        }\n\n    //        StringBuilder stringBuilder2 = new StringBuilder(stringBuilder);\n    //        //将code 加入到 stringBuilder2\n    //        stringBuilder2.append(code);\n    //        if(hafumanRoot != null) { //如果node == null不处理\n    //            //判断当前node 是叶子结点还是非叶子结点\n    //            if(hafumanRoot.getData() == null) { //非叶子结点\n    //                //递归处理\n    //                //向左递归\n    //                createHafumanTab(hafumanRoot.getLeft(), \"0\", stringBuilder2);\n    //                //向右递归\n    //                createHafumanTab(hafumanRoot.getRight(), \"1\", stringBuilder2);\n    //            } else { //说明是一个叶子结点\n    //                //就表示找到某个叶子结点的最后\n    //                hfumaCodeTa.put(hafumanRoot.getData(), stringBuilder2.toString());\n    //            }\n    //        }\n\n        }\n\n    //辅助生成哈夫曼树\n    //参数是原字符串的byte数组\n    public static List<Node2> auxiliarycreatehafuManTree(byte [] strByte){\n\n    //封装一个List<Node2>集合\n    List<Node2> node2=new ArrayList<>();\n\n    Map<Byte,Integer>  counts=new HashMap<>(); //用来记录字节以及出现的次数\n    for(byte b:strByte){\n\n        Integer count = counts.get(b);\n\n        if(count==null){\n            //说明没有该字节\n\n            counts.put(b,1);\n\n        }\n        else {\n\n            counts.put(b,count+1);//已经存在的字节的个数\n\n        }\n\n    }\n\n    //遍历counts\n\n    for(Map.Entry<Byte,Integer> m:counts.entrySet()){\n\n        node2.add(new Node2(m.getKey(),m.getValue()));\n\n    }\n\n\n    return  node2;\n\n    }\n\n    //生成哈夫曼树\n    public  static  Node2 createhafuManTree(List<Node2> node2){\n\n    //生成哈夫曼树\n\n    while (node2.size()>1) {\n        Collections.sort(node2);\n\n        //取前两个\n        Node2 leftNode = node2.get(0);\n        Node2 rightNode = node2.get(1);\n\n        //生成新二叉树\n        Node2 parent=new Node2(null,leftNode.getWeight() + rightNode.getWeight());\n        parent.setLeft(leftNode);\n        parent.setRight(rightNode);\n\n        node2.remove(leftNode);\n        node2.remove(rightNode);\n\n        node2.add(parent);\n\n\n    }\n\n       return  node2.get(0);\n    }\n\n    public static void preOrder(Node2 root){\n\n\n    if(root!=null){\n\n        root.preOrder(root);\n\n    }\n\n\n    }\n\n\n    }\n\n    class  Node2  implements  Comparable<Node2>{\n\n    private  Byte data; //数据\n    private  int weight; //权重\n    private  Node2 left;//左节点\n    private  Node2 right;//右节点\n\n\n    public Node2(Byte data, int weight) {\n        this.data = data;\n        this.weight = weight;\n    }\n\n\n    @Override\n    public String toString() {\n        return \"Node2{\" +\n                \"data=\" + data +\n                \", weight=\" + weight +\n                '}';\n    }\n\n    public Byte getData() {\n        return data;\n    }\n\n    public void setData(  Byte data) {\n        this.data = data;\n    }\n\n    public int getWeight() {\n        return weight;\n    }\n\n    public void setWeight(int weight) {\n        this.weight = weight;\n    }\n\n    public Node2 getLeft() {\n        return left;\n    }\n\n    public void setLeft(Node2 left) {\n        this.left = left;\n    }\n\n    public Node2 getRight() {\n        return right;\n    }\n\n    public void setRight(Node2 right) {\n        this.right = right;\n    }\n\n    @Override\n    public int compareTo(Node2 o) {\n\n\n        //这个方法啊（this.age相当于参数o1,o.age相当于参数o2,但是在原码中o1,o2是调过来的\n        //比如说 1,2,6,5,4,3\n\n        //当你设置if(this.age>o.age){\n        //\n        //            return 1;\n        //        }\n        //        else if(this.age<o.age){\n        //\n        //            return -1;\n        //        }\n        //        else {\n        //\n        //            return 0;\n        //        }\n        // 你设置this.age的时候是当前age嘛，(比如1和2比较)所以就是1（o1），那么o.age就是2(o2)，\n        // 但是在源码中 2其实是o1,1其实是o2,那么你在源码中是o1>o2的，所以就返回的是1,既然返回1了，源码的执行就会去到升序的方法\n        // 循环找，一直找到返回-1的，就是o1<o2,然后就记录o1的位置，然后进行二分插入升序排序\n\n        //当你设置 if(this.age>o.age){\n        //\n        //            return -1;\n        //        }\n        //        else if(this.age<o.age){\n        //\n        //            return 1;\n        //        }\n        //        else {\n        //\n        //            return 0;\n        //        }\n        //\n        // ）\n        // 比如1,2比较，源码中1是o2,2是o1,这个时候o1>o2返回的是-1，那么就会进入降序的方法，直到找到返回1的，就是o1<o2,然后\n        //就反转o2前面的数据，即从o2位置到开始位置反转过来，然后再进行二分降序排序。\n\n\n        //这个就是升序的，也可以写成  return this.age-o.age;\n        // 降序的话可以写成o.age-this.age(举个例子:o.age-this.age>0的时候其实就是this.age-o.age<0的时候，也就是说你o.age-this.age>0返回的值就是\n        //this.age-o.age <0的时候返回的值，比如说o.age-this.age=1 >0（返回1），那么this.age-o.age<0返回的也是1，这样就去到了降序)\n        return this.weight-o.weight;\n    }\n\n\n    //前序遍历\n\n    public  void preOrder(Node2 node2){\n\n        System.out.println(node2);\n\n        if(node2.getLeft()!=null){\n\n            preOrder(node2.getLeft());\n        }\n        if(node2.getRight()!=null){\n\n            preOrder(node2.getRight());\n        }\n\n\n    }\n    }\n\n\n\n\n","tags":["学习笔记"]},{"title":"数据结构-堆排序","url":"/2020/04/30/数据结构-堆排序/","content":"\n树结构的实际应用-堆排序\n\n<!-- more-->\n\n### 堆排序\n\n1) 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复 杂度均为 O(nlogn)，它也是不稳定排序。\n  \n2) 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有 要求结点的左孩子的值和右孩子的值的大小关系。\n   \n3) 每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆 \n    \n4) 大顶堆举例说明\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/8B745253E2AD469C9E186E6F2C382C13/124)\n\n5)小顶堆举例说明\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/BA0AD5FDDB15460A9393E4C52862C9B4/126)\n\n6) 一般升序采用大顶堆，降序采用小顶堆\n\n\n### 堆排序基本思想\n\n1) 将待排序序列构造成一个大顶堆 \n\n2) 此时，整个序列的最大值就是堆顶的根节点。 \n\n3) 将其与末尾元素进行交换，此时末尾就为最大值。 \n\n4) 然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，便能得到一个有序 序列了\n\n\n### 堆排序步骤图解说明\n\n要求：给你一个数组 {4,6,8,5,9} , 要求使用堆排序法，将数组升序排序\n\n步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。 \n\n原始的数组 [4, 6, 8, 5, 9] 1) .假设给定无序序列结构如下\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/BC76FD6255764C508AC4EA4D49FA9F73/128)\n\n\n2) .此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的 6 结点），从左至右，从下至上进行调整。\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/ACA07AC88F8A4A82876D7A07E49228AD/130)\n\n3) .找到第二个非叶节点 4，由于[4,9,8]中 9 元素最大，4 和 9 交换。\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/DD39A475C2EF4A748D3366FFF37F951E/132)\n\n4) 这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中 6 最大，交换 4 和 6\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/78A6B3742C714CC4932DDE71EE951B0A/134)\n\n此时，我们就将一个无序序列构造成了一个大顶堆\n\n步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，\n得到第二大元素。如此反复进行交换、重建、交换。\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/A012A94195374466823B64744F170957/136)\n\n2) .重新调整结构，使其继续满足堆定义\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/92F3A4C39A24457183A5780C6209FB43/138)\n\n3) .再将堆顶元素 8 与末尾元素 5 进行交换，得到第二大元素 8\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/D3A159CF0F3F4FAFA50AE8BD436BE69F/140)\n\n4) 后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/1B7951A37DEB4518BAC862A1CF6CE336/142)\n\n\n再简单总结下堆排序的基本思路： \n\n1).将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;\n\n 2).将堆顶元素与末尾元素交换，将最大元素\"沉\"到数组末端; \n \n 3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤， 直到整个序列有序。\n\n----\n\n代码如下:\n\n     public class HeapSortDemo {\n\n    //堆排序：；\n\n    /*\n\n    堆排序：基本思想与思路分析\n\n    首先给你一个无序的序列，如果是升序的话就使用大顶堆（每个结点的值都大于或等于其左右孩子结点的值），降序的话就用\n    小顶堆（每个结点的值都小于或等于其左右孩子结点的值）\n\n\n        在数组里面的元素，按照索引的位置排成二叉树，首先去到二叉树的最后一个非叶子节点，\n\n        （这样比较好理解，其实每次应该从根节点开始循环调整）（arr.length / 2 -1）\n\n        先记录下来这个节点的值。然后去到该节点的左节点，判断左节点的值是否小于右节点的值，如果是的话，就把指针指向右边这个值。否则指针位置不变\n\n        再拿左右两边的比较大值与父节点比较，如果比父节点大的话就交换位置，然后原来指向非叶子节点的指针就要指向左右节点中比较大的一方，（因为下面可能还有需要调整的。\n\n        每次调整完，那么根节点就是最大的值了，就把根节点与数组最后一个数据交换，再继续调整（这个时候不要数组末尾的数据了）\n\n     */\n\n\n     public static void main(String args[]) {\n         int arr[] = {4, 6, 8, 5, 9};\n         heapSort(arr);\n\n     }\n\n\n     public  static  void  heapSort(int [] arr){\n\n         int temp=0;\n         //现在把无序数组调整成一个大顶堆（初始）\n\n         for (int i=arr.length/2-1;i>=0;i--){\n\n             //从最后一个非叶子开始\n\n             adjust(arr,i,arr.length);  //这里的调整长度写固定，因为先是把初始数组的元素搞成一个大顶堆\n\n         }\n\n         //现在循环结束就已经把数组所有元素改成大顶堆了（数组第一个元素就是最大的）\n\n         //现在是进行把数组最大的元素arr[0]与末尾元素交换，然后去新一轮的调整把最大数调整到数组的0。。\n\n         for (int j=arr.length-1;j>0;j--){\n\n             //交换\n             temp=arr[j];//末值\n             arr[j]=arr[0];//最大值去到末尾\n             arr[0]=temp;//原来末尾值去到第一个位置\n             adjust(arr,0,j); //继续新一轮，都是从最开始的根节点开始。就是说是在原来的大顶堆的基础上。。细品。\n\n         }\n\n       System.out.println(Arrays.toString(arr));\n\n\n     }\n\n\n     public  static  void  adjust(int [] arr,int i, int length){\n\n\n\n         //是从下往上调整的\n\n         //arr需要排序的数组，i是非叶子节点的索引位置，length是需要调整的数组长度,每调整完一次都要减少\n\n\n         //k是从当前非叶子节点的左节点开始，k（索引）的范围就是要小于要调整的数组长度,k=k*2+1表示当我比较当前非叶子节点左右节点谁大谁小之了后，\n         // k指针移动到\n         // 左右节点中比较大的那一个节点，然后与父节点比较，要是有调整的话可能会造成下面的局部堆混乱(因为我是从下往上的调整的,\n         // 调整上面的可能会造成下面的混乱)\n         int temp=arr[i];//记录当前非叶子节点的值\n\n         for(int k= i*2+1;k<length;k=k*2+1){\n\n             if( k+1 < length && arr[k]<arr[k+1] ){\n\n                 //说明左节点小于右节点的值，那么k要后移到右节点，所以k++\n                 k++;\n\n             }\n\n             //就是说我要拿到左右节点中比较大的一个值的索引，再拿该索引的值与temp进行比较\n\n             if(arr[k]>temp){\n\n\n                 //右节点比当前非叶子节点的值大，就要交换\n                 arr[i]=arr[k];\n                 arr[k]=temp; //直接交换，不用去到循环结束再交换\n                 i=k;  //为什么我把左右节点中值比较大的索引给i呢，因为你是在大的地方跟父节点比较并调整（或不调整）的，\n                 // 那么大的这个索引处要是调整了，那么它下面的局部堆可能会发生混乱，这样我就要i=k,去继续下面的局部堆判断调整\n\n                 //值比较小的那个就不用动它，因为我是从下往上调整的上面一个节点没动，那下面的就不动。\n\n             }\n             else{\n\n\n                 break;\n\n                 //从下往上调整的，比如说0这个的非叶子节点的局部堆（3个元素）啥都不用动，那么下面就不用动了，直接break\n                 //为什么我可以break掉，因为我是从最后一个非叶子节点开始的，假如最后一个非叶子节点和它的左右节点已经\n                 //是一个局部的大顶堆了，那么就不用再继续下去了。可以再到上一个非叶子节点，\n                 // 假如它还是已经是一个局部的大顶堆的话，也可以直接去看再上一非叶子节点\n\n             }\n\n         }\n\n        // arr[i]=temp;//就是循环退出后，i的值就已经到了原来左右节点中比较大的那个值的位置，并且已经和非叶子节点交换了，所以就把\n                      //原来非叶子节点的值赋值给这个发生交换的位置。 这样比较难理解，可以直接在循环里面交换\n\n     }\n\n    }\n\n\n\n\n","tags":["学习笔记"]},{"title":"后序线索化二叉树（Java版）","url":"/2020/04/30/后序线索化二叉树（Java版）/","content":"\n后序线索化\n<!-- more-->\n\n前面介绍了前序线索化二叉树、中序线索化二叉树，本文将介绍后序线索化二叉树。之所以用单独的一篇文章来分析后序线索化二叉树，是因为后序线索化二叉树比前序、中序要复杂一些；另外在复习线索化二叉树的过程中，大部分讲解数据结构的书籍中都是以中序线索化为例，在网上搜索也很少有详细讲解前序、后序线索化的文章，对于使用Java语言编写的代码更是凤毛麟角，因此决定把个人的理解过程记录下，并分享给有需要的同学参考。\n\n### 一、图解后序线索化\n\n  如果你很清楚的理解了前序、中序线索化二叉树，那么下面的图解不难理解；如果你还未掌握前序、中序线索化二叉树，请先详细阅读线索二叉树之前序、中序线索化（Java版），然后再回来阅读本文更便于理解。\n  下图是一棵后序线索化的二叉树，如下图：\n\n   ![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/315B0C850ADA4FFAAC6D6DF28A9F2B36/122)\n\n\n   为了更清晰、直观的表示出后继线索，在上图中忽略了前驱线索，请自行脑补。通过观察上图，节点H的后继节点是I，因此节点H的right指针指向I；节点I的后继节点是D，因此节点D的right指针指向D；节点D的后继节点是E，但是节点D的right指针指向了子节点B，因此D的right指针也就不能指向后继节点；同理节点B也没办法指向后继节点F。\n\n\n 对这棵二叉树完成后序线索化之后，我们在对其进行遍历时，我们知道后序遍历的顺序是：左右根，那对于上图的后序遍历结果是：HIDEBFGCA。\n\n\n 遍历后序线索化二叉树的思路：由于是后序线索化，那么后序遍历的开始节点一定是最左子节点，从根节点出发找到最左子节点，如何判断是否是最左子节点呢？如果是最左子节点，则其left指针一定的线索，如上图我们找到最左子节点H，H的right指针是后继线索，找到节点I，节点I的right指针是后继线索，找到节点D，节点D的right指针是子节点I，并不是后继线索指针，那么问题来了？此时我们该如何处理呢？\n\n通过观察D的后继节点E，但是D与E没有直接线索，不过D的父节点是B，B的右字节是E，存在这样一个间接的关系，我们是否可以利用这个间接的关系呢？答案是肯定的，但是按照我们上文介绍的节点数据结构，并不存在指向父节点的指针，因此我们要对节点数据结构进行修改，修改如下：\n\n   \n     //节点存储结构\n    static class Node {\n    String data;        //数据域\n    Node left;          //左指针域\n    Node right;         //右指针域\n    Node parent;        //父节点的指针（为了后序线索化使用）\n    boolean isLeftThread = false;   //左指针域类型  false：指向子节点、true：前驱或后继线索\n    boolean isRightThread = false;  //右指针域类型  false：指向子节点、true：前驱或后继线索\n\n    Node(String data) {\n        this.data = data;\n    }\n    }\n\n\n按照如上的存储结构增加了parent指针之后，D节点存在了指向父节点B的指针。当遍历到D节点时找到D节点的父节点B，B的right指针指向了子节点E，E的right指针又指向了B，这里又出现了另一个问题，就是进入了两次B，如果按照前面的方式则进入了一个死循环。以节点B为例，我们什么时候去找B的父节点，什么时候去处理他的右节点呢。我们分析下两次进入节点B，第一次是通过B的左节点进入，第二次是通过右子节点进入，我们可以记录上一个处理的节点，如果上一个处理的节点是B的左节点，则接下进入B的右节点，如果上一个处理的节点是B的右节点，则说明B的左右子树都处理完成，继续处理B的父节点。\n\n\n### 二、Java代码实现后序线索化\n\n\n        public class PostThreadBinaryTree {\n\n    private Node preNode;   //线索化时记录前一个节点\n\n    //节点存储结构\n    static class Node {\n        String data;        //数据域\n        Node left;          //左指针域\n        Node right;         //右指针域\n        Node parent;        //父节点的指针（为了后序线索化使用）\n        boolean isLeftThread = false;   //左指针域类型  false：指向子节点、true：前驱或后继线索\n        boolean isRightThread = false;  //右指针域类型  false：指向子节点、true：前驱或后继线索\n\n        Node(String data) {\n            this.data = data;\n        }\n    }\n\n\n    static Node createBinaryTree(String[] array, int index) {\n        Node node = null;\n\n        if (index < array.length) {\n            node = new Node(array[index]);\n            node.left = createBinaryTree(array, index * 2 + 1);\n            node.right = createBinaryTree(array, index * 2 + 2);\n\n            //记录节点的父节点（后序线索化遍历时使用）\n            if (node.left != null) {\n                node.left.parent = node;\n            }\n\n            if (node.right != null) {\n                node.right.parent = node;\n            }\n        }\n\n        return node;\n    }\n\n    //后序线索化\n    void postThreadOrder(Node node) {\n        if (node == null) {\n            return;\n        }\n\n        //处理左子树\n        postThreadOrder(node.left);\n        //处理右子树\n        postThreadOrder(node.right);\n\n        //左指针为空,将左指针指向前驱节点\n        if (node.left == null) {\n            node.left = preNode;\n            node.isLeftThread = true;\n        }\n\n        //前一个节点的后继节点指向当前节点\n        if (preNode != null && preNode.right == null) {\n            preNode.right = node;\n            preNode.isRightThread = true;\n        }\n        preNode = node;\n    }\n\n\n    //后续遍历线索二叉树，按照后继方式遍历（思路：后序遍历开始节点是最左节点）\n    void postThreadList(Node root) {\n        //1、找后序遍历方式开始的节点\n        Node node = root;\n        while (node != null && !node.isLeftThread) {\n            node = node.left;\n        }\n\n        Node preNode = null;\n        while (node != null) {\n            //右节点是线索\n            if (node.isRightThread) {\n                System.out.print(node.data + \", \");\n                preNode = node;\n                node = node.right;\n\n            } else {\n                //如果上个处理的节点是当前节点的右节点\n                if (node.right == preNode) {\n                    System.out.print(node.data + \", \");\n                    if (node == root) {\n                        return;\n                    }\n\n                    preNode = node;\n                    node = node.parent;\n\n                } else {    //如果从左节点的进入则找到有子树的最左节点\n                    node = node.right;\n                    while (node != null && !node.isLeftThread) {\n                        node = node.left;\n                    }\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        String[] array = {\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\"};\n        Node root = createBinaryTree(array, 0);\n\n        PostThreadBinaryTree tree = new PostThreadBinaryTree();\n        tree.postThreadOrder(root);\n        System.out.println(\"后序按后继节点遍历线索二叉树结果：\");\n        tree.postThreadList(root);\n    }\n    }\n\n\n### 三、前序、中序、后序线索化比较\n\n1. 前序线索化二叉树遍历相对最容易理解，实现起来也比较简单。由于前序遍历的顺序是：根左右，所以从根节点开始，沿着左子树进行处理，当子节点的left指针类型是线索时，说明到了最左子节点，然后处理子节点的right指针指向的节点，可能是右子树，也可能是后继节点，无论是哪种类型继续按照上面的方式（先沿着左子树处理，找到子树的最左子节点，然后处理right指针指向），以此类推，直到节点的right指针为空，说明是最后一个，遍历完成。\n2. 中序线索化二叉树的网上相关介绍最多。中序遍历的顺序是：左根右，因此第一个节点一定是最左子节点，先找到最左子节点，依次沿着right指针指向进行处理（无论是指向子节点还是指向后继节点），直到节点的right指针为空，说明是最后一个，遍历完成。\n3. 后序遍历线索化二叉树最为复杂，通用的二叉树数节点存储结构不能够满足后序线索化，因此我们扩展了节点的数据结构，增加了父节点的指针。后序的遍历顺序是：左右根，先找到最左子节点，沿着right后继指针处理，当right不是后继指针时，并且上一个处理节点是当前节点的右节点，则处理当前节点的右子树，遍历终止条件是：当前节点是root节点，并且上一个处理的节点是root的right节点。\n","tags":["转载随笔"]},{"title":"线索二叉树原理及前序、中序线索化（Java实现）","url":"/2020/04/30/线索二叉树原理及前序、中序线索化（Java实现）/","content":"\n\n### 一、线索二叉树原理\n<!-- more-->\n\n前面介绍二叉树原理及特殊二叉树文章中提到，二叉树可以使用两种存储结构：顺序存储和二叉链表。在使用二叉链表的\n存储结构的过程中，会存在大量的空指针域，为了充分利用这些空指针域，引申出了“线索二叉树”。回顾一下二叉链表存储结构，如下图： \n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/2F43C5B3BF0441C296DA055899BE3BC0/109)\n\n通过观察上面的二叉链表，存在着若干个没有指向的空指针域。对于一个有n个节点的二叉链表，每个节点有指向左右节点的2个指针域，整个二叉链表存在2n个指针域。而n个节点的二叉链表有n-1条分支线，那么空指针域的个数=2n-(n-1) = n+1个空指针域，从存储空间的角度来看，这n+1个空指针域浪费了内存资源。 \n\n从另外一个角度来分析，如果我们想知道按中序方式遍历二叉链表时B节点的前驱节点或者后继节点时，必须要按中序方式遍历二叉链表才能够知道结果，每次需要结果时都需要进行一次遍历，是否可以考虑提前存储这种前驱和后继的关系来提高时间效率呢？ \n\n\n综合以上两方面的分析，可以通过充分利用二叉链表中的空指针域，存放节点在某种遍历方式下的前驱和后继节点的指针。\n\n我们把这种指向前驱和后继的指针成为线索，加上线索的二叉链表成为线索链表，对应的二叉树就成为“线索二叉树(Threaded Binary Tree)” 。\n\n\n### 二、构建线索二叉树过程\n\n1、我们对二叉树进行中序遍历，将所有的节点右子节点为空的指针域指向它的后继节点。如下图： \n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/7A35F67A379A4F2BBDF590100205EB17/112)\n\n通过中序遍历我们知道H的right指针为空，并且H的后继节点为D（如上图第1步），I的right指针为空，并且I的后继节点为B（如上图第2步），以此类推，知道G的后继节点为null，则G的right指针指向null。\n\n2、接下来将这颗二叉树的所有节点左指针域为空的指针域指向它的前驱节点。如下图：\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/4AD276D6043E499982467AA1DC46377A/114)\n\n\n\n如上图，H的left指针域指向Null（如第1步），I的前驱节点是D，则I的left指针指向D，以此类推。 通过上面两步完成了整个二叉树的线索化，最后结果如下图： \n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/BBF81C1055444B3AA676BCC78F053241/116)\n\n\n通过观察上图（蓝色虚线代表后继、绿色虚线代表前驱），可以看出，线索二叉树，等于是把一棵二叉树转变成了一个“特殊的双向链表“(后面会解释为什么叫特殊的双向链表），这样对于我们的新增、删除、查找节点带来了方便。所以我们对二叉树以某种次序遍历使其变为线索二叉树的过程称做是线索化。如下图： \n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/8500A95BEB8C43C19F5F246E630E9E36/118)\n\n\n仔细分析上面的双向链表，与线索化之后的二叉树相比，比如节点D与后继节点I，在完成线索化之后，并没有直接线索指针，而是存在父子节点的指针；节点A与节点F，在线索化完成之后，节点A并没有直接指向后继节点F的线索指针，而是通过父子节点遍历可以找到最终的节点F，前驱节点也存在同样的问题，正因为很多节点之间不存在直接的线索，所以我将此双向链表称做“特殊的双向链表”，再使用过程中根据指针是线索指针还是子节点指针来分别处理，所以在每个节点需要标明当前的左右指针是线索指针还是子节点指针，这就需要修改节点的数据结构。修改后的数据结构如下：\n\n        class Node {\n        String data;    //数据域\n        Node left;      //左指针域\n        Node right;     //右指针域\n        byte leftType;  //左指针域类型 0：指向子节点、1：前驱或后继线索\n        byte rightType; //右指针域类型 0：指向子节点、1：前驱或后继线索\n    }\n\n\n\n\n\n\n最终的二叉链表修改为如下图的样子： \n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/06855AF985A746A3ACD5CC0860FF7845/120)\n\n\n\n###  三、线索二叉树的代码（Java实现）\n\n代码如下：\n\n      public class ThreadBinaryTree {\n\n        private Node preNode;   //线索化时记录前一个节点\n\n        //节点存储结构\n        static class Node {\n        String data;        //数据域\n        Node left;          //左指针域\n        Node right;         //右指针域\n        boolean isLeftThread = false;   //左指针域类型  false：指向子节点、true：前驱或后继线索\n        boolean isRightThread = false;  //右指针域类型  false：指向子节点、true：前驱或后继线索\n\n        Node(String data) {\n            this.data = data;\n        }\n        }\n        \n        static Node createBinaryTree(String[] array, int index) {\n        Node node = null;\n             \n           //递归创建二叉树\n        if(index < array.length) {\n            node = new Node(array[index]);\n            node.left = createBinaryTree(array, index * 2 + 1);\n            node.right = createBinaryTree(array, index * 2 + 2);\n        }\n\n        return node;\n       }\n\n             \n         //中序线索化\n        void inThreadOrder(Node node) {\n        if(node == null) {\n            return;\n        }\n\n        //处理左子树\n        inThreadOrder(node.left);\n\n        //左指针为空,将左指针指向前驱节点\n        if(node.left == null) {\n            node.left = preNode;\n            node.isLeftThread = true;\n        }\n\n        //前一个节点的后继节点指向当前节点\n        if(preNode != null && preNode.right == null) {\n            preNode.right = node;\n            preNode.isRightThread = true;\n        }\n        preNode = node;\n\n        //处理右子树\n        inThreadOrder(node.right);\n    }\n\n          //中序线索化遍历(找后继节点，从左往右)\n        void inThreadList(Node node) {\n        //1、找中序遍历方式开始的节点\n        while(node != null && !node.isLeftThread) {\n            node = node.left;\n        }\n\n        while(node != null) {\n            System.out.print(node.data + \", \");\n\n            //如果右指针是线索\n            if(node.isRightThread) {\n                node = node.right;\n\n            } else {    //如果右指针不是线索，找到右子树开始的节点\n                node = node.right;\n                while(node != null && !node.isLeftThread) {\n                    node = node.left;\n                }\n            }\n        }\n    }\n\n            //中序线索化遍历（从右往左，找前驱节点）\n        void inPreThreadList(Node node) {\n        //1、找最后一个节点\n        while(node.right != null && !node.isRightThread) {\n            node = node.right;\n        }\n\n        while(node != null) {\n            System.out.print(node.data + \", \");\n\n            //如果左指针是线索\n            if(node.isLeftThread) {\n                node = node.left;\n\n            } else {    //如果左指针不是线索，找到左子树开始的节点\n                node = node.left;\n                while(node.right != null && !node.isRightThread) {\n                    node = node.right;\n                }\n            }\n        }\n    }\n\n            \n                //前序线索化\n        void preThreadOrder(Node node) {\n        if(node == null) {\n            return;\n        }\n\n        //左指针为空,将左指针指向前驱节点\n        if(node.left == null) {\n            node.left = preNode;\n            node.isLeftThread = true;\n        }\n\n        //前一个节点的后继节点指向当前节点\n        if(preNode != null && preNode.right == null) {\n            preNode.right = node;\n            preNode.isRightThread = true;\n        }\n\n        preNode = node;\n\n        //处理左子树\n        if(!node.isLeftThread) {\n            preThreadOrder(node.left);\n        }\n\n        //处理右子树\n        if(!node.isRightThread) {\n            preThreadOrder(node.right);\n        }\n    }\n\n       //前序线索化遍历\n    void preThreadList(Node node) {\n        while(node != null) {\n\n            while(!node.isLeftThread) {\n                System.out.print(node.data + \", \");\n                node = node.left;\n            }\n\n            System.out.print(node.data + \", \");\n            node = node.right;\n        }\n    }\n\n    public static void main(String[] args) {\n        String[] array = {\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\"};\n        Node root = createBinaryTree(array, 0);\n\n        ThreadBinaryTree tree = new ThreadBinaryTree();\n        tree.inThreadOrder(root);\n        System.out.println(\"中序按后继节点遍历线索二叉树结果：\");\n        tree.inThreadList(root);\n        System.out.println(\"\\n中序按前驱节点遍历线索二叉树结果：\");\n        tree.inPreThreadList(root);\n\n        Node root2 = createBinaryTree(array, 0);\n        ThreadBinaryTree tree2 = new ThreadBinaryTree();\n        tree2.preThreadOrder(root2);\n        tree2.preNode = null;\n        System.out.println(\"\\n前序按后继节点遍历线索二叉树结果：\");\n        tree.preThreadList(root2);\n    }\n    }\n\n\n\n### 四、小结\n线索化的实质就是将二叉链表中的空指针改为指向前驱节点或后继节点的线索；\n\n线索化的过程就是修改二叉链表中空指针的过程，可以按照前序、中序、后序的方式进行遍历，分别生成不同的线索二叉树；\n\n有了线索二叉树之后，我们再次遍历时，就相当于操作一个双向链表。\n\n使用场景：如果我们在使用二叉树过程中经常需要遍历二叉树或者查找节点的前驱节点和后继节点，可以考虑采用线索二叉树存储结构。","tags":["转载随笔"]},{"title":"数据结构-顺序存储二叉树和线索化二叉树","url":"/2020/04/30/数据结构-顺序存储二叉树和线索化二叉树/","content":"\n顺序存储二叉树\n<!-- more-->\n\n从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/34D4D8FE711E45F387C2E2EC79786AA4/103)\n\n\n特点：\n\n1) 顺序二叉树通常只考虑完全二叉树 \n\n2) 第 n 个元素的左子节点为 2 * n + 1 \n\n3) 第 n 个元素的右子节点为 2 * n + 2 \n\n4) 第 n 个元素的父节点为 (n-1) / 2 \n\n5) n : 表示二叉树中的第几个元素(按 0 开始编号如图所示)\n\n\n\n\n### 顺序存储二叉树遍历\n\n\n给你一个数组 {1,2,3,4,5,6,7}，要求以二叉树前，中，后序遍历的方式进行遍历。\n\n代码如下：\n\n\n     public class ArrBinaryTreeDemo {\n\n\n    //顺序存储二叉树\n\n    //树可以转成数组，数组也可以转成树\n    //如int [] arr={1,2,3,4,5,6},那么从索引0开始，二叉树从上到下，从左到右也是按照数组的索引来排的，对应的也是数组的数据\n\n     public static void main(String args[]) {\n\n\n         //顺序存储二叉树按照前序，中序，后序遍历\n\n         //测试前序遍历\n         int [] arr={1,2,3,4,5,6,7};\n         ArrBinary arrBinary=new ArrBinary(arr);\n\n          arrBinary.preOrderStart();\n\n          //中序\n        System.out.println(\"前序完成\");\n\n         arrBinary.inOrderStart();\n\n         System.out.println(\"中序完成\");\n         //后序\n\n         arrBinary.postOrderStart();\n\n         System.out.println(\"后序完成\");\n\n     }\n\n\n\n\n    }\n\n    //顺序存储二叉树类\n    class ArrBinary{\n\n\n    private  int [] arr;  //需要一个数组\n\n    public ArrBinary(int[] arr) {\n        this.arr = arr;\n    }\n\n\n    public  void  preOrderStart(){\n\n        preOrder(0);\n    }\n    public  void  inOrderStart(){\n\n        inOrder(0);\n    }\n    public  void  postOrderStart(){\n\n        postOrder(0);\n    }\n\n    //前序遍历\n    public  void preOrder(int index){\n\n        //先输出当前节点\n        System.out.println(arr[index]);\n\n        //左边\n        if(2 * index+1<arr.length){\n\n            //去左边的节点\n            preOrder(2 * index+1);\n\n        }\n\n        //右边\n        if(2 * index+2<arr.length){\n\n            //去右边的节点\n            preOrder(2 * index+2);\n        }\n\n    }\n\n\n    //中序遍历\n\n    public  void inOrder(int index){\n\n        //先左边\n\n        if(2 * index+1<arr.length){\n\n            inOrder(2 * index+1);\n        }\n\n        System.out.println(arr[index]);\n\n        //右边\n\n        if(2 * index + 2<arr.length){\n\n            inOrder(2 * index + 2);\n\n        }\n\n    }\n    //后序遍历\n\n    public  void postOrder(int index){\n\n        //先左边\n\n        if(2 * index+1<arr.length){\n\n            postOrder((2 * index+1));\n        }\n        //右边\n\n        if(2 * index + 2<arr.length){\n\n            postOrder(2 * index + 2);\n\n        }\n\n        System.out.println(arr[index]);\n    }\n\n\n    }\n\n\n\n\n\n---\n---\n###  线索化二叉树\n\n 问题：将数列 {1, 3, 6, 8, 10, 14 } 构建成一颗二叉树. n+1=7\n\n ![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/64CE9DE4CB894BFE9F1E5516E9AC1201/105)\n\n 1) 当我们对上面的二叉树进行中序遍历时，数列为 {8, 3, 10, 1, 6, 14 } \n \n 2) 但是 6, 8, 10, 14 这几个节点的 左右指针，并没有完全的利用上. \n \n 3) 如果我们希望充分的利用 各个节点的左右指针， 让各个节点可以指向自己的前后节点,怎么办? \n \n 4) 解决方案-线索二叉树\n\n\n###  线索二叉树基本介绍\n\n1) n 个结点的二叉链表中含有 n+1 【公式 2n-(n-1)=n+1】 个空指针域。利用二叉链表中的空指针域，存放指向 该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为\"线索\"） \n\n2) 这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质 的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种 \n\n3) 一个结点的前一个结点，称为前驱结点 4) 一个结点的后一个结点，称为后继结点\n\n\n### 线索二叉树应用案例\n\n应用案例说明：将下面的二叉树，进行中序线索二叉树。中序遍历的数列为 {8, 3, 10, 1, 14, 6}\n\n中序遍历的结果：{8, 3, 10, 1, 14, 6}\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/22F8846E46BF47DF9ACEC38FEC222590/107)\n\n说明: 当线索化二叉树后，Node 节点的 属性 left 和 right ，有如下情况: \n\n1) left 指向的是左子树，也可能是指向的前驱节点. 比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的 就是前驱节点. \n\n2) right 指向的是右子树，也可能是指向后继节点，比如 ① 节点 right 指向的是右子树，而⑩ 节点的 right 指向 的是后继节点.\n\n\n### 遍历线索化二叉树\n\n\n\n全部代码如下：\n\n  \n\n\n\n\n    public class ThreadedBinaryTreeDemo {\n\n    //线索化二叉树\n\n\n    //如一个二叉树中序遍历的结果：{8, 3, 10, 1, 14, 6}\n\n    /*\n    * 8为例,8的前驱节点是null,后继节点是3， 3的前驱节点是8,后继节点是10\n    *\n    * 比如在某一个节点，如果该节点的左指针原来是空的，那么就把它的左指针指向它的前驱节点，\n    * 如果它的右指针是空的，那么右指针就指向它的后继节点，如果该节点原来的左或者右已经有指向了，那就不要动它\n    * */\n\n\n\n\n     public static void main(String args[]) {\n\n\n         //测试中序线索化\n         HeroNode2 root = new HeroNode2(1, \"tom\");\n         HeroNode2 node2 = new HeroNode2(3, \"jack\");\n         HeroNode2 node3 = new HeroNode2(6, \"smith\");\n         HeroNode2 node4 = new HeroNode2(8, \"mary\");\n         HeroNode2 node5 = new HeroNode2(10, \"king\");\n         HeroNode2 node6 = new HeroNode2(14, \"dim\");\n\n\n         //二叉树，后面我们要递归创建, 现在简单处理使用手动创建\n         root.setLeft(node2);\n         root.setRight(node3);\n         node2.setLeft(node4);\n         node2.setRight(node5);\n         node3.setLeft(node6);\n         root.setParent(null);\n         node2.setParent(root);\n         node3.setParent(root);\n         node4.setParent(node2);\n         node5.setParent(node2);\n         node6.setParent(node3);\n         ThreadedBinaryTree threadedBinaryTree=new ThreadedBinaryTree(root);\n\n         //以10来测试，看线索化后的10的左右指针\n\n         //threadedBinaryTree.threadedBinaryTreeInOrder();\n    //\n    //         System.out.println(node5.getLeft());\n    //         System.out.println(node5.getRight());\n\n    //         threadedBinaryTree.threadedBinaryTreepreOrder();\n    ////\n    //       System.out.println(node5.getLeft());\n    //         System.out.println(node5.getRight());\n\n            //threadedBinaryTree.threadedBinaryTreeList2();\n\n            threadedBinaryTree.threadedBinaryTreepostOrder();\n\n    //            System.out.println(node5.getLeft());\n    //            System.out.println(node5.getRight());\n\n\n            threadedBinaryTree.threadedBinaryTreepostOrderList();\n\n\n     }\n\n\n\n\n\n    }\n\n\n\n    class  ThreadedBinaryTree{\n\n    private    HeroNode2  root;\n    private  HeroNode2 pre;\n\n    public ThreadedBinaryTree(HeroNode2 root) {\n        this.root = root;\n    }\n\n\n      public  void  threadedBinaryTreeInOrder(){\n\n    this.threadedBinaryTreeInOrder(root);\n\n    }\n\n       public  void  threadedBinaryTreepreOrder(){\n\n    this.threadedBinaryTreepreOrder(root);\n\n    }\n       public  void  threadedBinaryTreepostOrder(){\n\n    this.threadedBinaryTreepostOrder(root);\n\n    }\n\n    //线索化二叉树的方法（中序）\n\n    public  void   threadedBinaryTreeInOrder(HeroNode2 node){\n\n        if(node==null){\n            //节点为空\n            return;\n        }\n\n        //中序线索化\n\n\n        //先左边\n        threadedBinaryTreeInOrder(node.getLeft());\n\n        //处理当前节点\n        //先处理左指针\n\n        if(node.getLeft()==null){\n\n            //左指针为空的情况下，那么就可以指向前驱节点了\n            node.setLeft(pre);\n            node.setLeftType(1);\n\n        }\n\n        //接下来到右节点,指向后继节点这种操作可以让node移动了一个位置再指向，比如说{8, 3, 10, 1, 14, 6},\n        // 当前是8,然后node移动到3的时候，那么你让pre同时也指向node的前一个也就是8,那么pre在指向3就可以了\n\n        if(pre!=null && pre.getRight()==null){\n\n            //前置节点不为空并且其右指针是没有指向的时候就可以操作后继节点了\n\n            pre.setRight(node);\n            pre.setRightType(1);\n        }\n\n        //让pre指向node,这样从8开始的话，当到3的时候上面的pre就是8，这样8就可以和3连接上了\n\n        pre=node;\n\n        //右边\n\n        threadedBinaryTreeInOrder(node.getRight());\n\n\n\n    }\n    //线索化二叉树的方法（前序）\n\n    public  void   threadedBinaryTreepreOrder(HeroNode2 node){\n\n\n        //前序线索化因为是从上往下走的，所以会遇到一个节点（左指针为空）的左指针指向上一个节点，这样在继续遍历的时候会造成死循环\n        if(node==null){\n            //节点为空\n            return;\n        }\n\n        //前序线索化\n\n\n\n        //处理当前节点\n        //先处理左指针\n\n        if(node.getLeft()==null){\n\n            //左指针为空的情况下，那么就可以指向前驱节点了\n            node.setLeft(pre);\n            node.setLeftType(1);\n\n        }\n\n        //接下来到右节点,指向后继节点这种操作可以让node移动了一个位置再指向，比如说{8, 3, 10, 1, 14, 6},\n        // 当前是8,然后node移动到3的时候，那么你让pre同时也指向node的前一个也就是8,那么pre在指向3就可以了\n\n        if(pre!=null && pre.getRight()==null){\n\n            //前置节点不为空并且其右指针是没有指向的时候就可以操作后继节点了\n\n            pre.setRight(node);\n            pre.setRightType(1);\n        }\n\n        //让pre指向node,这样从8开始的话，当到3的时候上面的pre就是8，这样8就可以和3连接上了\n\n        pre=node;\n\n\n        //左边\n         //这里要加条件，避免造成死循环\n        if(node.getLeftType()==0) {\n            threadedBinaryTreepreOrder(node.getLeft());\n        }\n        //右边\n      if(node.getRightType()==0) {\n    threadedBinaryTreepreOrder(node.getRight());\n      }\n\n\n    }\n\n\n    //中序线索化二叉树遍历的方法\n    //因为线索化后节点之间的连接会发生了一些变化，所以不能采用原来的遍历方式\n\n    //说一下遍历的思想,（这个时候所有节点的指针域都被利用了，直接判断节点是null的就可以退出循环了）就是中序的话，\n    // 先找到第一个leftType==1的节点，当前节点不是的话就一直向左边找，这样终究会找到第一个leftType==1的节点，\n    //\n    // 然后输出这个节点，然后去看看该节点的右节点是不是后继节点（rightType==1）,\n\n    //如果是的话就把node指针指向该节点并输出这个节点，继续循环找它的右节点，还是 这样判断。\n    //\n    // 如果不是的话那么node就指向它的下一个右节点节点，再执行上面的循环。。（哎哟，只可意会不可言传啊。。太难了）\n\n    public  void  threadedBinaryTreeList(){\n\n        //从左向右遍历，找后继节点\n\n\n        //因为是中序线索的\n        //从根节点开始，一直找左边一直找到一个leftType==1的节点\n        //说明这个就是中序线索化最开始的节点\n\n        HeroNode2 node=root;\n\n        while (node!=null){\n\n            //因为是中序线索化，所以不用判断一直向左找第一个节点会出现null指针异常，因为中序遍历总是向左会找到第一个节点\n            //但是如果是从右向左遍历就不一样了，可能一直向右找最后一个节点会造成空指针\n        while (node.getLeftType()==0){\n\n            node=node.getLeft();\n\n        }\n          //最外层的while循环执行第一次的时候，并且执行到小while循环退出说明找到第一个节点，并且其leftType==1\n        System.out.println(node);\n\n          while (node.getRightType()==1){\n\n              //说明该节点的右指针指向的直接就是后继节点\n              node=node.getRight();\n              System.out.println(node);\n\n          }\n\n          //否则循环退出，该node节点的右节点指向的是原来的右子树，那么就要把node替换到它的右节点，让这个右节点能够重新判断寻找\n\n            node=node.getRight();\n\n\n\n        }\n\n\n\n\n    }\n\n    public  void  threadedBinaryTreeList2(){\n\n\n\n        //中序遍历的第二种方式，找前驱节点，从最后一个后继节点开始\n\n        HeroNode2 node=root;\n\n        //1、找最后一个节点\n       // 但是如果是从右向左遍历就不一样了，可能一直向右找最后一个节点会造成空指针.所以要做判断。。\n        while(node.getRight()!= null && node.getRightType()==0) {\n            node = node.getRight();\n        }\n\n        while(node != null) {\n            System.out.print(node + \", \");\n\n            //如果左指针是线索\n            if(node.getLeftType()==1) {\n                node = node.getLeft();\n\n            } else {    //如果左指针不是线索，找到左子树开始的节点\n                node = node.getLeft();\n                while(node.getRight() != null && node.getRightType()==0) {\n                    node = node.getRight();\n                }\n            }\n        }\n\n    }\n\n\n    public  void  threadedBinaryTreePreList(){\n\n        //前序线索化的遍历，思路：从根节点开始，先向左找，碰到leftType==0的就输出，如果leftType==1就退出循环，输出该节点，\n        // 然后node节点移动到它的右节点，继续循环判断\n\n       //画个图,搞一遍，就是这个思路\n\n        HeroNode2 node2=root;\n        while (node2!=null){\n\n            while (node2.getLeftType()==0){\n\n                System.out.println(node2);\n                node2=node2.getLeft();\n\n            }\n\n            System.out.println(node2);\n\n            node2=node2.getRight();\n\n\n        }\n\n\n\n    }\n\n    //后序线索化\n\n    public  void  threadedBinaryTreepostOrder(HeroNode2 node2){\n\n\n        //后序线索化\n\n        //后序遍历和中序一样，不用考虑节点可能会造成死循环\n\n            if(node2==null){\n\n                return;\n            }\n        //左边\n            threadedBinaryTreepostOrder(node2.getLeft());\n\n\n            //右边\n\n            threadedBinaryTreepostOrder(node2.getRight());\n\n\n            //处理当前节点\n\n            if(node2.getLeft()==null){\n\n                //设置前驱节点\n                node2.setLeft(pre);\n                node2.setLeftType(1);\n            }\n\n            if(pre!=null && pre.getRight()==null){\n\n                pre.setRight(node2);\n                pre.setRightType(1);\n            }\n\n            pre=node2;  //处理完当前节点后，前驱节点指向当前节点，node节点继续去到下一个节点(2)的时候，pre就是2的前一个节点\n\n    }\n\n\n    //后序线索化遍历\n\n    public  void  threadedBinaryTreepostOrderList(){\n\n        //思路分析\n        /*\n\n\n         */\n\n        //1、找后序遍历方式开始的节点\n    //        HeroNode2 node = root;\n    //        while(node != null && node.getLeftType()==0) {\n     //            node = node.getLeft();\n    //        }\n     //\n    //        HeroNode2 preNode = null;\n    //        while(node != null) {\n    //            //右节点是线索\n    //            if(node.getRightType()==1) {\n    //                System.out.print(node);\n    //                preNode = node;\n    //                node = node.getRight();\n    //\n    //            } else {\n    //                //如果上个处理的节点是当前节点的右节点\n    //                if(node.getRight() == preNode) {\n    //                    System.out.print(node);\n    //                    if(node == root) {\n     //                        return;\n    //                    }\n    //\n    //                    preNode = node;\n    //                    node = node.getParent();\n    //\n    //                } else {    //如果从左节点的进入则找到有子树的最左节点\n    //                    node = node.getRight();\n    //                    while(node != null && node.getLeftType()==0) {\n    //                        node = node.getLeft();\n    //                    }\n    //                }\n    //            }\n      //        }\n      //\n\n\n        HeroNode2 node2=root;  //从根节点开始遍历\n\n        HeroNode2 preNode =null;\n\n\n            //先找到最左边的节点（刚开始）\n\n            while (node2!=null&&node2.getLeftType()==0){\n\n                node2=node2.getLeft();\n\n            }\n\n            while (node2!=null) {\n\n\n                if (node2.getRightType() == 1) {\n\n                    System.out.println(node2);\n\n                    preNode = node2;\n\n                    node2 = node2.getRight();\n                }\n                //循环退出说明已经不满足rightType==1,那么就要判断当前节点的的前置节点的位置了，如果前置节点是在当前节点的右节点\n                //就要移动当前节点到父节点的位置，也就是操作父节点，如果前置节点是在当前节点的左节点那，那么就直接移动到当前节点的右节点\n                else {\n                    if (node2.getRight() == preNode) {\n\n                        //先输出当前节点\n                        System.out.println(node2);\n                        if(node2==root){\n\n                            return;\n                        }\n                        preNode = node2; //前置节点指向当前\n                        node2 = node2.getParent();\n\n\n                    } else {\n\n                        //说明前置节点在当前节点的左节点\n                        //移动到当前节点的右节点就行了\n\n                        node2 = node2.getRight();\n\n                        while (node2!=null && node2.getLeftType()==0){\n                            node2=node2.getLeft();\n\n                        }\n\n                    }\n\n\n                }\n            }\n\n\n\n\n\n\n\n    }\n\n\n    }\n\n    class  HeroNode2{\n    private int no;//编号值\n    private  String name;//名称\n    private  HeroNode2 left; //指向左节点\n    private  HeroNode2 right;//指向右节点\n    private  HeroNode2 pre;//一个节点的前驱节点,默认为空\n    private  int leftType=0; //约定leftType=0表示左指针是连接着左子树的，=1表示是连接着前驱节点的\n    private  int rightType=0;//约定rightType=0表示右指针是连接着右子树的，=1表示是连接着后驱节点的\n    //这样约定会方便后面的遍历\n    private  HeroNode2 parent;\n\n\n\n\n\n\n    public HeroNode2(int no, String name) {\n        this.no = no;\n        this.name = name;\n    }\n\n\n    public int getNo() {\n        return no;\n    }\n\n    public void setNo(int no) {\n        this.no = no;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public HeroNode2 getLeft() {\n        return left;\n    }\n\n    public void setLeft(HeroNode2 left) {\n        this.left = left;\n    }\n\n    public HeroNode2 getRight() {\n        return right;\n    }\n\n    public void setRight(HeroNode2 right) {\n        this.right = right;\n    }\n\n    public int getLeftType() {\n        return leftType;\n    }\n\n    public void setLeftType(int leftType) {\n        this.leftType = leftType;\n    }\n\n    public int getRightType() {\n        return rightType;\n    }\n\n    public void setRightType(int rightType) {\n        this.rightType = rightType;\n    }\n\n    public HeroNode2 getParent() {\n        return parent;\n    }\n\n    public void setParent(HeroNode2 parent) {\n        this.parent = parent;\n    }\n\n    @Override\n    public String toString() {\n        return \"HeroNode{\" +\n                \"no=\" + no +\n                \", name='\" + name + '\\'' +\n                '}';\n    }\n\n    //开始写方法\n\n\n\n\n    //前序遍历的方法\n\n    public  void  preOrder(){\n\n        //先输出父节点\n        System.out.println(this);\n\n        //判断左节点是否为空\n        if(this.left!=null){\n\n            //继续前序遍历\n            this.left.preOrder();\n\n        }\n        //判断右节点是否为空\n        if(this.right!=null){\n\n            //继续前序遍历\n            this.right.preOrder();\n        }\n\n\n\n    }\n\n    //中序遍历的方法\n    public  void inOrder(){\n\n        //先判断左节点是否为空，不为空的话继续中序遍历\n\n        if(this.left!=null){\n\n            this.left.inOrder();\n\n        }\n        //输出父节点\n        System.out.println(this);\n\n        //判断右节点是否为空，不为空继续中序遍历\n        if (this.right!=null){\n\n            this.right.inOrder();\n        }\n\n    }\n\n    //后序遍历的方法\n\n    public  void postOrder(){\n\n        // 先判断左节点是否为空，不为空的话继续后序遍历\n        if(this.left!=null){\n\n            this.left.postOrder();\n        }\n\n        //判断右节点是否为空，不为空继续后序遍历\n        if (this.right!=null){\n\n            this.right.postOrder();\n        }\n\n        System.out.println(this);\n\n\n    }\n\n\n    //前序查找\n\n    public  HeroNode2 preOrderSearch(int no){\n        System.out.println(\"进入前序查找\");\n        if(this.no==no){\n\n            //如果当前进来的节点就是要找的，直接返回\n            return this;\n\n        }\n\n        //不满足的话就向左边递归\n\n\n        HeroNode2 resNode=null;   //这个值的设置就是为了纪录你进到一个节点里面是不是你要找的，如果找到了它的值就不是空了，不然就是null;\n        if(this.left!=null){\n\n            //如果向左递归找到了就返回,就没必要向右边递归了,所以要提前定义一个变量来接收\n            resNode=this.left.preOrderSearch(no);\n\n        }\n        if(resNode!=null){\n\n            return  resNode;\n        }\n        if(this.right!=null){\n\n            resNode=this.right.preOrderSearch(no);\n\n        }\n\n        //这个时候一定要返回了，无论resNode空还是不空,因为要有递归退出条件\n\n        return  resNode;\n\n\n\n    }\n\n    //中序遍历\n\n    public  HeroNode2 inOrderSearch(int no){\n\n        HeroNode2 resNode=null;//这个值的设置就是为了纪录你进到一个节点里面是不是你要找的，如果找到了它的值就不是空了，不然就是null;\n\n        //先向左边\n\n        if(this.left!=null){\n\n            resNode=this.left.inOrderSearch(no);\n        }\n        if(resNode!=null){\n\n            return  resNode;\n        }\n\n        System.out.println(\"进入中序查找\");\n        if(this.no==no){\n\n            return  this;\n\n        }\n\n        //否则就向右边\n\n        if(this.right!=null){\n\n            resNode=this.right.inOrderSearch(no);\n\n        }\n\n        return  resNode;\n\n\n    }\n\n\n\n    //后序查找\n\n    public  HeroNode2 postOrderSearch(int no){\n\n        //先左边\n        HeroNode2 resNode=null;//这个值的设置就是为了纪录你进到一个节点里面是不是你要找的，如果找到了它的值就不是空了，不然就是null;\n\n        //先向左边\n\n        if(this.left!=null){\n\n            resNode=this.left.postOrderSearch(no);\n        }\n        if(resNode!=null){\n\n            return  resNode;\n        }\n\n        if(this.right!=null){\n\n            resNode =this.right.postOrderSearch(no);\n\n        }\n        if(resNode!=null){\n\n            return  resNode;\n        }\n\n        System.out.println(\"进入后序查找\");\n        if(this.no==no){\n\n            return  this;\n        }\n\n        return  resNode;\n    }\n\n\n\n    //删除\n\n    public  void delNo(int no){\n\n\n     /*\n        1. 因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断 当前这个结点是不是需要删除结点\n\n        2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将 this.left = null; 并且就返回 (结束递归删除)\n\n        3. 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将 this.right= null ;并且就返回 (结束递归删除)\n\n        4. 如果第 2 和第 3 步没有删除结点，那么我们就需要向左子树进行递归删除\n\n        5. 如果第 4 步也没有删除结点，则应当向右子树进行递归删除.\n\n      */\n\n        if(this.left!=null &&this.left.no==no){\n\n            //说明该节点的左节点符合条件\n            this.left=null;\n            return;\n\n        }\n        if(this.right!=null &&this.right.no==no){\n\n            //说明该节点的右节点符合条件\n            this.right=null;\n            return;\n\n        }\n\n        //否则呢，就要递归向左寻找\n\n        if(this.left!=null){\n\n            this.left.delNo(no);\n        }\n\n        //递归向右寻找\n        if(this.right!=null){\n\n            this.right.delNo(no);\n        }\n\n\n    }\n\n\n\n\n\n\n\n    }\n\n\n\n\n\n","tags":["学习笔记"]},{"title":"数据结构-二叉树","url":"/2020/04/30/数据结构-二叉树/","content":"\n树结构的基础部分：\n<!-- more-->\n\n### 二叉树\n\n   为什么需要树这种数据结构:\n\n   1) 数组存储方式的分析 优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。 缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低\n\n   2) 链式存储方式的分析 优点：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好)。 缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历)\n\n   3) 树存储方式的分析 能提高数据存储，读取的效率, 比如利用 二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也 可以保证数据的插入，删除，修改的速度。\n\n   ### 二叉树的概念\n\n\n 树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树。\n\n\n 二叉树的子节点分为左节点和右节点\n\n\n \n \n 如果该二叉树的所有叶子节点都在最后一层，并且结点总数= 2^n -1 , n 为层数，则我们称为满二叉树 \n\n \n 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二 层的叶子节点在右边连续，我们称为完全二叉树\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/5ADA905F03254D9AB70540E6DEF07D64/94)\n\n\n### 二叉树遍历的说明\n\n1) 前序遍历: 先输出父节点，再遍历左子树和右子树 \n2) 中序遍历: 先遍历左子树，再输出父节点，再遍历右子树\n3) 后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/E7FB0B0B0FBE42C5A6E9CFA604F55FB7/97)\n\n\n\n### 二叉树-查找指定节点\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/9C7AAE52FAE44073927F1F338CAFF81F/99)\n\n\n###  二叉树-删除节点\n\n暂定要求：\n\n1) 如果删除的节点是叶子节点，则删除该节点 \n\n2) 如果删除的节点是非叶子节点，则删除该子树.\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/B2A7D0B30C9C4035B1EE0466EB8A81DD/101)\n\n\n\n\n---\n---\n全部代码如下:\n\n    public class BinaryTreeDemo {\n\n    //二叉树\n\n    //二叉树的遍历，分为前序遍历，中序遍历，后序遍历。\n\n    /*\n    * 前序遍历的话就是先输出父节点，再输出左节点，再输出右节点。\n    * 就是每进入一个节点，就先输出这个节点，然后再去判断左节点（先），再判断右节点（后），还是一样的操作，直到一个节点的方法执行完就一层一层回退.\n    *\n    * 从第一层开始（根节点），先输出根节点（1）,再判断该节点（1）的左节点（2）是否为空，不为空的话就进入到该节点（2）（意思就是操作该节点（2））\n    * 然后就输出(2)节点，再判断(2)的左节点是否为空，不为空就进入。\n    * 以此类推，每到一个节点（说明这个节点肯定不是空的）就先输出该节点，再做判断左和右节点是否为空。（先左边一直走完再到右边）\n    * 先递归判断左边，如果直到一个节点的左边是空的了，不能再走了，就回退，继续在上一个节点判断该节点的右节点。。。最后再一层一层回退。。。\n    * */\n\n    /*\n    中序遍历的话就是先输出左节点，再输出父节点，再输出右节点。\n\n     就是每进入一个节点，就先判断它的左节点是不是空（先），直到某一个节点的左节点为空了。那么这个左递归的代码就执行完了，就先输出该节点的值，然后在该\n     节点的基础上向右递归，直到某一个节点的右节点执行完了，就回退。。。\n\n    从第一层开始（根节点）（1），先判断根节点的左节点（2）是否为空， 不为空就进入该左节点（2），再判断（2）的左节点，一直到某一个\n    节点（n）的左节点为空了，就输出n节点，然后判断n节点的右节点是否为空，为空的话就回退到上一层，不为空就一直递归直到为空为止。\n     */\n\n    /*\n    后序遍历的话就是先输出左节点，再输出右节点，再输出父节点。\n    就是每进入一个节点，先判断左，右（递归下去），直到某一个节点的左右都为空了，就先输出该节点。然后一层层回退输出其他节点\n\n    从第一层开始（根节点）（1），先判断根节点的左节点（2）是否为空， 不为空就进入该左节点（2），再判断（2）的左节点，一直到某一个\n    节点（n）的左节点为空了，就判断n节点的右节点是否为空，为空的话就回退到上一层（m）,输出m，不为空就一直递归直到空，左右都判断完了都为空了就输出父节点,\n    然后一直回退。。。。\n     */\n\n\n    /*\n    前序查找：进入一个节点，先判断该节点是不是想要找的节点，如果是的话就直接返回，否则就判断左节点是否为空，如果不为空的话就进入该节点，\n    然后再判断该节点是不是要找的，是的话就返回，就这样一直到某一个节点的左节点为空了，并且还没找到，那么向右边的递归去找。。。。一直这样下去，再回退\n     */\n\n    /*\n    中序查找，开始进入一个节点（根节点），一直向左递归下去，定义一个变量来纪录看看找没找到，如果找到了就一直回退返回，\n    如果到某一个节点（n）左边再也走不了了还是没找到，那就比较这个n是不是，再去这个节点的右节点递归，然后再回退比较。\n\n     */\n    /*\n    后序查找，开始进入一个节点（根节点），一直向左递归下去，定义一个变量来纪录看看找没找到，如果找到了就一直回退返回，\n    如果到某一个节点（n）左边再也走不了了还是没找到，再去这个节点的右节点递归，那就比较这个n是不是，然后再回退比较。\n\n     */\n\n    /*\n    删除： 要求：\n\n    1) 如果删除的节点是叶子节点，则删除该节点\n\n    2) 如果删除的节点是非叶子节点，则删除该子树.\n\n    1. 因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断 当前这个结点是不是需要删除结点\n\n    2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将 this.left = null; 并且就返回 (结束递归删除)\n\n    3. 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将 this.right= null ;并且就返回 (结束递归删除)\n\n    4. 如果第 2 和第 3 步没有删除结点，那么我们就需要向左子树进行递归删除\n\n    5. 如果第 4 步也没有删除结点，则应当向右子树进行递归删除.\n\n     */\n\n\n\n     public static void main(String args[]) {\n\n\n\n         HeroNode root=new HeroNode(1,\"宋江\");\n         HeroNode node2=new HeroNode(2,\"吴用\");\n         HeroNode node3=new HeroNode(3,\"卢俊义\");\n         HeroNode node4=new HeroNode(4,\"林冲\");\n         HeroNode node5=new HeroNode(5,\"关胜\");\n\n         //手动创建二叉树\n         root.setLeft(node2);\n         root.setRight(node3);\n         node3.setLeft(node5);\n         node3.setRight(node4);\n\n         BinaryTree binaryTree=new BinaryTree(root);\n\n\n\n             //进行遍历\n    //             System.out.println(\"前序遍历\");\n    //             binaryTree.preOrder();\n    //\n    //\n    //             System.out.println(\"中序遍历\");\n    //             binaryTree.inOrder();\n    //\n    //             System.out.println(\"后序遍历\");\n    //             binaryTree.postOrder();\n\n\n           //进行查找\n\n    //         System.out.println(\"前序查找\");\n         binaryTree.preOrderSearch(5);\n\n         //System.out.println(\"中序查找\");\n        // binaryTree.inOrderSearch(5);\n\n    //         System.out.println(\"后序查找\");\n        // System.out.println(binaryTree.postOrderSearch(5));\n\n\n         System.out.println(\"删除前的前序遍历\");\n         binaryTree.preOrder();\n         binaryTree.delNo(3);\n         System.out.println(\"删除后的前序遍历\");\n         binaryTree.preOrder();\n\n\n\n     }\n\n\n\n    }\n\n    //先创建一个节点类\n\n    class HeroNode{\n\n    private int no;//编号值\n    private  String name;//名称\n    private  HeroNode left; //指向左节点\n    private  HeroNode right;//指向右节点\n\n\n    public HeroNode(int no, String name) {\n        this.no = no;\n        this.name = name;\n    }\n\n    public int getNo() {\n        return no;\n    }\n\n    public void setNo(int no) {\n        this.no = no;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public HeroNode getLeft() {\n        return left;\n    }\n\n    public void setLeft(HeroNode left) {\n        this.left = left;\n    }\n\n    public HeroNode getRight() {\n        return right;\n    }\n\n    public void setRight(HeroNode right) {\n        this.right = right;\n    }\n\n    @Override\n    public String toString() {\n        return \"HeroNode{\" +\n                \"no=\" + no +\n                \", name='\" + name + '\\'' +\n                '}';\n    }\n\n    //开始写方法\n\n    //前序遍历的方法\n\n    public  void  preOrder(){\n\n        //先输出父节点\n        System.out.println(this);\n\n        //判断左节点是否为空\n        if(this.left!=null){\n\n            //继续前序遍历\n            this.left.preOrder();\n\n        }\n        //判断右节点是否为空\n        if(this.right!=null){\n\n            //继续前序遍历\n            this.right.preOrder();\n        }\n\n\n\n    }\n\n    //中序遍历的方法\n    public  void inOrder(){\n\n        //先判断左节点是否为空，不为空的话继续中序遍历\n\n        if(this.left!=null){\n\n            this.left.inOrder();\n\n        }\n        //输出父节点\n        System.out.println(this);\n\n        //判断右节点是否为空，不为空继续中序遍历\n        if (this.right!=null){\n\n            this.right.inOrder();\n        }\n\n    }\n\n    //后序遍历的方法\n\n    public  void postOrder(){\n\n        // 先判断左节点是否为空，不为空的话继续后序遍历\n        if(this.left!=null){\n\n            this.left.postOrder();\n        }\n\n        //判断右节点是否为空，不为空继续后序遍历\n        if (this.right!=null){\n\n            this.right.postOrder();\n        }\n\n        System.out.println(this);\n\n\n    }\n\n\n    //前序查找\n\n    public  HeroNode preOrderSearch(int no){\n       System.out.println(\"进入前序查找\");\n        if(this.no==no){\n\n            //如果当前进来的节点就是要找的，直接返回\n            return this;\n\n        }\n\n        //不满足的话就向左边递归\n\n\n        HeroNode resNode=null;   //这个值的设置就是为了纪录你进到一个节点里面是不是你要找的，如果找到了它的值就不是空了，不然就是null;\n        if(this.left!=null){\n\n            //如果向左递归找到了就返回,就没必要向右边递归了,所以要提前定义一个变量来接收\n            resNode=this.left.preOrderSearch(no);\n\n        }\n        if(resNode!=null){\n\n            return  resNode;\n        }\n        if(this.right!=null){\n\n            resNode=this.right.preOrderSearch(no);\n\n        }\n\n        //这个时候一定要返回了，无论resNode空还是不空,因为要有递归退出条件\n\n        return  resNode;\n\n\n\n    }\n\n    //中序遍历\n\n    public  HeroNode inOrderSearch(int no){\n\n        HeroNode resNode=null;//这个值的设置就是为了纪录你进到一个节点里面是不是你要找的，如果找到了它的值就不是空了，不然就是null;\n\n        //先向左边\n\n        if(this.left!=null){\n\n            resNode=this.left.inOrderSearch(no);\n        }\n        if(resNode!=null){\n\n            return  resNode;\n        }\n\n        System.out.println(\"进入中序查找\");\n        if(this.no==no){\n\n            return  this;\n\n        }\n\n        //否则就向右边\n\n        if(this.right!=null){\n\n           resNode=this.right.inOrderSearch(no);\n\n        }\n\n        return  resNode;\n\n\n    }\n\n\n\n    //后序查找\n\n    public  HeroNode postOrderSearch(int no){\n\n        //先左边\n        HeroNode resNode=null;//这个值的设置就是为了纪录你进到一个节点里面是不是你要找的，如果找到了它的值就不是空了，不然就是null;\n\n        //先向左边\n\n        if(this.left!=null){\n\n            resNode=this.left.postOrderSearch(no);\n        }\n        if(resNode!=null){\n\n            return  resNode;\n        }\n\n        if(this.right!=null){\n\n            resNode =this.right.postOrderSearch(no);\n\n        }\n        if(resNode!=null){\n\n            return  resNode;\n        }\n\n        System.out.println(\"进入后序查找\");\n        if(this.no==no){\n\n            return  this;\n        }\n\n        return  resNode;\n    }\n\n\n\n    //删除\n\n    public  void delNo(int no){\n\n\n     /*\n        1. 因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断 当前这个结点是不是需要删除结点\n\n        2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将 this.left = null; 并且就返回 (结束递归删除)\n\n        3. 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将 this.right= null ;并且就返回 (结束递归删除)\n\n        4. 如果第 2 和第 3 步没有删除结点，那么我们就需要向左子树进行递归删除\n\n        5. 如果第 4 步也没有删除结点，则应当向右子树进行递归删除.\n\n      */\n\n     if(this.left!=null &&this.left.no==no){\n\n       //说明该节点的左节点符合条件\n       this.left=null;\n       return;\n\n     }\n     if(this.right!=null &&this.right.no==no){\n\n       //说明该节点的右节点符合条件\n       this.right=null;\n       return;\n\n     }\n\n     //否则呢，就要递归向左寻找\n\n        if(this.left!=null){\n\n            this.left.delNo(no);\n        }\n\n        //递归向右寻找\n        if(this.right!=null){\n\n            this.right.delNo(no);\n        }\n\n\n    }\n\n\n    }\n\n\n    //创建一个二叉树类\n\n    class  BinaryTree{\n\n    //需要一个根节点\n    private  HeroNode root;\n\n    public BinaryTree(HeroNode root) {\n        this.root = root;\n    }\n\n    public HeroNode getRoot() {\n        return root;\n    }\n\n    public void setRoot(HeroNode root) {\n        this.root = root;\n    }\n\n    //前序遍历\n    public  void preOrder(){\n\n        if(root!=null){\n\n            this.root.preOrder();\n        }\n        else{\n\n            System.out.println(\"二叉树为空不能遍历\");\n        }\n\n    }\n    //中序遍历\n    public  void inOrder(){\n\n        if(root!=null){\n\n            this.root.inOrder();\n        }\n        else{\n\n            System.out.println(\"二叉树为空不能遍历\");\n        }\n\n    }\n    //后序遍历\n    public  void postOrder(){\n\n        if(root!=null){\n\n            this.root.postOrder();\n        }\n        else{\n\n            System.out.println(\"二叉树为空不能遍历\");\n        }\n\n    }\n\n\n    //前序查找\n    public  HeroNode preOrderSearch(int no) {\n\n        if (root != null) {\n\n            return  root.preOrderSearch(no);\n        } else {\n            return null;\n        }\n    }\n    //中序查找\n    public  HeroNode inOrderSearch(int no){\n        if (root != null) {\n\n            return  root.inOrderSearch(no);\n        } else {\n            return null;\n        }\n    }\n    //后序查找\n    public  HeroNode postOrderSearch(int no){\n        if (root != null) {\n\n            return  root.postOrderSearch(no);\n        } else {\n            return null;\n        }\n    }\n\n\n    //删除\n\n    public  void delNo(int no){\n\n        if(root!=null){\n\n            if(root.getNo()==no){\n\n                root=null;\n\n            }\n\n            else{\n\n                root.delNo(no);\n\n            }\n\n\n        }\n\n        else {\n\n            System.out.println(\"二叉树为空，不能删除\");\n\n        }\n\n\n    }\n\n    }\n\n    \n\n    \n    ","tags":["学习笔记"]},{"title":"数据结构-哈希表","url":"/2020/04/25/数据结构-哈希表/","content":"\n哈希表(散列)..\n\n<!-- more-->\n\n### 哈希表(散列)-Google 上机题\n\n\n  1) 看一个实际需求，google 公司的一个上机题: \n  \n  2) 有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,住址..),当输入该员工的 id 时,要求查 找到该员工的 所有信息. \n  \n  3) 要求: 不使用数据库,尽量节省内存,速度越快越好=>哈希表(散列)\n\n  ### 哈希表的基本介绍\n\n  散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通 过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组 叫做散列表。\n\n  ![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/1DCC20A8E9964D9DA05CF24D25E24585/89)\n\n\n\n  google 公司的一个上机题:\n\n  有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,名字,住址..),当输入该员工的 id 时, 要求查找到该员工的 所有信息. 要求: \n  \n  1) 不使用数据库,,速度越快越好=>哈希表(散列) \n  \n  2) 添加时，保证按照 id 从低到高插入 [课后思考：如果 id 不是从低到高插入，但要求各条链表仍是从低到 高，怎么解决?] \n  \n  3) 使用链表来实现哈希表, 该链表不带表头[即: 链表的第一个结点就存放雇员信息] \n  \n  4) 思路分析并画出示意图\n\n  ![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/73A4253EDE0545EEB03BFF5183E56FDE/91)\n\n\n---\n---\n\n  代码如下：\n\n        public class HashTabDemo {\n\n    //哈希表\n\n    //哈希表的底层是一个数组，数组的每一个索引中存放着一张链表。\n    //通过散列函数找到添加数据在哪个索引，从而可以在该索引的链表中添加数据。\n\n    /*\n    题目：\n    有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,名字,住址..),\n    当输入该员工的 id 时, 要求查找到该员工的 所有信息. 要求: 1) 不使用数据库,,速度越快越好=>哈希表(散列)\n    2) 添加时，保证按照 id 从低到高插入 [课后思考：如果 id 不是从低到高插入，但要求各条链表仍是从低到 高,怎么解决?]\n    3) 使用链表来实现哈希表, 该链表不带表头[即: 链表的第一个结点就存放雇员信息]\n    */\n\n\n     public static void main(String args[]) {\n\n         HashTab hashTab=new HashTab(7);\n\n         //写一个菜单\n         Scanner  scanner=new Scanner(System.in);\n\n         String key=\"\";\n\n         while (true){\n\n\n             System.out.println(\"add 添加雇员\");\n             System.out.println(\"list 遍历雇员\");\n             System.out.println(\"getEmp 查看某个雇员\");\n             System.out.println(\"exit 退出程序\");\n             key=scanner.next();\n\n             switch (key){\n\n                 case \"add\":\n                     System.out.println(\"请输入雇员的id\");\n                     int empId=scanner.nextInt();\n                     System.out.println(\"请输入雇员的名字\");\n                     String empName=scanner.next();\n                     Emp emp=new Emp(empId,empName);\n                     hashTab.add(emp);\n                     break;\n\n\n                 case \"list\":\n                     hashTab.list();\n                     break;\n\n                 case \"getEmp\":\n\n                     System.out.println(\"请输入要查找雇员的id\");\n                     int empId2=scanner.nextInt();\n                     hashTab.getEmpById(empId2);\n                     break;\n\n                 case \"exit\":\n\n                     System.exit(0);\n             }\n\n         }\n\n\n     }\n\n    }\n\n    class  Emp{\n\n    //这是雇员类。因为链表的每一个节点存放的就是雇员\n\n    int id;  //雇员id\n    String name; //雇员姓名\n    Emp next; //next域，指向下一个雇员节点\n\n    public Emp(int id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n\n     }\n\n\n    class EmpLinkedList{\n\n    //链表类\n\n    private  Emp head; //雇员链表的头指针，这个链表没有头节点，头指针直接指向第一个节点，默认null\n\n    Emp empHead=new Emp(0,\"\"); //顺序添加插入的时候用到的头节点，适应有头节点的情况\n    //首先呢，要编写一些方法，因为真正操作哈希表是在哈希表类中进行的，所以先在链表类中定义这些方法，方便哈希表的调用\n\n\n    //遍历链表\n\n    public  void list(){\n\n\n        if(head==null){\n\n            //说明没有数据。\n            System.out.println(\"该链表没有数据\");\n            return;\n\n        }\n\n        //否则就需要一个辅助指针帮助遍历\n\n        Emp cur=head;//初始指向头指针\n\n        while (true){\n\n         System.out.println(\"雇员的id为\"+cur.id);\n\n\n            if(cur.next==null){\n\n                //说明到达最后了\n                break;\n\n            }\n\n            cur=cur.next;\n\n        }\n\n\n    /*\n        if(empHead.next==null){\n\n            //说明没有数据。\n            System.out.println(\"该链表没有数据\");\n            return;\n\n        }\n\n        //否则就需要一个辅助指针帮助遍历\n\n        Emp cur=empHead.next;//初始指向头指针\n\n        while (true){\n\n            System.out.println(\"雇员的id为\"+cur.id);\n\n\n            if(cur.next==null){\n\n                //说明到达最后了\n                break;\n\n            }\n\n            cur=cur.next;\n\n        }\n    */\n    }\n\n\n\n\n    public void  add (Emp emp){\n\n\n        //添加雇员\n\n        if(head==null){\n\n            //头指针指向为空,直接赋值给头指针\n\n            head=emp;\n            return;\n\n        }\n        //否则说明是有元素的\n\n        //那么就要用一个辅助指针来找到链表的最后一个元素,在最后插入(这里假设添加的顺序是id不重复从小到大按顺序添加)\n\n        Emp cur=head;\n        while (true){\n\n            //找到最后一个节点\n\n            if(cur.next==null){\n\n                cur.next=emp;\n                break;\n            }\n            cur=cur.next;\n\n        }\n\n        //循环结束后就已经添加进去了。\n        System.out.println(\"添加成功\");\n\n    }\n\n\n    //id不重复的按照顺序添加(这种情况是有头节点的)\n    public  void add2(Emp emp){\n\n     Emp temp=empHead;\n     boolean flag=false;\n     while (true){\n\n         if(temp.next==null){\n\n             //说明是初始就位空数据或者是遍历到最后了还是不满足中间插入的条件，那就只能在最后面插入了\n\n             break;\n         }\n         if(temp.next.id==emp.id){\n\n             //说明有重复元素\n             flag=true;\n             break;\n\n         }\n         if(temp.next.id>emp.id){\n\n             //当前的这个temp的下一个节点都比你传进来的元素的id大了，那么呢你这个元素就应该插在这里当前的temp和temp.next的中间\n             //当前这个temp肯定是比你这个元素的id值小了，不然它在上一次循环中就会被确定下来并退出了。\n             break;\n\n         }\n\n         temp=temp.next;\n\n     }\n\n     if(flag){\n\n         System.out.println(\"链表中已有重复元素，无法添加\");\n     }\n     else{\n\n         emp.next=temp.next;\n         temp.next=emp;\n    System.out.println(\"添加成功！\");\n     }\n\n\n    }\n\n    //没有头节点的按顺序添加\n    public  void add3(Emp emp){\n\n\n    //这是没有头节点的情况的,也是可以运行的\n\n     Emp cur=head;\n\n     if(head==null){\n\n         head=emp;\n\n     }\n     else {\n\n         boolean flag = false;\n         while (true) {\n\n             if (cur.next == null) {\n\n                 //说明是初始就位空数据或者是遍历到最后了还是不满足中间插入的条件，那就只能在最后面插入了\n\n                 break;\n             }\n             if (cur.next.id == emp.id) {\n\n                 //说明有重复元素\n                 flag = true;\n                 break;\n\n             }\n             if (cur.next.id > emp.id) {\n\n                 //当前的这个temp的下一个节点都比你传进来的元素的id大了，那么呢你这个元素就应该插在这里当前的temp和temp.next的中间\n                 //当前这个temp肯定是比你这个元素的id值小了，不然它在上一次循环中就会被确定下来并退出了。要是没有头节点的话，你的指针直接指向第一个元素\n                 //那么当你这个元素比传进来的元素小的话，你会\n                 break;\n\n             }\n\n             cur = cur.next;\n\n         }\n\n         if (flag) {\n\n             System.out.println(\"链表中已有重复元素，无法添加\");\n         } else {\n\n             emp.next = cur.next;\n             cur.next = emp;\n             System.out.println(\"添加成功！\");\n         }\n     }\n\n    }\n\n\n\n\n\n    //根据雇员id查询雇员信息\n\n    public  Emp getEmpById(int id){\n\n        //遍历链表，找到相应的id退出\n\n\n        if (head==null){\n\n\n            return null;\n        }\n\n\n        Emp cur=head;\n        while (true){\n            if(cur.id==id){\n\n                break;\n\n            }\n\n             if(cur.next==null){\n\n                 cur=cur.next;\n                 break;\n             }\n            cur=cur.next;\n\n\n        }\n\n        return  cur;\n\n\n\n\n    }\n\n\n    }\n\n\n    class  HashTab{\n\n    //哈希表类\n    private  EmpLinkedList[] empLinkedLists;  //链表数组\n\n    private  int size;// 链表数组的大小\n\n\n    public HashTab(int size) {\n\n        empLinkedLists=new EmpLinkedList[size]; //初始化链表数组，但是链表数组里面的每一个链表实体还没有初始化,\n\n                                                 // 链表数组里面的每一个索引的数据都是链表实体\n        for (int i=0;i<empLinkedLists.length;i++){\n\n            empLinkedLists[i]=new EmpLinkedList();\n\n        }\n        this.size = size;\n    }\n\n\n    public void  add(Emp emp){\n\n        //添加雇员。\n        //需要一个散列函数来指定应该在链表数组的哪一个位置\n\n        int hashNo= hashFunction(emp.id);\n\n        //添加\n        System.out.println(\"雇员即将被添加到第\"+(hashNo+1)+\"条链表\");\n        empLinkedLists[hashNo].add3(emp);\n\n\n\n    }\n\n\n    //散列\n    public  int hashFunction(int id){\n\n        return  id % size;\n\n    }\n\n\n    //遍历\n\n    public  void list(){\n\n        for(int i=0;i<empLinkedLists.length;i++){\n\n            System.out.println(\"当前链表为第\"+(i+1)+\"个\");\n            empLinkedLists[i].list();\n            System.out.println();\n\n        }\n\n    }\n\n\n    //根据id查询雇员\n\n    public  void getEmpById(int id){\n\n\n        int hashNo=hashFunction(id);\n\n\n        Emp empById = empLinkedLists[hashNo].getEmpById(id);\n\n        if(empById!=null){\n            System.out.println(\"已经找到了，当前雇员在\"+(hashNo+1)+\"条链表，id为\"+id);\n\n        }\n        else{\n\n            System.out.println(\"没有找到喔！\");\n        }\n\n\n    }\n    }    \n\n\n\n\n\n\n ","tags":["学习笔记"]},{"title":"数据结构-查找算法第二辑","url":"/2020/04/25/数据结构-查找算法第二辑/","content":"\n\n插值查找与斐波那契查找算法:\n\n\n<!-- more-->\n\n### 插值查找算法:\n\n 1) 插值查找原理介绍: 插值查找算法类似于二分查找，不同的是插值查找每次从自适应 mid 处开始查找。\n   \n 2) 将折半查找中的求 mid 索引的公式 , low 表示左边索引 left, high 表示右边索引 right. key 就是前面我们讲的 findVal。\n\n ![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/D90DE930AFF14D57993B74B2062B31E6/85)\n\n\n3) int mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]) ;/*插值索引*/ \n\n对应前面的代码公式： int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left])\n\n\n代码如下:\n\n    public class InsertSearch {\n\n    //插值查找（自适应mid）,提高效率\n\n    //公式：int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left])\n\n    static  int  index=0;\n     public static void main(String args[]) {\n\n         int [] arr={1,8, 10, 89, 1000, 1234};\n\n         int i=insertSearch(arr,0,arr.length-1,1);\n\n         System.out.println(\"索引位置在\"+i+\"找了\"+index+\"次\");\n     }\n\n     public static int insertSearch(int [] arr,int left,int right,int findVal){\n\n         index++;\n\n         if(left>right){\n\n             return -1;\n\n         }\n\n         int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);\n\n         if(arr[mid]<findVal){\n\n             return  insertSearch(arr,mid+1,right,findVal);\n\n         }\n         else if(arr[mid]<findVal){\n\n             return  insertSearch(arr,left,mid-1,findVal);\n         }\n\n         else {\n\n             return mid;\n\n         }\n\n\n\n\n\n\n     }\n\n    }\n\n\n\n---\n---\n\n\n### 斐波那契查找算法\n\n\n斐波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的两个相邻数 的比例，无限接近 黄金分割值 0.618\n\n\n\n斐波那契(黄金分割法)原理:\n\n斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid 不再是中间或插值得到，而是位 于黄金分割点附近，即 mid=low+F(k-1)-1（F 代表斐波那契数列），如下图所示\n\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/27CE3FAA80CB4481A3291A42FD424859/87)\n\n\n对 F(k-1)-1 的理解： \n\n1) 由斐波那契数列 F[k]=F[k-1]+F[k-2] 的性质，可以得到 （F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1 。该式说明： 只要顺序表的长度为 F[k]-1，则可以将该表分成长度为 F[k-1]-1 和 F[k-2]-1 的两段，即如上图所示。从而中间位置为 mid=low+F(k-1)-1\n\n\n2) 类似的，每一子段也可以用相同的方式分割 3) 但顺序表长度 n 不一定刚好等于 F[k]-1，所以需要将原来的顺序表长度 n 增加至 F[k]-1。这里的 k 值只要能使 得 F[k]-1 恰好大于或等于 n 即可，由以下代码得到,顺序表长度增加后，新增的位置（从 n+1 到 F[k]-1 位置）， 都赋为 n 位置的值即可。 \n\nwhile(n>fib(k)-1) \n\nk++;\n\n\n\n代码如下:\n\n\n     public class FibonacciSearch {\n\n    //斐波那契查找算法\n\n    //基本思路与思想：\n\n    /*\n     斐波那契数列  1 1 2 3 5 8 13 21 ...\n\n      数列的规律是 f(k)=f(k-1)+f(k-2)  (k表示第几个数据，规律从2这个数据开始。。)\n\n      所以可以推导出 f(k)-1=f(k-1)-1 + f(k-2)-1 +1\n\n      所以如果一个顺序表的长度为f(k)-1的话，那么这个顺序表就可以分为f(k-1)-1  ，mid(就是1) , f(k-2)-1 这三个部分，mid就是加在后面的1。\n\n       这里我们的顺序表是数组，索引从0开始。所以是从0到数组末端索引的长度为f(k)-1。\n      这个时候的mid就等于 left(最左指针)+f(k-1)-1\n\n      但是呢，顺序表的长度可能不一定等于 斐波那契数列中第k个数-1，所以，如果顺序表的长度不满足这个条件，就要定义一个数组，把长度扩为f(k)-1.\n\n      扩充的数据为原数组的最后一个数据\n\n      如果要找的数据在mid的左边，那么原来左边数据是从0到 f(k-1)-1,就要在这个长度的基础上继续寻找黄金分割点mid。\n\n      对比一下规律，原来 f(k)-1=f(k-1)-1 + f(k-2)-1 +1，那么现在就是 f(k-1)-1=f(k-1-1)-1 + f(k-1-2)-1 +  1 = f(k-2)-1 + f(k-3)-1 +1\n\n      所以 新的mid = left + f(k-2)-1,原来的mid是 left(最左指针)+f(k-1)-1，是不是k-1就行了。。\n\n      那么如果，\n\n      如果要找的数据在mid的右边，那么原来右边数据是从 原来的mid+1 到f(k-2)-1,就要在这个长度的基础上继续寻找黄金分割点mid。\n\n      对比一下规律，原来 f(k)-1=f(k-1)-1 + f(k-2)-1 +1，那么现在就是 f(k-2)-1=f(k-2-1)-1 + f(k-2-2)-1 +  1 = f(k-3)-1 + f(k-4)-1 +1\n\n      所以 新的mid = mid+1 + f(k-3)-1,原来的mid是 left(最左指针)+f(k-1)-1，是不是k-2就行了。。\n\n\n\n     */\n\n     public static void main(String args[]) {\n\n         int [] arr={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22};\n        System.out.println( fibonacciSearch(arr,0,arr.length-1,16));\n\n\n     }\n\n     public static int fibonacciSearch(int [] arr,int left,int right,int findVal){\n\n         //现在是寻找数列中的一个值，让第k个数据-1的值等于数组末端索引，就是找k。\n         //所以\n        int [] f=fib(arr);\n         int k=0;\n         while (right > f[k]-1){\n\n             //right是原数组的最后一个下标，如果right还是大于f[k]-1的说明k就要增加，直到在数列中找到一个k值，让f(k)-1>=right\n\n             k++;\n\n\n         }\n\n         //循环退出的时候说明k已经找到了，但是这个时候的f(k)-1不一定就是=right,所以要判断\n\n\n          //这个时候就需要一个新的数组了\n\n             //新数组默认是0来填充后面的\n             int [] temp= Arrays.copyOf(arr,f[k]-1+1);\n\n             //我们要把arr后面的数据用arr的最后一个数据来补充\n\n             for(int j=right+1;j<temp.length;j++){\n\n                 temp[j]=arr[right];\n\n             }\n\n\n\n    /*\n         //填充完了就要求mid值了\n\n\n         //来一个循环\n\n         while (left<=right){\n\n             int mid= left+f[k-1]-1;\n\n             if(temp[mid]>findVal){\n\n                 //就要去左边寻找黄金分割点\n\n                 right=mid-1;\n                 k-=1;\n\n             }\n\n             else if(temp[mid]<findVal){\n\n\n                 //右边寻找黄金分割点\n                 left=mid+1;\n                 k-=2;\n\n             }\n             else{\n\n                 //找到了，有可能这个mid的值是在原来数组扩展的后面的，所以要判断\n\n                 if(mid<right){\n\n                    return  mid;\n\n                 }\n\n                 else{\n\n                     return  right;\n\n                 }\n\n             }\n\n\n         }\n\n\n       return -1;\n\n    */\n\n        //递归实现\n\n        return fibonacciSearchRecursive(temp,left,right,k,f,findVal);\n\n     }\n\n\n\n\n\n     //定义一个生成斐波那契的数列\n\n    //首先你要有一个斐波那契数列,这样才能知道你这个顺序表的长度是数列中的k是多少，况且才能从数列中取得mid值\n\n    public static int [] fib(int [] arr){\n\n\n        int [] f = new int[arr.length * 2];\n\n        f[0]=1;\n        f[1]=1;\n        for (int i=2;i<f.length;i++){\n\n            f[i]=f[i-1]+f[i-2];\n\n        }\n      return  f;\n\n    }\n\n\n    //用递归实现。取代用while循环\n\n    public static  int fibonacciSearchRecursive(int [] temp,int left,int right,int k,int [] f,int findVal){\n\n\n         //做一些判断。//好让递归退出\n\n        if(temp.length==0||temp==null||findVal<temp[left]||findVal>temp[right]||left>right){\n\n            return  -1;\n        }\n\n        int mid= left+f[k-1]-1;\n\n        if(temp[mid]>findVal){\n\n            //就要去左边寻找黄金分割点\n\n           return fibonacciSearchRecursive(temp,left,mid-1,k-1,f,findVal);\n\n        }\n\n        else if(temp[mid]<findVal){\n\n\n            //右边寻找黄金分割点\n            return fibonacciSearchRecursive(temp,mid+1,right,k-2,f,findVal);\n        }\n        else{\n\n            //找到了，有可能这个mid的值是在原来数组扩展的后面的，所以要判断\n\n            if(mid<right){\n                return  mid;\n\n            }\n\n            else{\n                return  right;\n\n            }\n\n        }\n\n\n\n\n    }\n\n\n\n     }\n\n\n\n\n\n\n\n","tags":["学习笔记"]},{"title":"数据结构-查找算法第一辑","url":"/2020/04/25/数据结构-查找算法第一辑/","content":"\n查找算法：\n\n<!-- more-->\n\n  1) 顺序(线性)查找 \n  \n  2) 二分查找/折半查找\n\n\n  ### 线性（顺序）查找算法:\n\n  代码如下：\n\n\n       public class SeqSearch {\n\n\n    //顺序查找\n\n\n     public static void main(String args[]) {\n\n         int arr[]={1,3,5,7,9,2,4};\n         int i = seqSerach(arr, 90);\n         System.out.println(i);\n\n     }\n\n\n     public static   int seqSerach(int arr[],int findVal){\n\n\n         //遍历数组\n\n         for (int i=0;i<arr.length;i++){\n\n             if(arr[i]==findVal){\n\n                 return  i;\n             }\n\n\n         }\n         return  -1;\n\n     }\n\n    }\n\n\n\n\n\n---\n----\n### 二分查找\n\n    \n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/1226F4C9CF0448389E229175B04089D2/83)\n\n\n代码如下:\n\n      public class BinarySearch {\n\n\n     public static void main(String args[]) {\n\n         //二分查找(顺序表)\n\n         int [] arr={1,3,3,3,3,7,9,11,13};\n\n     // System.out.println( binarySearch(arr,0,arr.length-1,1));\n\n         ArrayList<Integer> arrayList = binarySearch2(arr, 0, arr.length - 1, 3);\n\n         System.out.println(arrayList);\n\n\n     }\n\n\n     //先写一个只能查到单个元素的索引的方法，重复元素的查不到\n     public static int  binarySearch(int [] arr,int left,int right,int findVal) {\n\n\n         //遍历数组\n         //既然是递归，那么就要有终止条件，找到了就返回这是一个，找不到的话也要设置一个条件\n         if (left > right) {\n\n             return -1;\n         }\n         int mid = (left + right) / 2;//中间的指针\n\n\n             if (findVal > arr[mid]) {\n\n                 //说明要寻找的值比中间值的指针大，那么就要向右边继续寻找，也就是向右递归。\n                 return binarySearch(arr, mid + 1, right, findVal);\n\n             } else if (findVal < arr[mid]) {\n\n                 //否则就是要寻找的值比中间值小，向左递归\n                 return binarySearch(arr, left, mid - 1, findVal);\n\n             } else {\n\n                 //否则就是恰好中间的值就是\n                 return mid;\n\n             }\n\n\n\n\n\n     }\n\n\n\n     //现在编写一个可以查询重复元素的索引的方法。用集合来接收\n\n    public static ArrayList<Integer> binarySearch2(int [] arr,int left,int right,int findVal){\n\n\n\n         if(left>right){\n\n           return new ArrayList<Integer>();\n         }\n\n         int mid=(left+right)/2;\n         if(findVal>arr[mid]){\n\n            return binarySearch2(arr,mid+1,right,findVal);\n\n         }\n         else if(findVal<arr[mid]){\n\n              return  binarySearch2(arr,left,mid-1,findVal);\n         }\n         else{\n\n            /*\n\n            这种方法可行的。\n            下面的没注释的也是可行的\n             //这个环节说明是到了找到到第一个元素的时候了，但是不要立即返回。\n             //如果这个时候left还没有等于right,就说明可能还有相同数据,继续寻找\n             ArrayList<Integer> arrayList=new ArrayList<>();\n\n             if(left==right){\n\n                 return  arrayList;\n             }\n             for(int i=0;i<arr.length;i++){\n\n                 if(arr[i]==arr[mid]){\n\n                     //就把数据放进集合中并返回\n                     arrayList.add(i);\n\n                 }\n\n             }\n           return   arrayList;\n\n             */\n\n            ArrayList<Integer> arrayList=new ArrayList<>();\n\n            int temp=mid-1;  //定义一个向左边扫描的指针\n\n             while (true){\n\n                 //说明不满足加入集合中的条件\n                 if(temp<0||arr[temp]!=findVal) {\n                     break;\n                 }\n                 //为什么这样设计呢，因为数组它是有序的，假如你的数据有重复的话，那么你的当前找到的数据的指针(进来else的指针)如果你的左边都没了\n                 // ，那么就没必要找了，因为根本不可能再有了，右边也是同样的道理\n                 arrayList.add(temp);\n                 temp--;\n\n             }\n\n             //这里是把刚进来else就找到的数据放进集合里\n             arrayList.add(mid);\n\n             temp =mid+1;\n             while (true){\n\n                 if(temp<0||arr[temp]!=findVal){\n\n                     break;\n                 }\n\n                 arrayList.add(temp);\n                 temp++;\n\n             }\n\n             return  arrayList;\n         }\n\n\n\n    }\n\n\n    }\n\n\n\n\n\n","tags":["学习笔记"]},{"title":"数据结构-排序算法小结","url":"/2020/04/25/数据结构-排序算法小结/","content":"\n常用排序算法总结和对比\n<!-- more-->\n### 一张排序算法的比较图\n\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/B0E35E2CFE874CC4B09FC1C8D25A47D5/81)\n\n\n### 相关术语解释\n\n1) 稳定：如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面； \n\n2) 不稳定：如果 a 原本在 b 的前面，而 a=b，排序之后 a 可能会出现在 b 的后面；\n\n 3) 内排序：所有排序操作都在内存中完成； \n \n 4) 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； \n \n 5) 时间复杂度： 一个算法执行所耗费的时间。\n \n  6) 空间复杂度：运行完一个程序所需内存的大小。 \n  \n  7) n: 数据规模 \n  \n  8) k: “桶”的个数 \n  \n  9) In-place: 不占用额外内存 \n  \n  10) Out-place: 占用额外内存\n\n\n\n","tags":["随笔"]},{"title":"数据结构-排序算法第三辑","url":"/2020/04/25/数据结构-排序算法第三辑/","content":"\n归并排序与基数排序：\n\n<!--more-->\n\n### 归并排序\n\n归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer） 策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案\"修 补\"在一起，即分而治之)。\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/3CD9BAC588A64D3C8CCFC1F75B863C4F/71)\n\n\n\n再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将 [4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤\n\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/859771A71D1C42CB902147AB122FE493/73)\n\n代码如下：（思路分析）\n\n\n    public class MergeSortDemo {\n\n    //归并排序\n\n     public static void main(String args[]) {\n\n\n\n         /*\n         基本思想和思路分析：\n\n\n         分：归并排序就是把一个数组的元素先分成两个部分，假设mid1= （0+arr.length-1）/2左边是从 0 到mid，右边是从mid+1到数组末尾，按照\n\n         该种方法，再将分为两个部分的数组元素，左边：（左边： mid2=(0+mid1)/2,0到mid2,右边mid2+1到mid1 ）,右边：同样道理...依此类推来分直到每一个部分的元素被分为单个元素。\n\n          比如 ： 84571362\n\n          8457  1362\n\n       84  57   13  62\n\n     8 4   5 7   1 3   6 2\n\n     治：先从最细分的开始合并，\n\n\n     分应该是一个递归的过程，就是细分到最细了就从栈的上往下合并，也就是从最细的到完整的。\n\n     单个元素的合并，哪几个单元素是之前被一个部分拆下来的，就把它们按照有序的方式合并成原来的部分。逐步合并成完整的，每一次合并都要把合并后的\n     序列放到一个新的数组中，最后合并完了再把这个中间数组拷贝到原数组。\n\n     比如：  48   57   13   26\n\n              4578   1236\n\n               12345678\n\n\n         */\n\n\n         int [] arr={ 8,4,5,7,1,3,6,2};\n         int [] temp=new int[arr.length];\n\n         System.out.println(\"前\"+ Arrays.toString(arr));\n         breakArr(arr,0,arr.length-1,temp);\n         System.out.println(\"后\"+Arrays.toString(arr));\n\n\n\n\n\n     }\n\n     //分解数组\n     public  static void breakArr(int [] arr,int left,int right,int [] temp){\n\n\n\n         //什么时候不再分解了\n         if(left<right){\n\n             int mid=(left+right)/2;\n             //向左递归分解\n             breakArr(arr,left,mid,temp);\n\n             //向右递归分解\n\n             breakArr(arr,mid+1,right,temp);\n\n             //栈顶进行合并，就是左递归一直到最后不能递归了，就执行分解操作，同样道理\n\n             merge(arr,temp,left,right);\n\n\n\n             //程序是这样执行的，首先从开始进来分解完左边，再去分解左边，再去分解左边，直到左边不能再被分解了就回退到上一级别（3）\n             // 的部分向右分解进入下一级别，右边分解完（分一次）就不能分解了，然后回退上一级别(也就是3)，3这个级别再执行合并。然后3这个级别\n             //都执行完了就回退到上一级别（2），2呢，就继续执行它的向右分解的代码，直到。。。。。执行回退到该级别，就进行合并..\n\n         }\n\n\n\n\n     }\n\n\n     //合并的方法\n     public  static void merge(int arr[],int [] temp,int left,int right){\n\n\n         //arr是原数组，temp是临时数组，left是左指针，就是最左边的索引，right是右指针，就是最右边的索引\n\n\n         int i=left;//i是会移动的，是左边的可移动指针，初始值为左边的索引\n         int mid=(left+right)/2;  //中间\n         int j=mid+1;//j是可移动的右边的指针，初始值为右边的索引\n         int t=0;//t是临时数组的索引\n\n\n         //合并的时候，比如拿最后一次合并来说，有两个有序的部分， 先拿左边的部分的第一个元素与右边的第一个元素相比，如果左边第一个元素比右边\n         //第一个元素小，那么就把左边第一个元素移到临时数组中，然后左边的元素移到下一个，继续和右边第一个元素比较，反之则把右边第一个元素移到临时数组,右边的\n         //元素右移，和左边第一个元素比较。。。就这样比下去，直到有一个部分的元素都比完了，就把另外一个部分的剩余的元素按照索引填进临时数组里。\n\n         while (i<=mid && j<=right){\n\n             if(arr[i]<=arr[j]){\n                 //左边的元素小于右边的\n                 temp[t]=arr[i];\n                 i++;\n                 t++;\n\n             }\n             else{\n\n                 //左边的元素大于右边的\n\n                 temp[t]=arr[j];\n                 j++;\n                 t++;\n\n             }\n\n         }\n\n         //循环结束，如果还有某个部分的元素剩余\n\n         //左边的元素有剩余\n         while (i<=mid){\n\n             temp[t]=arr[i];\n             i++;\n             t++;\n\n         }\n\n         //右边有元素剩余\n         while (j<=right){\n\n             temp[t]=arr[j];\n             j++;\n             t++;\n         }\n\n\n         //现在是把临时数组的元素拷贝到原数组\n\n         //每一次合并完就要拷贝进原数组。每一次的临时数组都会从0开始覆盖原数组，直到最后合并成有序的了，\n         // 就从0开始覆盖原数组，就完事了\n\n         int tempLeft=left; //从left开始。这样一个部分的左右两个部分合并才不会造成合并了左后进去原数组了，但是合并了右部分后进入原数组把左的覆盖掉。\n         t=0;\n         while (tempLeft<=right){\n\n             arr[tempLeft]=temp[t];\n\n             t++;\n             tempLeft++;\n\n         }\n\n\n\n\n\n\n     }\n\n\n\n    }\n\n---\n---\n\n### 基数排序\n\n\n直接上图：\n\n将数组 {53, 3, 542, 748, 14, 214} 使用基数排序, 进行升序排序\n\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/084D7A02753D41A2BEFA749E81DFB77D/75)\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/E0159661F5724F4E90600B74F8708563/77)\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/AC9A56C2FFC440DDBB2CBF6B437E7E49/79)\n\n\n代码实现（思路分析）:\n\n     public class RadixSort {\n\n    //基数排序\n\n    //基本思想与思路：\n\n\n    /*\n    定义10个桶，每一个桶是一个一维数组，\n    数组元素的最大位数是n（若n=3）\n    第一次把数组中的元素的个位数一一拿出来，是多少就放在相应下标的桶里。\n    放完后，就把桶中的数据取出按顺序取出来放在原数组里面。\n    清空桶的数据\n    第二次就把数组中的元素的10位数一一拿出来，是多少就放在相应下标的桶里\n    再把桶中的数据按顺序拿出来放在原数组。\n    清空桶的数据\n    第三次就把百位数拿出来。。。还是这样操作\n     */\n\n\n     public static void main(String args[]) {\n\n\n         int [] arr={53, 3, 542, 748, 14, 214};\n         //一步一步来。\n\n         //定义一个二维数组，bucket[10][?],为了防止栈溢出，?设为arr.length。\n\n         int [] [] bucket=new int [10][arr.length];\n         //从桶中拿数据的时候，你得知道每一个桶中有多少数据，这样才能把数据取出来放在数组里\n\n         //所以定义个一维数组来记录每一个桶中的数据  bucketElementCount[0],代表下标为0的桶的个数\n\n          int [] bucketElementCount=new int[10];\n          System.out.println(\"排序前\"+Arrays.toString(arr));\n          radixSort(arr,bucket,bucketElementCount);\n          System.out.println(\"排序后\"+Arrays.toString(arr));\n\n\n\n\n\n          /*\n         //第一步，取个位数。\n\n            System.out.println(\"前\"+ Arrays.toString(arr));\n\n\n         //遍历数组\n         for (int i=0;i<arr.length;i++){\n\n              int digits=arr[i]%10;  //取模10就可以得到其个位数\n             bucket[digits][bucketElementCount[digits]]=arr[i];\n             bucketElementCount[digits]++;\n         }\n\n          //遍历桶，放进原数组\n         int index=0;\n         for(int k=0;k<bucketElementCount.length;k++){\n\n             //可能存在有的桶没有值，所以要做判断\n             if(bucketElementCount[k]!=0){\n\n                 //说明下标为k的桶是有数据的\n\n                 for(int l=0;l<bucketElementCount[k];l++){\n\n                     //把桶的值放进数组里面\n                     arr[index]=bucket[k][l];\n                     index++;\n\n                 }\n\n             }\n\n\n\n\n         }\n\n\n\n      System.out.println(\"后\"+Arrays.toString(arr));\n\n    */\n\n     }\n\n     public static  void radixSort(int [] arr,int [][]bucket,int [] bucketElementCount ){\n\n         //整合一下\n\n         //判断数组中的最大位数的长度是多少，这样才可以知道需要进行多少次才到达有序。数组中最大数的位数为多少，就要进行多少次的排序操作\n\n         //定义一个最大值,假设是数组的第一个数组\n\n         int max= arr[0];\n         for(int i=0;i<arr.length;i++){\n\n             if(arr[i]>max){\n\n                 max=arr[i];\n             }\n\n         }\n\n         //求最大值的长度\n         int maxLength=(max+\"\").length();\n\n         int count=0;\n         //那就循环maxLength次\n\n         for(int i=0,n=1;i<maxLength;i++,n*=10){\n\n           count++;\n\n             //遍历数组\n             for (int j=0;j<arr.length;j++){\n\n                 int digits=arr[j]/n%10;  //分别取模10的倍数\n                 bucket[digits][bucketElementCount[digits]]=arr[j]; //bucket[每一轮的各个个/十/百...位数][记录每一轮中的各个个/十/百..位数的个数]\n                 bucketElementCount[digits]++;\n             }\n\n             //遍历桶，放进原数组\n             int index=0;\n             for(int k=0;k<bucketElementCount.length;k++){\n\n\n                 //bucketElementCount[?] ?表示某一轮的个/百/..位数，总体表示有多少个\n                 //可能存在有的桶没有值，所以要做判断,因为没有值的桶，bucketElementCount这个数组不会记录进去\n                 if(bucketElementCount[k]!=0){\n\n                     //说明下标为k的桶是有数据的,只要bucketElementCount[k]有数据。说明bucket[k][？]是有数据的 ，？就是bucketElementCount[k]\n\n                     for(int l=0;l<bucketElementCount[k];l++){\n\n                         //把桶的值放进数组里面\n                         arr[index]=bucket[k][l];\n                         index++;\n\n                     }\n\n                 }\n                 //清空桶的数据个数,防止对下一次造成影响\n\n                bucketElementCount[k]=0;  //!!!不然的话就会把原来的数据放进数组里面.\n\n\n\n             }\n    System.out.println(\"第\"+count+Arrays.toString(arr));\n\n         }\n\n\n\n\n     }\n\n\n    }\n\n\n\n\n基数排序的说明: \n\n1) 基数排序是对传统桶排序的扩展，速度很快。\n\n2) 基数排序是经典的空间换时间的方式，占用内存很大, 当对海量数据排序时，容易造成 OutOfMemoryError 。 \n\n3) 基数排序时稳定的。[注:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些 记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且 r[i]在 r[j]之前，而在排序后的序列中，r[i]仍在 r[j]之前， 则称这种排序算法是稳定的；否则称为不稳定的] \n\n4) 有负数的数组，我们一般不用基数排序来进行排序\n\n\n","tags":["学习笔记"]},{"title":"Java快速排序-图文并茂的解释","url":"/2020/04/24/Java快速排序-图文并茂的解释/","content":"\n快速排序图文并茂的详细解析：\n<!-- more-->\n### 高快省的排序算法\n有没有既不浪费空间又可以快一点的排序算法呢？那就是“快速排序”啦！光听这个名字是不是就觉得很高端呢。\n\n假设我们现在对“6 1 2 7 9 3 4 5 10 8”这个10个数进行排序。首先在这个序列中随便找一个数作为基准数（不要被这个名词吓到了，就是一个用来参照的数，待会你就知道它用来做啥的了）。为了方便，就让第一个数6作为基准数吧。接下来，需要将这个序列中所有比基准数大的数放在6的右边，比基准数小的数放在6的左边，类似下面这种排列：\n\n3 1 2 5 4 6 9 7 10 8\n\n在初始状态下，数字6在序列的第1位。我们的目标是将6挪到序列中间的某个位置，假设这个位置是k。现在就需要寻找这个k，并且以第k位为分界点，左边的数都小于等于6，右边的数都大于等于6。想一想，你有办法可以做到这点吗？\n\n### 排序算法显神威\n方法其实很简单：分别从初始序列“6 1 2 7 9 3 4 5 10 8”两端开始“探测”。先从右往左找一个小于6的数，再从左往右找一个大于6的数，然后交换他们。这里可以用两个变量i和j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵i”和“哨兵j”。刚开始的时候让哨兵i指向序列的最左边（即i=1），指向数字6。让哨兵j指向序列的最右边（即=10），指向数字。\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/78A800EC7D404E13A3CEDD2EA5C6031C/51)\n\n首先哨兵j开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵j先出动，这一点非常重要（请自己想一想为什么）。哨兵j一步一步地向左挪动（即j–），直到找到一个小于6的数停下来。接下来哨兵i再一步一步向右挪动（即i++），直到找到一个数大于6的数停下来。最后哨兵j停在了数字5面前，哨兵i停在了数字7面前。\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/2AE9F9B54BC54AEB8B155462EF013B97/54)\n\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/0E0EEEAB70ED4EEC895AFE066F27FC56/57)\n\n\n现在交换哨兵i和哨兵j所指向的元素的值。交换之后的序列如下：\n\n6 1 2 5 9 3 4 7 10 8\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/BC3EAE35BA13411C9485DBEA54A589A9/59)\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/40B21DF9B59A44B0A5C636D3440A23EA/61)\n\n到此，第一次交换结束。接下来开始哨兵j继续向左挪动（再友情提醒，每次必须是哨兵j先出发）。他发现了4（比基准数6要小，满足要求）之后停了下来。哨兵i也继续向右挪动的，他发现了9（比基准数6要大，满足要求）之后停了下来。此时再次进行交换，交换之后的序列如下：\n\n6 1 2 5 4 3 9 7 10 8\n\n第二次交换结束，“探测”继续。哨兵j继续向左挪动，他发现了3（比基准数6要小，满足要求）之后又停了下来。哨兵i继续向右移动，糟啦！此时哨兵i和哨兵j相遇了，哨兵i和哨兵j都走到3面前。说明此时“探测”结束。我们将基准数6和3进行交换。交换之后的序列如下：\n\n3 1 2 5 4 6 9 7 10 8\n\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/E5DA215317854F7FA158CD311D0B1622/63)\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/6973399280F04DA1B5F8A8912987757A/65)\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/C09001868A3A484AAC9A30C98E5C1EE3/67)\n\n\n到此第一轮“探测”真正结束。此时以基准数6为分界点，6左边的数都小于等于6，6右边的数都大于等于6。回顾一下刚才的过程，其实哨兵j的使命就是要找小于基准数的数，而哨兵i的使命就是要找大于基准数的数，直到i和j碰头为止。\n\nOK，解释完毕。现在基准数6已经归位，它正好处在序列的第6位。此时我们已经将原来的序列，以6为分界点拆分成了两个序列，左边的序列是“3 1 2 5 4”，右边的序列是“9 7 10 8”。接下来还需要分别处理这两个序列。因为6左边和右边的序列目前都还是很混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理6左边和右边的序列即可。现在先来处理6左边的序列现吧。\n\n左边的序列是“3 1 2 5 4”。请将这个序列以3为基准数进行调整，使得3左边的数都小于等于3，3右边的数都大于等于3。好了开始动笔吧\n\n如果你模拟的没有错，调整完毕之后的序列的顺序应该是：\n\n2 1 3 5 4\n\nOK，现在3已经归位。接下来需要处理3左边的序列“2 1”和右边的序列“5 4”。对序列“2 1”以2为基准数进行调整，处理完毕之后的序列为“1 2”，到此2已经归位。序列“1”只有一个数，也不需要进行任何处理。至此我们对序列“2 1”已全部处理完毕，得到序列是“1 2”。序列“5 4”的处理也仿照此方法，最后得到的序列如下：\n\n1 2 3 4 5 6 9 7 10 8\n\n对于序列“9 7 10 8”也模拟刚才的过程，直到不可拆分出新的子序列为止。最终将会得到这样的序列，如下\n\n1 2 3 4 5 6 7 8 9 10\n\n到此，排序完全结束。细心的同学可能已经发现，快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了。下面上个霸气的图来描述下整个算法的处理过程。\n\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/F18AFF9A4E554F858AA607540644DCD7/69)\n\n\n这是为什么呢？\n\n快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(N2)，它的平均时间复杂度为O(NlogN)。其实快速排序是基于一种叫做“二分”的思想。我们后面还会遇到“二分”思想，到时候再聊。先上代码，如下\n\n\n\n### 代码如下：\n\n\n    public class QuickSort {\n\n    #arr 需要排序的数组\n    #low 开始时最左边的索引=0\n    #high 开始时最右边的索引=arr.length-1\n    public static void quickSort(int[] arr,int low,int high){\n        int i,j,temp,t;\n        if(low>high){\n            return;\n        }\n        i=low;#左边哨兵的索引\n        j=high;#右边哨兵的索引\n        //temp就是基准位\n        temp = arr[low];#以最左边为  基准位\n\n        while (i<j) {\n            //先看右边，依次往左递减\n            #先从右往左找一个小于 基准位的数\n            #当右边的哨兵位置所在的数>基准位的数 时\n            #继续从右往左找（同时 j 索引-1）\n            #找到后会跳出 while循环\n            while (temp<=arr[j]&&i<j) {\n                j--;\n            }\n\n            //再看左边，依次往右递增\n            #步骤和上面类似\n            while (temp>=arr[i]&&i<j) {\n                i++;\n            }\n\n            //如果满足条件则交换\n            if (i<j) {\n\n    #z、y 都是临时参数，用于存放 左右哨兵 所在位置的数据\n                 z = arr[i];\n                 y = arr[j];\n\n                 # 左右哨兵 交换数据（互相持有对方的数据）\n                 arr[i] = y;\n                 arr[j] = z;\n\n            }\n\n        }\n\n      #这时 跳出了 “while (i<j) {}” 循环\n    #说明 i=j 左右在同一位置\n        //最后将基准为与i和j相等位置的数字交换\n         arr[low] = arr[i];#或 arr[low] = arr[j];\n         arr[i] = temp;#或 arr[j] = temp;\n\n\n    #i=j\n    #这时  左半数组<(i或j所在索引的数)<右半数组\n    #也就是说(i或j所在索引的数)已经确定排序位置， 所以就不用再排序了，\n    # 只要用相同的方法 分别处理  左右数组就可以了\n\n        //递归调用左半数组\n        quickSort(arr, low, j-1);\n        //递归调用右半数组\n        quickSort(arr, j+1, high);\n    }\n\n\n    public static void main(String[] args){\n        int[] arr = {10,7,2,4,7,62,3,4,2,1,8,9,19};\n        quickSort(arr, 0, arr.length-1);\n        for (int i = 0; i < arr.length; i++) {\n            System.out.println(arr[i]);\n        }\n    }\n    }\n\n\n### 输出\n\n\n    输出为\n1\n\n2\n\n2\n\n3\n\n4\n\n4\n\n7\n\n7\n\n8\n\n9\n\n10\n\n19\n\n62\n","tags":["随笔"]},{"title":"数据结构-排序算法第二辑","url":"/2020/04/24/数据结构-排序算法第二辑/","content":"\n希尔排序： 解决简单插入排序存在的问题\n<!-- more-->\n比如说当插入排序进行到一个待插入数比前面所有的数都小的时候，那么这个数就要比较移动很多次才能找到第一个位置进行插入，效率很低。\n\n### 希尔排序\n\n\n![示意图](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/B7C864B49285479AA918030C2568D610/47)\n\n\n代码如下（基本思路与思想）：\n\n\n    public class ShellSortDemo {\n\n    //希尔排序\n    /*\n    基本思路思想：就是对一个数组的长度一直除以2，每次相除后忽略掉余数后得到一个值，直到这个值是小于0，那么就结束。\n\n    每得到一个值，就说明在该值的情况下，增量为这个值,就可以把数组的元素分为这么多组（该值）。那么，分组后的数组的数据元素在每一个组中的\n\n    数据的间隔就是该值。那么就对每一个组中的元素进行排序，第一种方法是交换法，就是从每一个组的第一个元素开始（指针先指向第一元素），\n\n     如果第一个元素的下一个值比它小的话\n\n    就把这个小的值和第一个元素的值交换（假设从小到大排序），以此类推，比如说到了第二个值（指针指向第二值），那么就让它和它的下一个元素比较，比较\n\n    完后（交换或者不交换），注意，这个时候后，指针要往前一位，让第一个元素和第二个元素进行比较，因为，可能存在第二个元素和它的下一个元素比较完后，\n\n    换位了，然后换位的后第二个元素可能比第一个元素的值小（比如 5. 8 ,2）,8和2换位后，还要拿5和2比较并换位。\n\n    就这样，依次分组，分完组后的每一组都要进行这个操作,直到不能再分组为止\n    */\n\n\n    public static void main(String[] args) {\n\n        int[] arr = {8, 9, 1, 7, 2, 3, 5, 4, 6, 0,112,78,64,13,114};\n        int temp = 0;//交换的中间变量\n\n        //一步一步来，先把分到组后在组中的排序的逻辑给写出来。\n\n        //首先得话呢，我需要知道当前是分了多少组，因为我知道这个数据后，就知道了排序的时候该组数据的增量是多少，那么我就可以\n        //定位到两个相互比较的数据了\n\n        //以数组元素个数为例，首先是分成5组10/2=5\n\n        //为什么i要从5开始（也就是当前的分组数)呢?  因为我下一个for循环是要定位从每一个组中的第一个数据开始，\n\n        // 比如说分成了5组那么第一组是（0,5），最后一组是（4,9）\n\n        //找规律，是不是i开始是5，i最后是9，第一组的时候i-5=0,这样就是第一组中的一个数据的索引，\n        // 最后呢，i-5=4,也就是最后一个组中的第一个数据的索引\n\n        //再比如说分成了2组，那么第一组是（0,2,4,6,8），第二组（1,3,5,7,9），\n\n        // 那么这个时候，i从2开始，到9，第一组的第一个数据的索引是不是i-2等于0，i=3的时候i-2=1就\n        //定位到了第二组的第一个数据的索引。\n\n        // 那么，第一组的倒数第二个数据的索引（不用最后一个，因为知道倒数第二个也就知道了最后一个）的索引就是i=8的时候，\n\n        // i-2=6,第二组的倒数第二个数据的索引就是i=9的时候，i-2=7\n        /*\n        for(int i=5;i<arr.length;i++){\n\n\n            for(int j=i-5;j>=0;j-=5){\n\n                //指针要往前一位。也就是减少一个增量\n\n                //接下来就是交换数据\n\n                if(arr[j]>arr[j+5]){\n\n                    temp =arr[j];\n                    arr[j]=arr[j+5];\n                    arr[j+5]=temp;\n\n                }\n\n\n            }\n\n    */\n\n\n        //测试一下分成5组的时候\n\n        //  System.out.println(Arrays.toString(arr));\n\n        System.out.println(\"前\" + Arrays.toString(arr));\n        //shellSort(arr);\n\n        shellSortInsert(arr);\n        System.out.println(Arrays.toString(arr));\n\n    }\n\n\n    //分组内的排序，交换法\n    public static void shellSort(int[] arr) {\n\n        int temp = 0;\n        int count=0;\n\n        //整合一下，在最外层添加分组的变化的for循环\n\n        for (int grap = arr.length / 2; grap > 0; grap /= 2) {\n\n                   count++;\n            for (int i = grap; i < arr.length; i++) {\n\n\n                for (int j = i - grap; j >= 0; j -= grap) {\n\n                    //指针要往前一位。也就是减少一个增量\n\n                    //接下来就是交换数据\n\n                    if (arr[j] > arr[j + grap]) {\n\n                        temp = arr[j];\n                        arr[j] = arr[j + grap];\n                        arr[j + grap] = temp;\n\n                    }\n\n\n                }\n\n\n            }\n    System.out.println(\"第\"+count+\"轮的\"+Arrays.toString(arr));\n\n        }\n\n\n    }\n\n\n\n    //分组内插入法排序(效率更高)\n    public  static  void shellSortInsert(int [] arr){\n\n        //外层逐步分组的逻辑是不变的\n        for(int grap=arr.length/2; grap>0; grap/=2){\n\n\n            //既然你要使用插入法，那么就就要有插入点，和待插入值。\n\n            //当我来到分成了某个组的一个组的时候，那么我就要从该组的第二个数开始，作为待插入值，并且这个待插入值是要逐步变化的。所以我要\n            //在逐步分组的基础上用一个for循环来实现待出入值的变化，找一下规律，当你分成了5组的时候，\n            // 待插入值是不是从5这个索引开始。然后逐步递增直到9（9是最后一个值了嘛）\n            //假如分成2组的时候，那就是从2开始，待插入值直到9，所以，这个for循环就是从当前分成的组数开始，到arr.length。\n\n\n            for(int i=grap;i<arr.length;i++){\n\n\n                //这里就需要定义一下待插入值和插入点了吧\n\n                int j=i;//这是待插入值所在的索引。\n                int insertVal=arr[j];//记录一下当前的待插入值\n                int insertIndex=j-grap;//这是插入点。（比如说（0,5）这一组，那么0就是插入点。）\n\n                if(insertVal<arr[insertIndex]){\n\n                    //说明当前位置不合适，就要找插入位置。那么就要来个循环来找插入位置了。因为比较了插入点的值后，插入点还要前移。\n\n                    while (insertIndex>=0 && insertVal<arr[insertIndex]){\n\n                        //那么就要进行找位置插入。\n\n                        arr[insertIndex+grap]=arr[insertIndex]; //就是把这个插入点的值赋给待插入点的位置。\n\n                        insertIndex =insertIndex-grap; //比较前面的插入点。\n                    }\n\n                    //说明找到位置了，就把之前的待插入的值赋到插入点的位置上\n                    // (比如  101 119 34 ),34是待插入值，比较完119后就变成了 101 119 119，然后呢，插入点移到了101这个位置，34再跟101比，满足条件\n                    //就变成了 101 101 119\n                    //最后呢就把34这个值到当前插入点+grap上，因为它循环出来出来的时候是inserIndex已经 -grap 了，那你要在当前的insertIndex上插入的话就要加回来\n\n                    arr[insertIndex+grap]=insertVal;\n\n\n\n                }\n\n            }\n\n\n\n\n\n\n\n        }\n\n\n\n    }\n\n\n    }\n\n\n\n---\n---\n###  快速排序\n\n快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排 序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n\n\n\n\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/6E63137715E94633B5DE60C47744A6E6/49)\n\n\n\n\n代码如下（思想与思路）：\n\n\n    public class QuickSortDemo {\n\n    //快速排序法\n\n    /*\n    基本思想与思路。先从一个数组中的数据中选择一个基准值（随便哪个地方）然后定义一个左右指针，以基准值（这里选择中间的索引的值）\n\n    为界限，让左边的数据全都比基准值小，右边的数据比基准值大。所以需要在左边和右边来选择需要的数据。\n\n    左边：左边的指针从0开始,遇到比基准值大的数据或者相等就停下来，右边从数组末尾开始，遇到比基准值小的数据或相等就停下来。然后在两个都停下来后交换值，\n\n    交换完后，继续判断交换后的值，继续向前。直到左指针与右指针相等，这个时候它们指向的值就是基准值，这时候就不需要再继续。\n\n    然后就会形成以基准值为界，左边都是小于或等于基准值的数据，右边都是大于或者等于基准值的数据，\n\n    然后再左边执行一样的方法（递归）  右边同样直到整个序列都是有序的。\n\n    */\n\n\n     public static void main(String args[]) {\n\n      int arr []={-9,78, 0, 23, -567, 70, -1,  90, 450,1,4,7,5};\n\n    System.out.println(\"前\"+ Arrays.toString(arr));\n      //quickSort(arr,0,arr.length-1);\n         quickSort2(arr,0,arr.length-1);\n         System.out.println(\"后\"+ Arrays.toString(arr));\n\n     }\n\n\n\n     public   static  void quickSort(int [] arr,int left,int right){\n\n         //首先定义指针变量\n\n     //         int left=0;  //左界限\n       //         int right=arr.length-1; //右界限\n\n         int l=left;  //左指针\n         int r=right; //右指针\n         int pivot=arr[(left+right)/2];  //基准值\n         int temp=0; //交换的中间变量\n\n\n         while (l<r){\n\n             //因为l>=r的话就已经说明完成任务了。\n\n             //左边指针开始移动\n\n             while (arr[l]<pivot){\n\n                 //左边的数据大于等于基准值就不会满足条件，进不来循环,指针的值就不会变化，也就是停下来了\n                 //否则就要移动\n                 l+=1;\n\n             }\n\n\n             while (arr[r]>pivot){\n\n                 //同道理。右边有数据小于等于基准值就停下来\n                 r -=1;\n\n             }\n\n             //现在到这里就说明已经两边都停下来了\n             //准备交换，但是有过左右指针停下来是到了基准值这里的话就不需要交换了,这个时候l=r\n\n             //所以就退出\n             if(l>=r){\n\n                 break;\n             }\n\n             //不退出就要交换\n\n             temp=arr[l];  //左边的值\n             arr[l]=arr[r];  //右边的给左\n             arr[r]=temp;  //左的给右\n\n\n             //交换完了后可能会出现一种情况就是\n\n             //比如说， 这样一串数据  -567 78 0 23 -567 70 -1  90 450\n\n             //这里的第一次排序的基准值是-567，左边指针刚开始就停下来了，右边指针到基准值的位置才停下来。这个时候，把\n             //它们交换后，指针再次判断，还是停在这里，再继续交换。。。会形成死循环,所以如果交换完后左边的值等于基准值，就要\n             //r指针前移（--），如果交换完后右边的值等于基准值，就要左指针后移(++),这样就会避免死循环\n\n\n             //如果交换完只有一边的值等于基准值，其实指针右（左）移不移都没事，循环会帮你移，不过这样写的话可以省点判断，又可以\n             //在交换完两边的数据都等于基准值的时候避免死循环\n             if (arr[l]==pivot){\n\n                 r--;\n\n             }\n             if(arr[r]==pivot){\n\n                 l++;\n             }\n\n\n         }\n\n         //现在出来之后呢就是说明已经在基准值两边\n         //形成以基准值为界，左边都是小于或等于基准值的数据，右边都是大于或者等于基准值的数据，\n\n         //就要递归了\n\n         //但是循环出来后会存在l==r这样的情况，如果你直接递归的话，那么你把指针传进去的话就会照成还是跟之前的一样的\n         // （只不过是换了个基准值，你原来的老基准值还在里面，）所以你要把他们错开\n\n         if(l==r){\n\n             l++;\n             r--;\n\n         }\n\n         //开始递归\n\n         //如果你的左边界是大于等于右边界了就没必要左递归了\n\n         if(left<r){\n\n             quickSort(arr,left,r);\n         }\n\n         //右递归\n\n         //如果你的右边界是小于等于左边界了就没必要右递归了\n\n         if(right>l){\n\n             quickSort(arr,l,right);\n\n         }\n\n\n\n\n\n\n\n\n     }\n\n\n        //现在再写一个总是以左边的第一个数据为基准值的\n\n    public  static  void quickSort2(int [] arr,int left,int right){\n\n         //思路分析，\n      /*\n         总是以左边第一个数据为基准，左指针从0开始出发，（也就是从基准值所在位置）,右边从最后一个数据开始。\n\n         先从右边开始走，如果右指针找到比基准值小的就停下来。左边同样，如果遇到比基准值大的就停下来。都停下来了就交换数据\n\n         直到左右指针相等，这个时候呢，它们所指向的数据还不是当前基准值，需要把当前指向的值与数组第一个数据（基准值）交换，\n\n         这样的话基准值就回归到该在的位置了。\n\n         然后再从左边第一个数据选取为基准值，截取左边第一个到原来基准值的前一位（！！）进行同样的 操作。\n\n         右边也一样，截取原来的基准值的后一位作为基准值，直到数组末尾,进行同样的操作。\n\n\n\n     */\n\n       int temp=0;\n\n       int l=left;\n       int r=right;\n\n      int pivot=arr[left]; //左边第一个\n\n\n       while (l<r){\n\n\n       //必须从右边开始走，因为从左边开始走的话有可假如它停在了一个大于基准值的地方，这个右再走，假如它一直畅通无阻，直接来到这个值的地方，那么\n       //l=r了，就退出交换基准值，直接把大于基准值的这个值交换过去了。那么归位后，你的基准值左边就有一个比它大的值，这样就错啦！\n       //相反，如果你从右开始走，它就不会把指针指在比基准值大的地方，这样l=r的时候就不会有这种情况了\n       while (arr[r]>=pivot && l<r){\n\n           //这里要加判断条件l<r，因为我是当l=r的时候就要退出去交换基准值了，如果当\n           //如  -9,78, 0, 23, -567, 70, -1,  90, 450，当开始r走到-567时就停下来，l在78停下来，交换完后\n           //变成-9,-567, 0, 23, 78, 70, -1,  90, 450,这个时候循环继续，r先走，r来到了-567,l本来就是在-567\n           //这样当l判断条件arr[l]<=pivot（没加l<r）的时候是向前进的，这样他们就不能合在一起了！就会出错！\n           //所以为了防止l或者r越界，需要加上条件。\n\n           r--;\n\n       }\n\n       while (arr[l]<=pivot && l<r){\n\n           l++;\n\n       }\n\n       if(l>=r){\n\n           break;\n       }\n\n\n       temp=arr[l];\n       arr[l]=arr[r];\n       arr[r]=temp;\n\n\n\n\n       }\n\n       //循环退出的时候，l==r了，需要把当前指针指向的值与基准值交换，让基准值归位\n\n        int temp2=arr[l];\n\n          arr[l]=arr[left] ;\n\n          arr[left]=temp2;\n\n\n          //然后进行左右递归\n\n        if(left<r){\n\n            quickSort2(arr,left,r-1);\n        }\n\n        if(right>l){\n\n            quickSort2(arr,l+1,right);\n\n        }\n\n\n\n\n    }\n\n    }\n\n    \n\n\n\n\n","tags":["学习笔记"]},{"title":"数据结构-排序算法第一辑","url":"/2020/04/20/数据结构-排序算法第一辑/","content":"\n算法的时间复杂度：\n<!-- more-->\n一个算法中的语句执行次数称为语句频度或时间频度。记为 T(n)。\n\n可忽略：\n\n常数项  低次项  系数\n\nT(n)=Ｏ( f(n) )，称Ｏ( f(n) ) 为算法的渐进时间复杂度，简称时间复杂度\n\nf(n)是把该忽略的忽略完后的结果。\n\n\n常见的时间复杂度:\n\n1) 常数阶 O(1) \n2) 对数阶 O(log2n)(2是底数，n是真数) \n3) 线性阶 O(n) \n4) 线性对数阶 O(nlog2n)\n5) 平方阶 O(n^2) \n6) 立方阶 O(n^3) \n7) k 次方阶 O(n^k) \n8) 指数阶 O(2^n)\n\n\n\n\n算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n^2)＜Ο(n^3)＜ Ο(n^k) ＜ Ο(2^n)\n\n常见时间复杂度举例，为了你能更好的理解\n\n1) 常数阶 O(1) \n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/082F058EBE7B4CFCBD4142E16A243E04/28)\n\n---\n2) 对数阶 O(log2n)\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/5939249BA95C4608B4E959503842089B/31)\n\n---\n\n3) 线性阶 O(n) \n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/9AC69D12CFBC4357BE8918721C74F2EC/33)\n\n\n---\n\n4) 线性对数阶 O(nlog2n)\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/6D62B72572B64A58AF3AC7D576038BC9/36)\n\n---\n5) 平方阶 O(n^2) \n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/75F0F23A206F464B95F87ADB61680011/39)\n\n---\n\n6) 立方阶 O(n³)、K 次方阶 O(n^k) 说明：参考上面的 O(n²) 去理解就好了，O(n³)相当于三层 n 循环，其它的类似\n\n\n### 排序算法\n\n冒泡排序法：\n\n基本思想：\n\n通过对待排序序列从前向后（从下标较小的元素开始）,依次比较 相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。\n\n\n优化： 如果一趟比较下来没有进行过交换，就说明序列有序，因此要在 排序过程中设置一个标志 flag 判断元素是否进行过交换。从而减少不必要的比较。\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/69FEB93E9BC64F77984B20ECF5B841A4/41)\n\n\n代码如下:\n\n    public class BubbleDemo {\n\n    //冒泡排序法\n    //为了加深理解，我先把排序简化成一步一来，最后再提取。\n\n\n    static int k = 0;//记录一下趟数\n\n    public static void main(String args[]) {\n\n        //定义一个数组。\n\n    //          int [] arr={1,2,3,5,4};  //现在的数组长度是4\n    //          System.out.println(Arrays.toString(arr)+\"冒泡排序前的\");\n     //           bubble(arr);\n    //           System.out.println(Arrays.toString(arr)+\"冒泡排序后的\"+\"走了\"+k+\"趟\");\n\n        int[] arr = new int[80000];\n\n        for (int i = 0; i < 80000; i++) {\n\n            arr[i] = (int) (Math.random() * 80000);\n\n        }\n\n        Date date = new Date();\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd:hh:mm:ss\");\n        String s = simpleDateFormat.format(date);\n        System.out.println(\"排序前\" + s);\n        bubble(arr);\n        Date date1 = new Date();\n        String s1 = simpleDateFormat.format(date1);\n        System.out.println(\"排序后\" + s1);\n        //假设从小到大排序\n          /*\n          //先跑第一趟:\n\n\n             for(int i=0;i<arr.length-1;i++){\n\n\n                  //i代表指针，先从索引0开始,第一趟的指针范围是到数组的倒数第二个位置就可以了，\n                  // 因为当它指到到数组的倒数第二个位置的时候呢，会拿这个位置的值与数组最后值来比较\n\n                  if(arr[i]>arr[i+1]){\n\n                       //交换顺序\n                       int temp=arr[i];  //定义中间变量来存放该指针的值\n                       arr[i]=arr[i+1];\n                       arr[i+1]=temp;\n\n\n                  }\n\n             }\n             System.out.println(Arrays.toString(arr)+\"第一趟\");\n\n\n\n             //第二趟\n             //因为这个时候你的数组最后一位已经是数组中最大的那个数了，所以就不用操作它\n\n              for (int i=0;i<arr.length-1-1;i++){\n\n                   //指针的范围就是到数组的倒数第三个位置\n                   if(arr[i]>arr[i+1]){\n\n                        //交换顺序\n                        int temp=arr[i];  //定义中间变量来存放该指针的值\n                        arr[i]=arr[i+1];\n                        arr[i+1]=temp;\n\n\n                   }\n\n              }\n          System.out.println(Arrays.toString(arr)+\"第二趟\");\n\n\n\n             //第三趟\n\n\n              for (int i=0;i<arr.length-1-1-1;i++){\n\n                   //指针的范围就是到数组的倒数第四个位置\n                   if(arr[i]>arr[i+1]){\n\n                        //交换顺序\n                        int temp=arr[i];  //定义中间变量来存放该指针的值\n                        arr[i]=arr[i+1];\n                        arr[i+1]=temp;\n\n\n                   }\n\n              }\n          System.out.println(Arrays.toString(arr)+\"第三趟\");\n\n\n              //所以呢，数组中有n个要排序的元素，就要比较n-1趟(但是呢，有可能你在最后一趟的前某一趟已经是有序的了，那么就没必要在继续下一趟了)\n\n    */\n    }\n\n\n    //现在就抽取成for循环嵌套(也想着当你数组遍历的同时你又可以进行走一趟)\n\n    public static void bubble(int[] arr) {\n\n        //默认进不来交换数据的方法\n        boolean flag = false;\n        int temp;\n        for (int i = 1; i < arr.length; i++) {\n\n\n            for (int j = 0; j < arr.length - i; j++) {\n\n\n                //看到规律，第n趟的j<arr.length-?。?=n,所以呢，我的i从1开始，代表第一趟，i的范围就是1到（数组长度减-1）\n\n                //指针的范围就是到数组的倒数第四个位置\n\n                if (arr[j] > arr[j + 1]) {\n                    //能进来这里说明是一定会发生数据交换的，也就说明此时这一趟是需要进行排序的。\n                    //交换顺序\n                    flag = true;\n                    temp = arr[j];  //定义中间变量来存放该指针的值\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n\n\n                }\n\n\n            }\n            k++;\n            if (!flag) {\n                //进不来说明这一趟已经不用再交换数据位置了，那么它的下一趟就没必要了\n\n\n                break;\n\n            } else {\n\n                flag = false;\n            }\n\n\n        }\n\n\n    }\n\n\n    }\n\n\n\n\n\n\n\n### 选择排序\n\n基本思想:\n\n    第一次从 arr[0]~arr[n-1]中选取最小值， 与 arr[0]交换，第二次从 arr[1]~arr[n-1]中选取最小值，与 arr[1]交换，第三次从 arr[2]~arr[n-1]中选取最小值，与 arr[2] 交换，…，第 i 次从 arr[i-1]~arr[n-1]中选取最小值，与 arr[i-1]交换，…, 第 n-1 次从 arr[n-2]~arr[n-1]中选取最小值， 与 arr[n-2]交换，总共通过 n-1 次，得到一个按排序码从小到大排列的有序序列。\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/10BFB4F0A8814CAE8995BF123EAAE1EC/43)\n\n代码如下:\n\n    public class SelectDemo {\n\n    //选择排序法\n\n    //一步一步来\n\n    public static void main(String[] args) {\n\n\n        int [] arr={8,3,2,1,7,4,6,5};\n\n      selectSort(arr);\n    /*\n        //第一趟\n\n        int min=arr[0];  //假设当前要拿来作交换的索引的值作为最小，如果有更小的就再赋给min\n        int index=0;\n        //找到第一趟中的最小值\n\n        for(int i=0;i<arr.length;i++){\n\n            if(min>arr[i]){\n\n                //如果哪个小，就赋值给min\n\n                min=arr[i];\n                index=i;\n            }\n\n\n\n\n        }\n\n        //与arr[0]比较，条件符合进行交换\n        if(arr[0]>min){\n\n            arr[index]=arr[0];\n            arr[0]=min;\n\n\n\n\n        }\n\n        System.out.println(\"第一趟后的结果\"+ Arrays.toString(arr));\n\n\n\n        //第二趟\n\n        //找到第二趟中的最小值\n        int min=arr[1]\n        for(int i=1;i<arr.length;i++){\n\n            if(min>arr[i]){\n\n                //如果哪个小，就赋值给min\n\n                min=arr[i];\n                index=i;\n            }\n\n\n\n        }\n\n        //与arr[1]比较，条件符合进行交换\n        if(arr[1]>min){\n\n            arr[index]=arr[1];\n            arr[1]=min;\n\n\n\n\n        }\n\n        System.out.println(\"第二趟后的结果\"+ Arrays.toString(arr));\n        //第三趟\n\n        //找到第三趟中的最小值\n        int min=arr[2]\n        for(int i=2;i<arr.length;i++){\n\n            if(min>arr[i]){\n\n                //如果哪个小，就赋值给min\n\n                min=arr[i];\n                index=i;\n            }\n\n\n\n\n        }\n\n        //与arr[2]比较，条件符合进行交换\n        if(arr[2]>min){\n\n            arr[index]=arr[2];\n            arr[2]=min;\n\n\n\n\n        }\n\n        System.out.println(\"第三趟后的结果\"+ Arrays.toString(arr));\n\n    */\n    }\n\n\n\n    public static void selectSort(int [] arr){\n\n        int min=0;\n        int index=0;\n        //抽取一下\n\n        //第一层是确定你会有多少趟\n        for(int i=0;i<arr.length-1;i++){\n\n            min=arr[i];  //每一趟进来的时候就设置min值。用来作为该趟要逐步拿来比较来找出该趟中最小的值。遇到比min小的，就把值赋给min\n            //内层是在一个趟中你的具体的排序逻辑\n\n            //找到第i趟中的最小值\n            for(int j=i;j<arr.length;j++){\n\n                if(min >arr[j]){\n\n                    //如果哪个小，就赋值给min\n\n                    min=arr[j];\n                    index=j;\n                }\n\n\n\n            }\n\n            //与arr[i]比较，条件符合进行交换,//这里的判断是优化一下，因为你开始的时候已经把arr[i]的值赋给min了，\n            //它在寻找该趟最小值的时候，要么遇到比min小的就赋给min,要么就遇不到,min就不变，arr[i]一定是大于或者等于min的。\n            //arr[i]等于min的时候接没必要交换了。\n            if(arr[i]>min){\n\n                arr[index]=arr[i];\n                arr[i]=min;\n\n\n\n\n            }\n\n            System.out.println(\"第\"+(i+1)+\"趟后的结果\"+ Arrays.toString(arr));\n\n\n\n\n\n\n        }\n\n\n    }\n\n\n    }\n\n\n\n---\n\n### 简单插入排序\n\n基本思想： 把 n 个待排序的元素看成为一个有序表和一个无序表，开始时有 序表中只包含一个元素，无序表中包含有 n-1 个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。\n\n![](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/EABA9CDC134F450C80708A788DA05A34/45)\n\n\n代码如下（思路分析）:\n\n    public class InsertDemo {\n\n    //插入排序法\n\n    //一步一步来\n\n     public static void main(String args[]) {\n\n         int[] arr = {101, 34, 119, 1,118,6,73,87,45,63};\n\n         insertSort(arr);\n\n\n         //假设从小到大排\n\n         //初始的插入点是索引0 ,插入点是会变的，怎么变呢，循环变化，如假设5,8已经排好了，现在到了2，那么\n\n         //首先插入点是8这个位置，比较处理完后，插入点要向前移一位，\n\n         // 因为还要和5来比较（假如现在是 5,8排好了，然后碰到2了，它就要先和8比较，插在8的前面，再和5比较，插在5的前面）\n\n         //所以当我每次比较完后插入点就要变化，也就是自减，但是自减可能会自减到-1，这样就会越界，所以得加条件判断\n\n         //然后你比较的过程中，如果你比现在插入点的值大或者是等了，就没必要再比较了，因为前面的值已经被安排过了，这个时候你传进来的值肯定比前面大,\n         // 直接放在原位就可以了，否则的话\n\n         //就要把当前插入点+1的索引所在的数据和插入点索引所在数据交换，继续下一个插入点的比较\n\n\n         //第一趟\n         /*\n         int insertIndex = 0;  //插入点，当插入点到了数组元素的最后一个元素所在的索引时，就说明已经排好了\n         int insertVal = arr[1]; //就是待插入的值，就是没有被安排放到哪里的值,假设是第一趟\n\n\n         while (insertIndex>=0 && insertVal<arr[insertIndex]){\n\n             arr[1]=arr[insertIndex];  //先把当前插入点索引对应的值赋值给进来要找插的数据（即arr[2]这个位置）\n             arr[insertIndex]=insertVal; //这个时候arr[2]的值已经发生变化了，但是我上面有保存原来array[2]的值insertVal\n\n             insertIndex--;\n\n         }\n             //否则，当进来的时候不满足上面的条件或者上面的循环执行到某个插入点就不满循环条件了，就直接在原插入点后移的地方放\n             insertIndex++; //也就是在插入点的后一位赋值。\n             arr[insertIndex] = insertVal;\n             System.out.println(\"输出第一趟后的\" + Arrays.toString(arr));\n\n\n    */\n\n     }\n\n\n    public static void insertSort(int [] arr){\n\n\n    int insertIndex = 0;  //插入点，当插入点到了数组元素的最后一个元素所在的索引时，就说明已经排好了\n    int insertVal = 0; //就是待插入的值，就是没有被安排放到哪里的值,\n         //外层是插入点，当插入点到了数组元素的最后一个元素所在的索引时，就说明已经排好了，已经没什么可以插了\n           //刚开始插入排序的时候数组第一个数组被作为第一个放在有序表中的元素\n\n    //当内部循环的处理比较插入完成，程序结束了，那么你外层循环要给内层循环一个新的插入点，好让未被安排的下一位元素能够插进来\n         for (int i=0;i<arr.length-1;i++){\n\n             insertIndex = i;  //插入点，当插入点到了数组元素的最后一个元素所在的索引时，就说明已经排好了\n             insertVal = arr[i+1]; //就是待插入的值，就是没有被安排放到哪里的值,假设是第一趟\n\n\n             while (insertIndex>=0 && insertVal<arr[insertIndex]){\n\n                 arr[insertIndex+1]=arr[insertIndex];  //先把当前插入点索引对应的值赋值给进来要找插的数据（即arr[2]这个位置）\n                 arr[insertIndex]=insertVal; //这个时候arr[2]的值已经发生变化了，但是我上面有保存原来array[2]的值insertVal\n\n                 insertIndex--;\n\n             }\n             //否则，当进来的时候不满足上面的条件或者上面的循环执行到某个插入点就不满循环条件了，就直接在原插入点后移的地方放\n             //这里没必要写了，如果，当进来的时候不满足上面的条件或者上面的循环执行到某个插入点就不满循环条件了，直接不改变位置就行了，\n             //你上面的循环已经对需要改变位置的已经安排了\n               /*\n             if(insertIndex!=i) {\n                 insertIndex++; //也就是在插入点的后一位赋值。\n                 arr[insertIndex] = insertVal;\n             }\n             */\n\n             System.out.println(\"输出第\"+(i+1)+\"趟后的\" + Arrays.toString(arr));\n\n\n\n\n\n         }\n\n    }\n\n\n    }\n\n\n\n\n\n----\n\n\n\n","tags":["学习笔记"]},{"title":"数据结构-回溯法解决八皇后问题","url":"/2020/04/19/数据结构-回溯法解决八皇后问题/","content":"\n回溯法：\n<!-- more-->\n从问题的某一种可能出发, 搜索从这种情况出发所能达到的所有可能, 当这一条路走到” 尽头 “的时候, 再倒回出发点, 从另一个可能出发, 继续搜索. 这种不断” 回溯 “寻找解的方法, 称作” 回溯法 “。\n回溯是一种算法思想，可以用递归实现。\n\n### 八皇后问题\n\n\n八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于 1848 年提出：在 8×8 格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、 同一列或同一斜线上，问有多少种摆法(92)。\n\n---\n----\n\n代码说话:\n\n    public class Queue8 {\n\n\n    //八皇后问题\n\n    //8行8列的格子，每一行放一个皇后，任意两行的皇后不能在同一列，同一斜线\n\n    //回溯法\n    /*\n    思路：第一行第一列放上皇后，\n\n    接着第二行从第一列开始放皇后，判断皇后是否符合要求，直到找到合适的第一个位置。\n\n    其他行一样，每次放一个位置都会比较当前行和已经放过皇后的行。\n\n    实践证明，当你按照这样放的时候，到了某一行，你会发现\n\n    这一行找完所有位置没有一个是符合要求的，那么重点来了，\n\n    就回溯到前一行，从你放皇后的位置向右挪一位,找不到合适的位置就再挪，直到循环结束，还是不行就回到再前一行\n\n    直到找到你这行的第二个与下面的其他放过皇后的行不冲突的位置，\n\n    这一行找到位置了，\n\n    然后就进到到原来没有位置那一行（就是这一行的后一行），\n\n    再次寻找合适的位置。以此类推，当有一行的位置都不符合，就回到前一行，找到合适位置，\n\n    如果前一行还是没有合适的位置，就回到再前一行。。\n\n    假如找到位置了就递增一行。\n\n    就这样，一定会找到的一个正确的位置，当你的行数到达第8行并且已经成功后，会退出方法，\n\n    那么你第八行的剩下的循环位置会继续执行，\n\n    它会向右把皇后加一个位置，这个时候会发生冲突了，那么就持续推进，直到列数走完，\n\n    走完了就回退了前一行，前一行的皇后再向前移动，直到找到合适的位置再进入后一行，后一行再找位置，\n\n    再不行再回退，前一行不行就再回退，这样的话新一轮的解法求解又即将出来了。。。。。。\n\n    当最外层的循环执行完了，一切结束。\n    */\n\n\n    int max=8;//8个皇后\n    int [] arr=new int [max];\n    static  int count=0;\n    static  int judegCount=0;\n     public static void main(String args[]) {\n\n     //我们用一个数组来存放结果\n         //如：array[8]={0,1,2,3,4,5,6,7,8}\n           //代表8个皇后，arr[i]=val 代表第（i+1）个皇后放在地(i+1)行的第（var+1）列\n\n         Queue8 queue8=new Queue8();\n         queue8.check(0);\n         System.out.println(\"共\"+count+\"种解法\");\n         System.out.println(\"共\"+judegCount+\"种突出检测\");\n\n     }\n\n\n\n\n\n\n    //放皇后的方法\n    public void check(int n){\n\n\n         //加个条件，如果第8行加入皇后不发生冲突了，就停止进入第九行，因为没有！\n        if(n==max){\n\n\n            //这个时候就可以打印一种解法的结果了\n\n            print();\n            count++;\n            System.out.println();\n\n            return;\n\n        }\n\n         //n从0开始，代表行因为这样容易对结果数组的位置赋值\n\n        for(int i=0;i<max;i++){\n\n            //进来的皇后位置先是该行的第一列\n            //i是列\n            arr[n]=i;\n\n            //放完后与其他已经放了的行不冲突了就去下一行，否则就继续挪位置(列)\n            if(judge(n)){\n\n                //说明不冲突\n                //去下一行\n                check(n+1);\n\n\n            }\n\n\n        }\n\n    }\n\n    private void print() {\n\n         //打印每一种解法\n        for(int i=0;i<arr.length;i++){\n\n            System.out.printf(arr[i]+\" \");\n        }\n\n    }\n\n    private  boolean judge(int n){\n\n         //传进来的n指的是当前行，判断当前行的冲突是否与其他的几个n-1行是否冲突\n        //判断是否在同一列,是否在同一斜线\n\n    judegCount++;\n\n       for(int i=0;i<n;i++){\n\n           if(arr[i]==arr[n]||Math.abs(n-i)==Math.abs(arr[n]-arr[i])){\n\n               //说明是在同一斜线上\n\n               return  false;\n           }\n\n       }\n       return  true;\n\n    }\n\n\n    }","tags":["学习笔记"]},{"title":"数据结构-递归的学习以及解决小球迷宫问题","url":"/2020/04/19/数据结构-递归的学习以及解决小球迷宫问题/","content":"\n递归的重要原则\n\n<!-- more-->\n\n1) 执行一个方法时，就创建一个新的受保护的独立空间(栈空间) \n\n2) 方法的局部变量是独立的，不会相互影响, 比如 n 变量 \n\n3) 如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据. \n\n4) 递归必须向退出递归的条件逼近，否则就是无限递归,出现 StackOverflowError，死龟了:)\n\n 5) 当一个方法执行完毕，或者遇到 return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或 者返回时，该方法也就执行完毕\n\n\n ### 递归-小球迷宫问题\n\n ![迷宫问题](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/2444B00B8C1F40E8A38CF0E7A9148FF9/23)\n\n\n 代码说话：\n\n      public class Maze {\n\n    //小球迷宫问题\n\n    //思路分析：\n\n      /*\n      8行7列的二维数组 数组元素默认为0   四周都是墙，对墙的位置赋值为1。\n\n      给你一个起点，给你一个终点。\n\n      迷宫问题，从起点开始，假如不是终点的话，那就要移动，移动的话就得分策略（如每次移动都是下左上右）,当你移动到一个节点的\n\n      时候可能是新的节点，也可能是死节点。\n\n      所以设计代码的时候要判断当前的节点是不是终点，是的话直接返回。不是的话\n\n      那就判断是不是新的节点（因为墙，已走过的，或者已走过但走不通（3），是的话就赋值为2，也就是假设它能走通，然后就尝试按照策略递归走，即按照策略去下一个节点，下一个节点再按照策略尝试去下一个节点。\n\n      当有一个策略走通了就继续递归下去直到终点就就返回true，策略都不通就把该点置为3\n\n      每到一个可以走的节点(0)，置为2，假设可以走通。然后按照策略走，下左上右都不通了就返回false,置为3(它在按策略走的时候任何一个方向都不通)。\n      产生回溯：就是说比如你起点去调用方法去移动到下一个点，但是它按照策略走不通，返回了false，它就会返回给起点，这个时候，它就调用方法回到起点，尝试寻找新的解法。\n\n       */\n\n\n       public static void main(String args[]) {\n\n\n\n    int [] [] map=new int[8][7];\n\n    //赋墙：\n    //行不变，列在变\n      for(int i=0;i<7;i++){\n\n          map[0][i]=1;\n          map[7][i]=1;\n    }\n      //列不变，行变\n           for (int i=0;i<8;i++){\n           map[i][0]=1;\n           map[i][6]=1;\n           }\n           //第四行的第二列和第三列也是墙\n           map[3][1]=1;\n           map[3][2]=1;\n\n\n           //设置终点：\n         //  map[6][5]=2;\n           //输出一下试试\n\n           for(int i=0;i<8;i++){\n\n               for (int j=0;j<7;j++){\n\n                   System.out.printf(map[i][j]+\"  \");\n               }\n               System.out.println();\n           }\n\n           setWay(map,1,1);\n\n           System.out.println(\"....................\");\n\n           for(int i=0;i<8;i++){\n\n               for (int j=0;j<7;j++){\n\n                   System.out.printf(map[i][j]+\"  \");\n               }\n               System.out.println();\n           }\n\n       }\n\n\n       //移动节点的方法\n\n\n    //把地图传过去，递归传引用类型变量的话是共享的\n\n     //当前这个几点的位置(i,j)\n     public  static  boolean setWay(int[][] map,int i,int j){\n           //这个节点是不是终点\n           if(map[6][5]==2){\n\n               return true;\n           }\n           else{\n\n               //就要移动了，但是是否有移动的资格呢？\n               if(map[i][j]==0){\n\n                   //有资格\n                   //在没开始走之前给它赋为2，假设她是可以走通的,都走不通了再辅值为3\n                   map[i][j]=2;\n\n                   if(setWay(map, i+1, j)){\n\n                             return  true;            //下(向下移动) 碰到下面调用的各种路都不通了就返回来给第一个节点是false,\n                                                      // 尝试向下一个策略，否则下面调用在调用。。。不返回false，直到终点返回true就通了\n\n                   }\n                   else if(setWay(map,i,j+1)){\n\n                       return  true;   //右\n\n                   }\n                   else if(setWay(map, i-1, j)){\n                       return  true;//上\n                   }\n\n                   else if(setWay(map, i, j-1)){\n\n                       return  true;//左\n                   }\n\n                   else {\n\n                       //都走不通，返回false\n                       map[i][j]=3;\n                       return  false;\n\n                   }\n\n\n\n\n\n\n               }\n               else{\n\n                   //说明这个节点是 1或2或3，为什么是2也不能移动呢，因为你要是又回到2的话就代表你回溯了，而我在\n                   //2这个节点已经设置各种策略去寻找它的路了，你现在又来？没用。它不像八皇后问题，回溯回来的时候还有选择的余地，你现在\n                   //这个迷宫问题回来的时候已经没有选择的余地，你要做的我已经做过了。\n                 return  false;\n               }\n\n\n\n           }\n\n\n\n\n     }\n\n\n\n\n    }\n\n\n\n","tags":["学习笔记"]},{"title":"数据结构-栈的基本实现与应用","url":"/2020/04/19/数据结构-栈的基本实现与应用/","content":"\n栈的基本实现(先进后出)\n<!--more-->\n### 数组模拟栈\n\n代码如下（思路分析再里面）：\n\n    class ArrayStack{\n\n    int [] stack;//定义一个int数组\n    int top=-1; //定义一个栈顶指针，默认-1\n    int maxSize; //栈的大小\n\n    public ArrayStack(int maxSize) {\n\n        this.maxSize = maxSize;\n        stack=new int[maxSize];\n    }\n\n    //栈满\n    public  boolean isFull(){\n\n        return top==maxSize-1;\n\n    }\n    //栈空\n    public  boolean isEmpty(){\n\n        return top==-1;\n\n    }\n\n    //进栈\n\n    public  void push(int value){\n\n        if (isFull()){\n\n            System.out.println(\"栈满无法进入!\");\n            return;\n        }\n        top++;\n        stack[top]=value;\n        System.out.println(\"进栈成功了\");\n\n\n\n\n    }\n    //出栈\n\n    public  int pop(){\n\n        if(isEmpty()){\n            System.out.println(\"栈空无法出栈！\");\n\n        }\n        int value=stack[top];\n        top--;\n        return value;\n\n    }\n\n    //遍历栈\n\n    public  void list(){\n\n\n        if(isEmpty()){\n\n            System.out.println(\"栈空无法遍历!\");\n\n        }\n\n        //数组从末端往前开始遍历\n        int a=0;\n        for(int i=top;i>=0;i--){\n\n            a++;\n            System.out.println(\"第\"+a+\"个遍历出的数据是:\"+stack[i]);\n\n        }\n\n\n    }\n    \n\n    }\n\n\n\n### 单链表模拟栈\n\n代码如下：\n    \n    class  SingleLinkedListStack{\n\n\n    //固定头\n    Node head=new Node(0);\n\n\n    //单链表栈\n\n    //判断栈空\n    public  boolean isEmpty(){\n\n        return  head.getNext()==null;\n\n\n    }\n\n    //进栈\n\n    public  void push(Node node){\n\n        //因为进栈的话新进来的数据要总是插在h头节点的最前面。\n        // 如果原来有值得话就得进行连接，如果链表为空的话直接插入即可\n\n        if(isEmpty()){\n\n            head.setNext(node);\n\n        }\n        else {\n            //先连接原来头节点的下一个节点\n            node.setNext(head.getNext());\n            //再用头节点连接新节点\n            head.setNext(node);\n        }\n    }\n\n    //出栈\n\n    public  int pop(){\n\n        if(isEmpty()){\n\n            System.out.println(\"栈空无法出栈！\");\n\n        }\n        else{\n\n            //后进来的总是先出去\n\n            int value=head.getNext().getVal();\n            //头节点指向头节点的下一个的下一个\n            head.setNext(head.getNext().getNext());\n            return value;\n\n        }\n        return  -1;\n\n    }\n\n    //遍历栈\n    public  void list(){\n\n        //直接从头到尾进行遍历就行了，因为你添加的时候就是新添加的放最前面了\n\n        if(isEmpty()){\n\n            System.out.println(\"栈空无法遍历!\");\n        }\n        Node temp=head.getNext();\n        int a=0;\n        while (true){\n\n            if(temp==null){\n\n                break;\n            }\n            a++;\n            System.out.println(\"第\"+a+\"个出来的数据是\"+temp.getVal());\n            temp=temp.getNext();\n\n        }\n\n    }\n\n\n\n\n    }\n\n    class  Node{\n\n    private  int val;\n    private Node next;\n\n    public Node(int val) {\n        this.val = val;\n    }\n\n    public int getVal() {\n        return val;\n    }\n\n    public void setVal(int val) {\n        this.val = val;\n    }\n\n    public Node getNext() {\n        return next;\n    }\n\n    public void setNext(Node next) {\n        this.next = next;\n    }\n\n    @Override\n    public String toString() {\n        return \"Node{\" +\n                \"val=\" + val +\n                '}';\n    }\n    }\n\n\n\n----\n----\n\n### 栈的应用--实现综合计算器（中缀表达式）\n\n比如说：7*6+2-1*9直接输入表达式，计算结果。\n\n![思路图解](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/FDFAE139A5734A168A77701B34E8F102/21)\n\n\n代码如下：\n\n    public class Calculator {\n\n    //实现中缀表达式的计算\n\n\n     public static void main(String args[]) {\n\n         String expression=\"7*2*2-5+1-5+3-5\";\n\n         //需要创建两个栈，一个用来存放数字，一个用来存放运算符号\n\n         //数字栈\n         ArrayCalculatorStack stackNum=new ArrayCalculatorStack(10);\n\n         //符号栈\n         ArrayCalculatorStack  stackOper=new ArrayCalculatorStack(10);\n\n         //定义一些变量\n\n         int index=0;//索引，帮助遍历这个表达式字符串\n         int num1=0;//数字栈弹出的栈顶元素\n         int num2=0;//数字栈弹出的次栈顶元素\n         char c=' ';//从表达式解析的\n         char oper=' ';\n         int res=0;//计算的值\n\n         //现在开始解析表达式字符串\n\n         //有可能是多位数，如果每解析到一个字符就把它操作栈中的话会造成计算结果错误\n\n         String keepNum=\"\"; //多位数字拼接用的。因为字符串拼接字符就自动转成字符串，可以再把字符串转成int\n\n         //循环操作\n         while (true) {\n\n\n             c = expression.substring(index, index + 1).charAt(0);\n\n             //首先判断字符是否是运算符\n\n             if (stackOper.isOperator(c)) {\n\n                 //是运算符\n\n                 //接着判断符号栈中是否为空\n                 if (stackOper.isEmpty()) {\n\n                     //是空\n                     //直接进栈\n                     stackOper.push(c);\n                 } else {\n\n                     //不为空\n                     //不为空。判断当前运算符的优先级，大于原来符号栈中的优先级就直接放进去,小于或者等于就要\n                     //在数字栈中弹出两个元素，从符号栈中弹出栈顶符号,进行计算。再把该运算符放进栈中。\n                     if(stackOper.priorityOperator(c)>stackOper.priorityOperator(stackOper.showTopOperator())){\n\n                         //当前运算符的优先级，大于原来符号栈中的优先级就直接放进去\n                         stackOper.push(c);\n\n\n                     }\n                     else {\n                         //当前运算符的优先级，\n                         //小于或者等于就要在数字栈中弹出两个元素，从符号栈中弹出栈顶符号,进行计算。再把该运算符放进栈中。以及把计算的值压入数字栈\n\n                          num1=stackNum.pop();\n                          num2=stackNum.pop();\n                          oper=(char) stackOper.pop();\n                          res = stackOper.calculator(num1, num2, oper);\n                          stackNum.push(res);\n                          stackOper.push(c);\n\n                     }\n\n\n                 }\n\n             } else {\n\n                 //是数字\n                 //判断是否是最后一位，如果是的话直接入栈\n\n                 keepNum += c;\n\n                 if(index==expression.length()-1){\n\n                     //直接压数字栈\n                     stackNum.push(Integer.parseInt(keepNum));\n\n                 }\n                 else {\n\n                     //判断这个数字的下一位是不是运算符，如果是的话直接入栈，并清空keepNum\n\n                     if (stackOper.isOperator(expression.substring(index + 1, index + 2).charAt(0))) {\n\n                         //说明是不是多位数\n                         //直接压数字栈\n                         stackNum.push(Integer.parseInt(keepNum));\n                         keepNum = \"\";\n\n                     }\n                 }\n\n             }\n\n             //循环结束条件\n             index++;\n\n             if(index >=expression.length()){\n\n                 //说明到表达式的末尾了\n                 break;\n             }\n\n         }\n\n         //当循环结束的时候，符号栈和数字栈可能还存在数字和运算符，就要进行弹栈计算，这个时候的数值是可以直接弹出来算的\n\n\n\n             //我们以符号栈来做参照\n             //符号栈空了就说明数字栈中的值一定是最后的计算值了\n             //否则就要进行弹栈计算\n             while (true) {\n                 if(stackOper.isEmpty()){\n\n                     res=stackNum.pop();\n                     break;\n                 }\n                 num1 = stackNum.pop();\n                 num2 = stackNum.pop();\n                  oper = (char) stackOper.pop();\n                 res = stackOper.calculator(num1, num2, oper);\n                 stackNum.push(res);\n\n             }\n\n         System.out.println(\"最终的计算值是\"+res);\n\n     }\n\n\n\n\n    }\n\n    //创建一个数组栈，出了出栈入栈等方法，还要扩展判断是否是运算符，判断运算符的优先级，查看栈的栈顶元素值,中间计算方法\n\n    class ArrayCalculatorStack{\n\n    int [] stack;//定义一个int数组\n    int top=-1; //定义一个栈顶指针，默认-1\n    int maxSize; //栈的大小\n\n    public ArrayCalculatorStack(int maxSize) {\n\n        this.maxSize = maxSize;\n        stack=new int[maxSize];\n    }\n\n    //栈满\n    public  boolean isFull(){\n\n        return top==maxSize-1;\n\n    }\n    //栈空\n    public  boolean isEmpty(){\n\n        return top==-1;\n\n    }\n\n    //进栈\n\n    public  void push(int value){\n\n        if (isFull()){\n\n            System.out.println(\"栈满无法进入!\");\n            return;\n        }\n        top++;\n        stack[top]=value;\n        System.out.println(\"进栈成功了\");\n\n\n\n\n    }\n    //出栈\n\n    public  int pop(){\n\n        if(isEmpty()){\n            System.out.println(\"栈空无法出栈！\");\n\n        }\n        int value=stack[top];\n        top--;\n        return value;\n\n    }\n\n    //遍历栈\n\n    public  void list(){\n\n\n        if(isEmpty()){\n\n            System.out.println(\"栈空无法遍历!\");\n\n        }\n\n        //数组从末端往前开始遍历\n        int a=0;\n        for(int i=top;i>=0;i--){\n\n            a++;\n            System.out.println(\"第\"+a+\"个遍历出的数据是:\"+stack[i]);\n\n        }\n\n\n    }\n\n\n    //判断入栈的数据是否是运算符\n    public boolean isOperator(char val){\n\n        //这里限定运算符是加减乘除\n        return val=='+'||val=='-'||val=='*'||val=='/';\n\n\n    }\n\n    //判断运算符的优先级\n\n    public  int priorityOperator(char val){\n\n        if(val=='*'||val=='/'){\n\n            return  1;\n\n        }\n        else if (val=='+'||val=='-'){\n            return  0;\n\n        }\n        else{\n\n            return -1;\n        }\n\n\n    }\n\n    //查看栈顶的元素值(这是给符号栈用的，数字栈不用)\n    public char showTopOperator(){\n\n        return  (char) stack[top];\n\n    }\n\n    public  int calculator(int num1,int num2,char oper){\n\n        //注意：中间计算的时候使用次数字栈栈顶元素在前去（+ - * /）数字栈顶元素\n\n        //判断输入的运算符类型\n        int res=0;\n        if(oper=='*'){\n\n             res=num2*num1;\n\n        }\n        else  if(oper=='/'){\n\n             res=num2/num1;\n        }\n        else if(oper=='+'){\n\n             res=num2+num1;\n\n        }\n        else  if(oper=='-'){\n             res=num2-num1;\n\n        }\n        else{\n            System.out.println(\"参数不合法\");\n\n\n        }\n\n\n    return res;\n\n    }\n\n\n\n    }\n\n\n\n\n### 逆波兰计算器\n\n输入一个后缀表达式，计算其结果\n\n例如: (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下: \n1．从左至右扫描，将 3 和 4 压入堆栈； \n\n2．遇到+运算符，因此弹出 4 和 3（4 为栈顶元素，3 为次顶元素），计算出 3+4 的值，得 7，再将 7 入栈； \n\n3．将 5 入栈；\n\n4．接下来是×运算符，因此弹出 5 和 7，计算出 7×5=35，将 35 入栈； \n\n5．将 6 入栈； \n\n6．最后是-运算符，计算出 35-6 的值，即 29，由此得出最终结果\n\n\n### 中缀表达式转后缀表达式\n\n\n后缀表达式适合计算式进行运算，但是人却不太容易写出来，尤其是表达式很长的情况下，因此在开发 中，我们需要将 中缀表达式转成后缀表达式。\n\n\n代码说话（步骤与思路）：\n\n    public class PolandNotation {\n\n    //实现逆波兰表达式计算器\n\n\n     public static void main(String args[]) {\n\n         String suffixExpression=\"4 5 * 8 - 60 + 8 2 / +\"; //后缀表达式\n\n         PolandNotation polandNotation=new PolandNotation();\n\n       // polandNotation.calculator(suffixExpression);\n         String expression = \"12+((20+3)*4)-5\";//注意表达式\n         List<String> infixExpressionList = polandNotation.infixExpressionToArraylist(expression);\n         //System.out.println(infixExpressionList);\n\n         //根据中缀表达式集合转换成后缀表达式集合\n\n        List<String> suffixExpressionList = polandNotation.suffixExpressionToArraylist(infixExpressionList);\n\n          System.out.println(suffixExpressionList);\n\n         polandNotation.calculator(suffixExpressionList);\n\n\n     }\n\n     //根据中缀表达式集合转换成后缀表达式集合\n    public  List<String> suffixExpressionToArraylist(List<String> infixExpressionList) {\n\n         //思路\n\n        //基本步骤\n        /*\n        1) 初始化两个栈：运算符栈 s1 和储存中间结果的栈 s2；\n        2) 从左至右扫描中缀表达式；\n        3) 遇到操作数时，将其压 s2；\n        4) 遇到运算符时，比较其与 s1 栈顶运算符的优先级：\n         1.如果 s1 为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；\n         2.否则，若优先级比栈顶运算符的高，也将运算符压入 s1；\n          3.否则，将 s1 栈顶的运算符弹出并压入到 s2 中，再次转到(4-1)与 s1 中新的栈顶运算符相比较；\n          5) 遇到括号时： (1) 如果是左括号“(”，则直接压入 s1 (2) 如果是右括号“)”，则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号为止，此时将这一对括号丢弃\n          6) 重复步骤 2 至 5，直到表达式的最右边\n          7) 将 s1 中剩余的运算符依次弹出并压入 s2\n          8) 依次弹出 s2 中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式\n         */\n\n\n        //转换成代码思路如下:\n\n        /*\n        这里就用一个栈，即栈s1,因为中间结果栈在过程中不会pop，只会添加，所以用数组代替，\n        当把元素加入数组中的时候到时候直接输出就是最后结果了\n        1.中缀表达式集合中的元素分为数字，括号，运算符三种元素\n        2.用 if else if else来处理这三种元素\n        3.数字直接入集合，括号的话分为左括号和右括号，左括号直接入，右括号的话弹出符号栈的元素放进后缀表达式ArrayList中直到遇到右括号。此时就把右括号弹出\n        4.然后是运算符。编写一个判断运算符优先级的方法.如果传进来的运算符的优先级小于等于栈顶的运算符的话,将栈顶的运算符弹出，\n        放进ArrayList集合中，再与新栈顶的元素比较，直到表达式最右边，（这里就是循环了）\n        5.栈中的元素弹出来放进集合\n\n\n         */\n\n        List<String> list=new ArrayList<>();\n\n        Stack<String> stack=new Stack<>(); //符号栈\n\n\n        //遍历传进来的中缀表达式集合\n\n           for(String s:infixExpressionList){\n\n               if(/* s.charAt(0)>=48 && s.charAt(0)<=57*/s.matches(\"\\\\d+\")){\n\n                   //说明是数字\n\n                   list.add(s);\n\n\n               }\n               else if(s.equals(\"(\")){\n\n                   stack.push(s);\n\n\n               }\n               else if(s.equals(\")\")){\n\n                  // 右括号的话,弹出符号栈顶的元素放进后缀表达式ArrayList中直到遇到左括号。此时就把左括号弹出\n     //\n                   while (true) {\n\n\n                       if(stack.peek().equals(\"(\")){\n\n                           break;\n\n                       }\n                       list.add(stack.pop());\n\n\n                   }\n                   stack.pop();//弹出左括号\n\n         //                   while (!stack.peek().equals(\"(\")){\n      //\n        //                       list.add(stack.pop());\n       //\n       //                   }\n     //                   stack.pop();//弹出左括号\n\n\n               }\n               else{\n\n                   while (true) {\n                       //运算符了\n                       if (stack.size()==0||operatorPriority(s)> operatorPriority(stack.peek())) {\n\n                           stack.push(s);\n                           break;\n                       }\n                       // 如果传进来的运算符的优先级小于等于栈顶的运算符的话,将栈顶的运算符弹出，\n                       //放进ArrayList集合中，再与新栈顶的元素比较，直到表达式最右边，（这里就是循环了）\n                       list.add(stack.pop());\n\n                   }\n\n        //                   while (stack.size()!=0 && operatorPriority(s)<=operatorPriority(stack.  peek())){\n    //\n    //                       list.add(stack.pop());\n    //\n    //                   }\n    //                   stack.push(s);\n\n               }\n\n\n\n           }\n\n           while (true){\n               if (stack.size()==0){\n                   break;\n               }\n               list.add(stack.pop());\n           }\n           //遍历list就是最后的结果\n\n          System.out.println(list);\n\n\n    return  list;\n\n\n\n    }\n\n\n    //实现中缀表达式转逆波兰表达式(后缀表达式)\n\n    //首先要将中缀表达式字符串转为一个ArrayList集合，这样会方便遍历操作\n\n    public  List<String> infixExpressionToArraylist(String infixExpression){\n\n         //中缀表达式字符串转为一个ArrayList集合\n        //因为是扫描字符加入集合中，如果是数字的话就要考虑多位数,否则就直接加入集合中\n\n        List<String> list=new ArrayList<>();\n        int index=0;\n        String keepNum=\"\";//用于拼接字符串的\n\n\n\n        while (true) {\n\n            if(index==infixExpression.length()){\n\n                break;\n\n            }\n            String s = infixExpression.substring(index, index + 1);\n            //判断字符是否是一个数字\n            if (isOperator(s)) {\n\n                //说明是运算符,直接加入集合\n\n                list.add(s);\n\n            } else {\n\n                //否则就是数字\n                  //拼接\n\n\n\n                if(index==infixExpression.length()-1){\n\n                    //数组最后一个\n                    //直接加入集合\n                    list.add(s);\n\n                }\n                else{\n\n\n                    if(isOperator(infixExpression.substring(index+1,index+2))){\n\n                        keepNum += s;\n                        list.add(keepNum);\n                        keepNum=\"\";\n\n\n                    }\n                    else{\n\n                        keepNum += s;\n                    }\n\n\n\n                }\n\n\n\n\n            }\n            index++;\n\n        }\n\n          return  list;\n\n\n\n\n\n    }\n    //定义一个判断是否是运算符的方法\n\n    public   boolean isOperator(String c){\n\n      return c.equals(\"+\")||c.equals(\"-\")||c.equals(\"*\")||c.equals(\"/\")||c.equals(\"(\")||c.equals(\")\");\n\n\n\n    }\n\n\n    //提取一个方法，后缀表达式的计算\n\n    public  void calculator(List<String> list){\n\n        //只需要一个栈\n        ArrayCalculatorStack stack =new ArrayCalculatorStack(10);\n        //从左到右进行扫描，遇到数字直接进数字栈,遇到运算符就弹出栈中的顶和次顶元素与运算符进行运算，再把运算结果进栈。\n        //以此循环，直到表达式的最右边。\n\n        //把字符串进行分割（以空格进行分割），存到ArrayList数组中。遍历数组，遇到数字就压栈，遇到符号就弹两个\n\n\n\n\n\n\n        int num1=0;\n        int num2=0;\n        char c=' '; //ArrayList中遍历出每一个字符串转成的字符\n        int res=0;\n\n\n        for (int i=0;i<list.size();i++){\n            //说明是运算符\n            c=list.get(i).charAt(0);\n\n            if(stack.isOperator(c)){\n\n                //弹栈\n                num1=stack.pop();\n                num2=stack.pop();\n                res = stack.calculator(num1, num2, c);\n                //把结果再压入栈中\n                stack.push(res);\n\n\n            }\n            else{\n\n                //不是运算符\n                //直接入栈\n                stack.push(Integer.parseInt(list.get(i)));\n\n\n            }\n\n\n        }\n\n\n        System.out.println(\"最终结果是\"+res);\n\n\n    }\n\n    //判断运算符的优先级\n    public  int operatorPriority(String ss){\n\n         if(ss.equals(\"+\")||ss.equals(\"-\")){\n\n             return 0;\n\n         }\n         else if(ss.equals(\"*\")||ss.equals(\"/\")){\n\n             return  1;\n         }\n         else {\n\n             return -1;\n\n         }\n\n\n    }\n\n    }\n    \n\n\n\n","tags":["学习笔记"]},{"title":"数据结构-单向环形链表解决约瑟夫问题","url":"/2020/04/19/数据结构-单向环形链表解决约瑟夫问题/","content":"\n用单向环形链表解决--约瑟夫问题\n<!--more-->\n### 问题描述：\n\n   Josephu 问题为：设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1<=k<=n）的人从 1 开始报数，数 到 m 的那个人出列，它的下一位又从 1 开始报数，数到 m 的那个人又出列，依次类推，直到所有人出列为止，由 此产生一个出队编号的序列。\n\n\n### 解决思路： \n\n用一个不带头结点的循环链表来处理 Josephu 问题：先构成一个有 n 个结点的单循环链表，然后由 k 结 点起从 1 开始计数，计到 m 时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从 1 开始计数，直 到最后一个结点从链表中删除算法结束。\n\n\n### 代码实现\n\n    public class JosePuLinked {\n\n\n    //约瑟夫问题\n\n    //    Josephu 问题为：设编号为 1，2，… n 的 n 个人围坐一圈，约定编号为 k（1<=k<=n）的人从 1 开始报数，\n    //     数到 m 的那个人出列，它的下一位又从 1 开始报数，\n    //     数到 m 的那个人又出列，依次类推，直到所有人出列为止，\n    //     由此 产生一个出队编号的序列。\n\n    //解决：用环形单链表来解决问题。n个节点。\n\n    public static void main(String[] args) {\n\n\n     CircleLinkedList circleLinkedList=new CircleLinkedList();\n     circleLinkedList.createCircleLinked(5);\n    circleLinkedList.list();\n\n    circleLinkedList.countNode(1,2,5);\n\n\n    }\n\n\n\n\n    }\n\n\n    class CircleLinkedList{\n\n\n    //指定一个first指针，指向创建的第一个节点\n\n    Node first=null;\n\n\n\n    //创建一个环形单链表\n\n    public  void  createCircleLinked(int nums){\n\n        Node cur=null;\n        //nums表示要创建的节点的个数\n        if(nums<=1){\n\n            //设置一个两个孩子及以上才玩\n            return;\n\n        }\n\n\n\n       //循环创建节点\n\n        for (int i=1;i<=nums;i++){\n\n             Node node=new Node(i);\n            if(i==1){\n\n                //说明是第一个节点(编号为1)\n\n\n                first=node;\n\n                //first节点不动，需要一个cur辅助变量来连接新创建的节点\n                //首先指向第一个节点\n                cur=first;\n\n                first.setNext(first);\n                //第一个节点自己形成环\n\n\n            }\n            else{\n\n                //否则是其他节点\n                //这个时候就要把新创建的节点连接起来\n\n                cur.setNext(node); //第一个节点指向新建节点\n                node.setNext(first);//新节点再指向第一个节点\n                cur=node;//cur后移到新节点\n\n            }\n\n        }\n\n\n        \n        \n\n\n    }\n\n\n    //遍历环形单链表\n\n    public  void list(){\n\n        //辅助变量cur,从第一个开始\n\n        if(first==null){\n            return;\n        }\n       Node cur=first;\n\n        while (true){\n\n            System.out.println(cur.getNo());\n            if(cur.getNext()==first){\n\n                break;\n            }\n            //System.out.println(cur.getNo());  注意，输出写在这里就造成输出倒数第二个节点时，\n            // 下面cur变成最后一个节点，再到上面就break了\n            //所以就打印不了最后一个\n            cur=cur.getNext();\n\n\n        }\n\n\n    }\n\n\n    //进行游戏，报数出队\n    //k是开始报数的节点编号，m是数几下，nums是节点个数\n    public  void countNode(int k,int m, int nums){\n\n        //首先刚开始需要一个辅助变量指向环形链表的最后一个节点。\n        // 这样做是为了当first指向要被删除的节点时，\n        // 可以让first后面的辅助变量helper指针把要被删除的节点的后一个节点连起来,继续形成环\n        //所以说这个方法里面first指针会变化，从谁开始报数就指向谁，从k编号开始报数的话first和helper就要移动k-1位。\n        // 然后报完之后first和helper要后移m-1(m是数几下),这个时候first指向的节点就是要被删除的节点，\n        //然后first再指向下一个节点，这个节点就是要开始报数的节点了。\n\n        if(k<1||k>nums||first==null){\n            System.out.println(\"参数不合法!\");\n            return;\n        }\n        Node helper=first;\n\n        //遍历，让helper指向最后一个节点\n        while (true){\n\n            if(helper.getNext()==first){\n\n                break;\n\n            }\n            helper=helper.getNext(); //后移\n\n        }\n\n     //这个时候helper已经指向最后一个节点了。\n\n      //从k编号开始报数的话first和helper就要移动k-1位。\n\n\n            for (int i = 0; i < k - 1; i++) {\n\n                first = first.getNext();\n                helper = helper.getNext();\n\n            }\n\n            // 报完之后first和helper要后移m-1(m是数几下),这个时候first指向的节点就是要被删除的节点\n\n        while (true) {\n            if(helper==first){\n                break;\n            }\n            for (int i = 0; i < m - 1; i++) {\n\n                first = first.getNext();\n                helper = helper.getNext();\n\n            }\n\n            //这个时候first指向的节点就是要被删除的节点\n\n            System.out.println(first.getNo() + \"出圈了\");\n            //删掉这个节点,并连起来\n            first = first.getNext();\n            helper.setNext(first);\n\n\n        }\n        System.out.println(first.getNo()+\"出圈了\");\n    }\n\n    }\n\n    class Node{\n\n    //环形单链表节点\n    private  int no;//编号\n    private  Node next;//next域\n\n    public int getNo() {\n        return no;\n    }\n\n    public void setNo(int no) {\n        this.no = no;\n    }\n\n    public Node getNext() {\n        return next;\n    }\n\n    public void setNext(Node next) {\n        this.next = next;\n    }\n\n    public Node(int no) {\n        this.no = no;\n    }\n\n\n    }\n\n\n\n\n\n\n   \n\n\n","tags":["学习笔记"]},{"title":"数据结构-单链表和双链表的操作","url":"/2020/04/16/数据结构-单链表和双链表的操作/","content":"\n 单链表的增删查改\n<!-- more-->\n---\n### 创建一个节点\n\n    //首先定义节点\n    class  HeroNode {\n\n    //属性\n      int no; //英雄编号\n      String name;//英雄姓名\n      String nickName;//英雄称号\n      HeroNode next;//节点的next域，指向下一个节点(它就是连接的下一个对象的地址)\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getNickName() {\n        return nickName;\n    }\n\n    public void setNickName(String nickName) {\n        this.nickName = nickName;\n    }\n\n    //定义构造函数\n    //定义英雄节点属性的时候不需要用到next域，默认为空，因为后面增删查改会对它进行处理,这样才会连起来\n\n    public HeroNode(int no, String name, String nickName) {\n        this.no = no;\n        this.name = name;\n        this.nickName = nickName;\n    }\n\n    @Override\n    public String toString() {\n        return \"HeroNode{\" +\n                \"no=\" + no +\n                \", name='\" + name + '\\'' +\n                \", nickName='\" + nickName + '\\'' +\n                '}';\n    }\n     }\n\n\n  \n\n\n### 创建一个单链表\n\n    //创建一个单链表\n\n    class  SingleLinkedList{\n\n    //单链表是由节点组成的，先给它一个固定的头结点。以后的几点增删改查\n\n    //编号为0，其他为空,头结点不存放数据\n    HeroNode head=new HeroNode(0,\"\",\"\");\n\n    //类中可写增删查改方法\n\n\n    }\n\n###  添加节点（直接在链表后面添加）\n\n        //添加\n    //不管编号顺序，直接在链表最后添加\n    public void add(HeroNode heroNode){\n\n        //得遍历链表，找到最后一个节点就退出,在节点的后面添加\n        //需要一个辅助变量来辅助遍历,头结点不能动\n\n        //代表从头结点开始，因为添加节点的话如果原来为空链表，\n        // 就要在头节点后面添加，需要与头节点建立联系，所以temp指向头节点是可取的\n        HeroNode temp=head;\n\n        while (true){\n\n            //表示是temp指向的节点是链表最后一个节点,退出\n            if(temp.next==null){\n\n                break;\n\n            }\n            //如果不是最后一个节点，temp就持续指向下一个\n\n            temp=temp.next;\n\n        }\n\n        //循环退出，添加\n        //此时temp指向最后一个节点\n        temp.next=heroNode;\n\n\n    }\n\n\n### 添加节点 （排序节点不重复添加）\n\n     //接下来是编号排序（从一开始）且编号唯一的添加\n\n    public  void  addOrder(HeroNode heroNode){\n\n        //条件分析：\n        /*\n        插入：1.节点后面插入(无论链表是空还是不空只需要temp.next==null，退出循环即可实现该方式的插入)\n              2.链表中间插入(temp.next.no > 传入节点.no,即可实现从小到大插入)\n        不插入:temp.next.no == 传入节点.no,实现唯一插入\n       三个条件只要满足一个就会退出循环，实现插与不插\n        每次插入节点都要遍历链表，如果遍历到的temp都不满足三种条件，那就后移temp,总有一个temp会满足条件。\n\n         */\n\n        HeroNode temp=head; //添加节点与head要联系起来,况且中间插入需要temp指定在要被插入位置的前一位\n        boolean flag=false; //默认插入的节点不重复\n        while (true){\n\n            if(temp.next==null){\n\n                //节点后面插入(无论链表是空还是不空只需要temp.next==null，退出循环即可实现该方式的插入)\n                break;\n            }\n            if (temp.next.no >heroNode.no){\n                //中间插入需要temp指定在要被插入位置的前一位\n                //2.链表中间插入(temp.next.no > 传入节点.no,即可实现从小到大插入)\n                break;\n            }\n            if (temp.next.no==heroNode.no){\n\n                //不插入:temp.next.no == 传入节点.no,实现唯一插入\n                flag=true;//重复数据\n                break;\n\n            }\n\n            //如果遍历到的temp都不满足三种条件，那就后移temp,总有一个temp会满足条件。\n            temp = temp.next;\n\n\n        }\n\n        //三个条件只要满足一个就会退出循环，实现插与不插\n        if(flag){\n\n            //重复数据不插入\n            System.out.println(\"插入的节点数据重复，无法添加！\"+heroNode.no);\n\n        }\n        else {\n\n            //进行插入操作\n\n            //这里一定要注意，顺序不能颠倒。如果颠倒了那么链表就连不起来了。\n            heroNode.next=temp.next;\n            temp.next=heroNode;\n\n        }\n\n\n\n\n    }\n\n\n### 遍历\n\n       //遍历\n\n    public  void list(){\n\n        //遍历链表\n\n        HeroNode temp=head.next; //直接遍历操作不操作头节点，所以辅助变量直接指向第一个节点\n            if (head.next == null) {\n\n                //链表为空，直接返回\n                return;\n\n            }\n\n            while (true){\n\n                //如果到最后一个就退出\n\n                if(temp==null){\n\n                    //到最后了\n                    break;\n\n                }\n                //每遍历一个节点就输出\n                System.out.println(temp);\n\n                //temp指向下一个节点\n                temp=temp.next;\n\n            }\n\n\n\n\n        }\n\n\n\n\n### 修改单链表节点\n\n    \n    //修改节点数据\n    public void  update(HeroNode heroNode){\n\n        //修改节点就要通过遍历找到要被修改的节点，修改数据即可（编号不修改，修改英雄名字或者昵称）\n        //不与头节点联系，所以\n        HeroNode temp=head.next; //直接指向第一个节点\n\n        if(temp==null){\n\n            //说明链表为空，直接返回\n            return;\n        }\n        while (true){\n\n\n            //找到了要被修改的数据\n            if(temp.no==heroNode.no){\n                //进行修改\n                temp.name=heroNode.name;\n                temp.nickName=heroNode.nickName;\n                break;\n            }\n            //遍历到最后了也没找到，退出\n    //            if(temp==null){\n    //                System.out.println(\"节点数据未找到！\");\n    //                break;\n    //\n    //            }\n            if(temp.next!=null) {\n                temp = temp.next;\n            }\n            else {\n                System.out.println(\"修改未找到数据\");\n                break;\n            }\n        }\n\n\n    }\n\n\n\n### 删除\n\n     //删除节点\n\n    public  void  delete(HeroNode heroNode){\n\n        //遍历找到要被删除节点的前一个节点，这样能把被删除数据前一个与被删除数据后一个的连接连起来\n        //所以temp从head开始\n        HeroNode temp=head;\n\n        //判断链表是否为空\n        if(head.next==null){\n            return;\n        }\n        while (true){\n\n            if(temp.next.no==heroNode.no){\n\n                //说明该temp是被删除节点的前一个节点\n\n                //这是删除的节点不是最后一个节点的时候\n\n                    temp.next = temp.next.next;\n\n\n                break;\n\n            }\n\n            if(temp.next!=null){\n\n                temp=temp.next;\n            }\n           else {\n                System.out.println(\"未找到要被删除的数据！\");\n                break;\n            }\n\n\n        }\n\n\n    }\n\n\n\n\n## 单链表面试题\n\n求单链表中有效数据的个数\n\n        public  int getLength(){\n\n\n        HeroNode temp=head.next; //直接遍历有效节点，不与head联系\n        //说白就是了遍历节点，求出遍历次数\n            int length=0;\n\n            if(head.next==null){\n\n                return  0;\n\n            }\n            while (true){\n\n                if(temp==null){\n\n                    //到最后了\n                    break;\n\n                }\n                length++;\n                temp=temp.next;\n\n\n            }\n\n\n        return length;\n        }\n\n\n\n\n\n----\n\n新浪面试题，查找单链表中的倒数第k个节点\n\n       public void getBackKNode(int k){\n\n        //思路:遍历取到单链表的节点个数,用节点个数减去k，得到一个数，然后遍历\n        int a=getLength()-k+1;\n        int n=0;\n        if(k<1||k>getLength()){\n\n            System.out.println(\"参数不合法\");\n\n        }\n        if(head.next==null){\n\n            return;\n        }\n\n        HeroNode temp=head.next;\n\n        while (temp!=null){\n\n            n++;\n            if(n==a){\n\n                break;\n\n            }\n            else {\n                temp = temp.next;\n            }\n\n\n\n\n\n        }\n        System.out.println(temp);\n\n\n    }\n\n\n\n----\n\n腾讯面试题,反转一个单链表\n\n\n       public void reverseSingleLinked(){\n\n        //思路：\n        /*\n\n        创建一个新的单链表头节点，用来辅助生成反转链表\n        根据原单链表的头节点，先遍历出每一个有效节点。(辅助变量从第一个有效节点开始指)\n        遍历到每一个新的节点，就把让头r指向它。但是单单这样是不行的，因为这样只是永远在换r的next的指向值\n        所以，我们要想一个方法，让新节点进来r.next的同时，也要把以前遍历的节点连在一起\n\n        如 h  1 2 3 4\n           r\n        当前的cur假设是2\n\n        这个时候呢，当我把r.next指向2的时候，我的1呢？1的话可以这样：\n\n        在cur等于1的时候，让cur指向r(cur.next=r.next),再把r->1(r.next=cur),那么就会形成\n\n        当前cur指向的就是1(第一步循环就是得到r的next域是1)\n\n        然后 再当cur=2时，继续cur.next=r.next,这样2和1就可以连起来了，\n\n        然后再用r.next指向2（r.next=cur）,就会形成 r->2->1的结果，\n\n        以此类推，当3进来的时候,把3指向r的next域（变成2了），这个时候就是3->2->1连起来了，再r->3(r.next-cur),以此类推，最终就可以连起来\n\n        cur.next=r.next  //先把当前cur指向r的next域，那么节点1在节点2\n\n\n        */\n\n        //实现\n\n        HeroNode cur=head.next;//辅助变量从第一个有效节点开始指)\n\n        HeroNode next=null;//用来后移cur的指向,达到遍历的效果\n\n        HeroNode reverseHead=new HeroNode(0,\"\",\"\");\n\n        if(head.next==null||head.next.next==null){\n\n            //空的或者只有一个节点，不用反转\n            return;\n\n        }\n        while (true){\n\n            if(cur==null){\n\n                //说明到最后的节点了\n                break;\n            }\n            //否则\n            next=cur.next; //记录下一个cur的指向值\n\n            cur.next=reverseHead.next;\n\n            reverseHead.next=cur;\n            cur=next; //后移\n\n\n\n        }\n\n        //退出循环后，因为你是新建了一个头，所以你的头结点地址和原来的头是不一样的\n        //所以把旧头指向新头的next即可\n\n        head.next=reverseHead.next;\n\n        //遍历一下验证\n        list();\n\n\n    }\n\n\n\n\n\n---\n\n百度面试题：从尾到头打印单链表\n\n\n    public   void  reversePrint(){\n\n        //不建议采用把链表翻转过来再遍历,因为这样会改变链表结构,可能会出问题\n\n        //采用栈，以此遍历节点，压入栈中，再pop弹栈\n\n        //新建一个栈\n        Stack<HeroNode> stack=new Stack<>();\n\n        HeroNode temp=head.next;\n        if(head.next==null){\n\n            return;\n        }\n        while (true){\n\n            if(temp==null){\n\n                break;\n            }\n            stack.push(temp);\n            temp=temp.next;\n\n\n        }\n\n      while (stack.size()>0){\n\n          System.out.println(stack.pop());\n      }\n\n    }\n\n\n\n---\n高频面试题：合并两个有序的单链表，合并之后的链表依然有序\n\n    public class mergeLinkedListDemo {\n\n    //用递归来解决问题,精辟！\n    /*\n    如 1->2->4\n       1->3->4\n\n       合并后希望是这样 1->1->2->3->4->4\n    */\n    public static void main(String[] args) {\n\n\n        ListNode l1=new ListNode(1);\n        ListNode l1Ne=new ListNode(2);\n        ListNode l1NeNe=new ListNode(4);\n        l1.setNext(l1Ne);\n        l1Ne.setNext(l1NeNe);\n\n        ListNode l2=new ListNode(1);\n        ListNode l2Ne=new ListNode(3);\n        ListNode l2NeNe=new ListNode(4);\n        l2.setNext(l2Ne);\n        l2Ne.setNext(l2NeNe);\n\n\n        ListNode newNode=ListNode.mergeLinkedList(l1,l2);\n\n      System.out.println(newNode);\n\n    }\n\n\n    }\n\n    class  ListNode{\n\n    int val;\n    ListNode next;\n\n    public ListNode getNext() {\n        return next;\n    }\n\n    @Override\n    public String toString() {\n        return \"ListNode{\" +\n                \"val=\" + val +\n                \", next=\" + next +\n                '}';\n    }\n\n    public void setNext(ListNode next) {\n        this.next = next;\n    }\n\n    public ListNode(int val) {\n        this.val = val;\n    }\n\n    /*\n    好比打架，因为原来两个链表都是默认从小到大排序，也就是，每一组都是从弱到强\n    动脑想想\n    要想获得所有人的排名（从弱到强）\n    首先得拿第一组最弱的和第二组最弱的比，谁输了，也就是谁小，就上排行位\n    然后把输的那一组的次弱的拿出来，和第二组（上一轮赢的那一组）进行比较，输的上排行榜，以此类推，\n    到了某一组的人物是null, 另一组有人，说明没对手，直接上排行版\n    */\n\n    public   static ListNode mergeLinkedList(ListNode l1,ListNode l2){\n\n        if(l1==null){\n\n            return l2;\n        }\n        if(l2==null){\n\n            return  l1;\n        }\n\n        ListNode head=null;\n\n        if(l1.val<=l2.val){\n\n            head=l1;\n            head.next=mergeLinkedList(l1.next,l2);\n\n        }\n        else {\n\n            head=l2;\n            head.next=mergeLinkedList(l1,l2.next);\n\n        }\n\n        return  head;\n    }\n    }\n\n    \n---\n\n\n---\n\n\n\n# 双链表\n\n管理单向链表的缺点分析: \n\n1) 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。 \n\n2) 单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以自我删除，所以前面我们单链表删除时节点，总是找到 temp,temp 是待删除节点的前一个节点。\n\n\n\n\n##  创建双链表节点\n\n    //首先定义节点\n    class  HeroNode2 {\n\n    //属性\n    int no; //英雄编号\n    String name;//英雄姓名\n    String nickName;//英雄称号\n    HeroNode2 next;//节点的next域，指向下一个节点(它就是连接的下一个对象的地址)\n    HeroNode2 pre;//节点的pre域，指向前一个节点。\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getNickName() {\n        return nickName;\n    }\n\n    public void setNickName(String nickName) {\n        this.nickName = nickName;\n    }\n\n    //定义构造函数\n    //定义英雄节点属性的时候不需要用到next域和pre域，默认为空，因为后面增删查改会对它进行处理,这样才会连起来\n\n    public HeroNode2(int no, String name, String nickName) {\n        this.no = no;\n        this.name = name;\n        this.nickName = nickName;\n    }\n\n    @Override\n    public String toString() {\n        return \"HeroNode2{\" +\n                \"no=\" + no +\n                \", name='\" + name + '\\'' +\n                \", nickName='\" + nickName + '\\'' +\n                '}';\n    }\n    }\n##  新建一个双链表\n\n    class DoubleLinkedList{\n\n    //固定头\n    HeroNode2 head=new HeroNode2(0,\"\",\"\");\n    }\n\n\n\n## 添加（直接链表后面添加）\n\n        //添加（直接添加到链表的最后）\n\n    public void add(HeroNode2 heroNode2){\n\n        //得遍历链表，找到最后一个节点就退出,在节点的后面添加\n        //需要一个辅助变量来辅助遍历,头结点不能动\n\n        //代表从头结点开始，因为添加节点的话如果原来为空链表，\n        // 就要在头节点后面添加，需要与头节点建立联系，所以temp指向头节点是可取的\n        HeroNode2 temp=head;\n\n        while (true){\n\n            //表示是temp指向的节点是链表最后一个节点,退出\n            if(temp.next==null){\n\n                break;\n\n            }\n            //如果不是最后一个节点，temp就持续指向下一个\n\n           temp=temp.next;\n\n        }\n\n        //循环退出，添加\n        //此时temp指向最后一个节点\n        temp.next=heroNode2;\n        heroNode2.pre=temp;\n\n\n    }\n\n## 添加（编号排序不重复添加）\n\n    //接下来是编号排序（从一开始）且编号唯一的添加\n\n    public  void  addOrder(HeroNode2 heroNode2){\n\n        //条件分析：\n        /*\n        插入：1.节点后面插入(无论链表是空还是不空只需要temp.next==null，退出循环即可实现该方式的插入)\n              2.链表中间插入(temp.next.no > 传入节点.no,即可实现从小到大插入)\n        不插入:temp.next.no == 传入节点.no,实现唯一插入\n       三个条件只要满足一个就会退出循环，实现插与不插\n        每次插入节点都要遍历链表，如果遍历到的temp都不满足三种条件，那就后移temp,总有一个temp会满足条件。\n\n         */\n\n        HeroNode2 temp=head; //添加节点与head要联系起来,况且中间插入需要temp指定在要被插入位置的前一位\n        boolean flag=false; //默认插入的节点不重复\n        while (true){\n\n            if(temp.next==null){\n\n                //节点后面插入(无论链表是空还是不空只需要temp.next==null，退出循环即可实现该方式的插入)\n                break;\n            }\n            if (temp.next.no >heroNode2.no){\n                //中间插入需要temp指定在要被插入位置的前一位\n                //2.链表中间插入(temp.next.no > 传入节点.no,即可实现从小到大插入)\n                break;\n            }\n            if (temp.next.no==heroNode2.no){\n\n                //不插入:temp.next.no == 传入节点.no,实现唯一插入\n                flag=true;//重复数据\n                break;\n\n            }\n\n            //如果遍历到的temp都不满足三种条件，那就后移temp,总有一个temp会满足条件。\n            temp = temp.next;\n\n\n        }\n\n        //三个条件只要满足一个就会退出循环，实现插与不插\n        if(flag){\n\n            //重复数据不插入\n            System.out.println(\"插入的节点数据重复，无法添加！\"+heroNode2.no);\n\n        }\n        else {\n\n            //进行插入操作\n\n           heroNode2.next=temp.next;\n           heroNode2.pre=temp;\n           temp.next=heroNode2;\n           temp.next.pre=heroNode2;\n\n        }\n\n\n\n\n    }\n\n\n## 遍历\n\n    //遍历\n\n    public  void list(){\n\n        //遍历链表\n\n        HeroNode2 temp=head.next; //直接遍历操作不操作头节点，所以辅助变量直接指向第一个节点\n        if (head.next == null) {\n\n            //链表为空，直接返回\n            return;\n\n        }\n\n        while (true){\n\n            //如果到最后一个就退出\n\n            if(temp==null){\n\n                //到最后了\n                break;\n\n            }\n            //每遍历一个节点就输出\n            System.out.println(temp);\n\n            //temp指向下一个节点\n            temp=temp.next;\n\n        }\n\n\n\n\n    }\n\n\n## 修改\n\n     public void  update(HeroNode2 heroNode2){\n\n        //修改节点就要通过遍历找到要被修改的节点，修改数据即可（编号不修改，修改英雄名字或者昵称）\n        //不与头节点联系，所以\n        HeroNode2 temp=head.next; //直接指向第一个节点\n\n        if(temp==null){\n\n            //说明链表为空，直接返回\n            return;\n        }\n        while (true){\n\n\n            //找到了要被修改的数据\n            if(temp.no==heroNode2.no){\n                //进行修改\n                temp.name=heroNode2.name;\n                temp.nickName=heroNode2.nickName;\n                break;\n            }\n            //遍历到最后了也没找到，退出\n    //            if(temp==null){\n    //                System.out.println(\"节点数据未找到！\");\n    //                break;\n    //\n    //            }\n            if(temp.next!=null) {\n                temp = temp.next;\n            }\n            else {\n                System.out.println(\"修改未找到数据\");\n                break;\n            }\n        }\n\n\n    }    \n\n\n\n## 删除\n\n          public  void del(int no){\n\n        //双链表的删除,可以实现temp指向哪里就删除哪里，所以temp从head.next开始\n\n        HeroNode2 temp=head.next;\n\n        boolean flag=false;//默认找不到要删除的节点\n\n        if(head.next==null){\n\n            return;\n\n        }\n\n        while (true){\n\n            if (temp==null){\n\n                //最后一个节点了，也没找到\n            }\n            if(temp.no==no){\n\n                flag=true;\n                break;\n            }\n            temp=temp.next;\n\n        }\n        if(flag){\n            //说明找到了\n\n                temp.pre.next = temp.next;//这是 被删除节点的前一位指向被删除节点的后一位的next域\n                if(temp.next!=null) {\n                //当你删除的 就是最后一个节点时，这个的temp.next.pre会报null,因为temp.next=null,null.pre??报错了,所以得加条件\n                temp.next.pre = temp.pre;//这是 被删除节点的后一位指向被删除节点的前一位的pre域，\n            }\n\n\n        }\n\n\n\n\n    }\n\n    \n\n\n\n    \n\n\n\n","tags":["学习笔记"]},{"title":"数据结构-稀疏数组及数组模拟队列","url":"/2020/04/14/数据结构-稀疏数组-数组模拟队列/","content":"\n*稀疏数组和数组模拟队列:*\n<!-- more-->\n# 稀疏数组\n\n### 基本概述\n\n当一个二维数组大部分数据都为0的时候，可以用到稀疏数组来保存该数组。\n\n\n  ![稀疏数组图示](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/EC41B3539BC24693B2A3772DA190DF4C/15)\n\n  稀疏数组的第一行分别存放原二维数组的行数，列数，以及非0的值个数\n  \n  从第二行开始就是存放非0数据分别在哪一行哪一列....\n\n\n## 二维数组与稀疏数组的转换\n代码如下：\n\n\n    package com.yjr.sparseArray;\n\n    import java.io.*;\n\n    public class sparseArray {\n\n     public static void main(String args[]) {\n\n         //原二维数组转稀疏数组\n         //假设定义一个二维数组，11行，11列，非0数据为sum个。\n\n         int [][] chessArr=new  int [11] [11];\n         chessArr[1][3]=8;\n         chessArr[2][4]=7;\n         chessArr[1][6]=11;\n         chessArr[6][3]=5;\n         chessArr[8][9]=15;\n\n\n         //怎么转？思路如下\n         //首先把二维数组进行遍历，得到有效数据个数\n         //定义一个sum来记录原二维数组的非0个数\n         int sum=0;\n         System.out.println(\"遍历原二维数组.....\");\n\n         for (int [] rows:chessArr){\n\n             //遍历行数组出来\n             //再遍历行数组里面的每一个数据\n             for (int data:rows){\n\n                 if(data!=0){\n\n                   sum++;\n\n                   //输出一下每一个行数组的数据\n                 }\n                 System.out.printf(\"%d\\t\",data);\n\n\n             }\n             System.out.println();\n\n         }\n         System.out.println(\"有效数据为:\" + sum);\n\n\n         //现在要把该二维数组转成稀疏数组\n         //定义稀疏数组\n         int [] [] sparseArray=new int [sum+1][3];\n\n         sparseArray[0][0]=11;\n         sparseArray[0][1]=11;\n         sparseArray[0][2]=sum;\n\n         //现在要对稀疏数组进行赋值\n\n         //遍历原二维数组\n         //定义一个count来记录是第几个非0数据\n         int count=0;\n         for (int i=0;i<11;i++){\n\n             for (int j=0;j<11;j++){\n\n                 if(chessArr[i][j]!=0){\n\n                     count++;\n\n                     sparseArray[count][0]=i;\n                     sparseArray[count][1]=j;\n                     sparseArray[count][2]=chessArr[i][j];\n\n\n\n                 }\n\n\n             }\n\n\n         }\n\n         //将稀疏数组写入文件中\n\n         try {\n\n             FileWriter writer=new FileWriter(\"map.txt\");\n             BufferedWriter bufferedWriter=new BufferedWriter(writer);\n\n             for (int [] rows:sparseArray){\n\n                 for (int data:rows){\n\n                     bufferedWriter.write(String.valueOf(data)+\"\\t\");\n                 }\n                 bufferedWriter.newLine();\n\n             }\n             bufferedWriter.flush();\n             bufferedWriter.close();\n             writer.close();\n\n         } catch (IOException e) {\n             e.printStackTrace();\n         }\n\n         System.out.println(\"输出稀疏数组!\");\n         //输出该稀疏数组\n         for (int a=0;a<sparseArray.length;a++){\n\n             System.out.printf(\"%d\\t%d\\t%d\\t\",sparseArray[a][0],sparseArray[a][1],sparseArray[a][2]);\n             System.out.println();\n         }\n\n         //先把稀疏数组从文件中取出来\n\n         int [] [] spareArr2=new int[sum+1][3];\n         try {\n             FileReader reader=new FileReader(\"map.txt\");\n             BufferedReader bufferedReader=new BufferedReader(reader);\n\n\n\n             String[] s1 = null;\n             int[] spa=null;\n             String s ;\n             int account=0;\n             while ((s=bufferedReader.readLine())!=null){\n\n                 s1=s.split(\"\\t\");\n\n              spa=new int[s1.length];\n                for (int i=0;i<s1.length;i++){\n\n                   spa[i]=Integer.parseInt(s1[i]);\n               }\n\n                for(int i=0;i<spa.length;i++){\n\n                    spareArr2[account][i]=spa[i];\n\n                }\n                account++;\n\n            }\n\n         } catch (Exception e) {\n             e.printStackTrace();\n         }\n         //遍历一下读取出来的稀疏数组\n         System.out.println(\"遍历读取出来的稀疏数组\");\n         for (int[] rows:spareArr2){\n\n             for (int data:rows){\n\n                 System.out.printf(\"%d\\t\",data);\n             }\n             System.out.println();\n         }\n\n         //接下来是讲稀疏数组恢复成原始的二维数组\n\n         //首先明确恢复成的二维数组是多少行，多少列\n         int chessArr2[][]=new int[sparseArray[0][0]][sparseArray[0][1]];\n\n         //接下来对该数组进行赋值\n         //遍历稀疏数组\n       for(int i=1;i<sparseArray.length;i++){\n\n           chessArr2[sparseArray[i][0]][sparseArray[i][1]]=sparseArray[i][2];\n\n       }\n\n       //输出该二维数组\n         System.out.println(\"输出从稀疏数组恢复的二维数组\");\n         for (int [] rows:chessArr2){\n\n             for (int data:rows){\n                 System.out.printf(\"%d\\t\",data);\n             }\n             System.out.println();\n         }\n\n\n     }\n\n\n\n\n     }\n\n\n\n\n\n\n\n\n---\n---\n---\n# 数组模拟队列\n\n### 非环形队列\n\nfront:初始值为-1，头元素的前一个位置\n\nrear:初始值为-1,指向尾元素\n\nmaxSize:数组容量\n\n队空：front==rear\n\n队满: rear=maxSize-1\n\n## 实现的代码\n    package com.yjr.queue;\n\n\n\n    import java.util.Scanner;\n\n    public class ArrayQueueDemo {\n\n\n    //利用数组模拟队列\n\n\n    public static void main(String[] args) {\n\n        //创建一个队列\n\n        ArrayQueue arrayQueue = new ArrayQueue(5);\n\n        Scanner scanner = new Scanner(System.in);\n\n        //菜单\n        boolean top=true;\n        while (top) {\n\n            System.out.println(\"s(show): 显示队列\");\n            System.out.println(\"e(exit): 退出程序\");\n            System.out.println(\"a(add): 添加数据到队列\");\n            System.out.println(\"g(get): 从队列取出数据\");\n            System.out.println(\"h(head): 查看队列头的数据\");\n\n            //接收一个字符\n            char key = scanner.next().charAt(0);\n\n\n            switch (key) {\n\n                case 's':\n\n                    try {\n                        arrayQueue.showQueue();\n                        System.out.println();\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                        // System.out.println(e.getMessage());\n                    }\n                    break;\n\n                case 'e':\n                    scanner.close();\n                    System.out.println(\"程序已退出!\");\n                    top=false;\n                    break;\n\n                case 'a':\n\n\n                    System.out.println(\"请输入要添加的数据\");\n                    int n = scanner.nextInt();\n                    try {\n                        arrayQueue.addQueue(n);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                    break;\n\n                case 'g':\n                    try {\n                       int a= arrayQueue.getQueue();\n                        System.out.printf(\"取出的数据为%d\\n\",a);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                    break;\n\n                case 'h':\n\n                    try {\n                        arrayQueue.headQueue();\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                    break;\n\n                default:\n\n                    System.out.println(\"命令输入错误！\");\n                    break;\n\n            }\n\n\n        }\n\n\n    }\n\n\n    }\n\n\n    class  ArrayQueue{\n\n    //这是数组队列类\n\n    private int MaxSize; //数组的最大容量\n    private int front; //指向队头元素的前一个，默认为-1\n    private int rear;  //指向队尾元素，默认为-1\n    private int [] arr; //数组\n\n    public ArrayQueue(int maxSize) {\n        MaxSize=maxSize;\n        arr=new int[MaxSize];\n        front=-1;\n        rear=-1;\n\n        //这样通过构造函数就可以创建指定大小的数组\n    }\n\n\n    //写方法\n\n    //判断是否为空\n\n    public boolean isEmpty(){\n\n        return  front==rear;//两者相等的话就说明为空\n    }\n\n    //判断是否为满\n\n    public  boolean isFull(){\n\n        return  rear==MaxSize-1;\n    }\n\n    //添加队列\n    public  void  addQueue(int n){\n\n        //判断是否为满\n        if(isFull()){\n\n            System.out.println(\"队列已满，添加失败！\");\n            return;\n        }\n\n        //否则添加队列\n        //rear向后移\n        rear++;\n        arr[rear]=n;\n        System.out.println(\"添加成功了！\");\n    }\n\n    //取队列的数据(从头取)\n    public  int getQueue(){\n\n        //判断是否空\n        if(isEmpty()){\n\n            throw new RuntimeException(\"队列空，不能取数据\");\n\n        }\n        //否则\n        //front后移\n        front++;\n        //返回数据\n        return  arr[front];\n\n    }\n\n    //显示队列的所有数据\n    public void showQueue(){\n\n        //判断是否空\n        if (isEmpty()){\n\n            System.out.println(\"队列为空，无法取出\");\n\n        }\n\n        for(int i=0;i<arr.length;i++){\n\n            System.out.printf(\"arr[%d]=%d\\t\",i,arr[i]);\n\n        }\n\n    }\n\n    //查看队列的头元素\n    public  void headQueue(){\n        if (isEmpty()) {\n            System.out.println(\"队列为空，查看头信息失败！\");\n        }\n        front++;\n        System.out.println(arr[front]);\n\n    }\n\n\n    }\n\n\n---\n---\n## 环形队列\n\n![环形队列图示](https://note.youdao.com/yws/public/resource/c1aa3442f95e016630f952f214a11dac/xmlnote/E8E109CD1D7F4D299FEAEA267C3172F9/19)\n\n\nfront:初始值 0，指向头元素\n\nrear:初始值 0，指向尾元素的后一位\n\n队空: front==rear\n\n队满：(rear+1)%maxSize==front\n\n有效数据个数: (rear + maxSize - front)% maxSize\n\n添加队列完后:rear =(rear+1)%maxSize\n\n取出队列元素后: front=(front+1)%maxSize\n\n取余是为了防止越界\n\n\n---\n\n### 实现代码\n\n    package com.yjr.queue;\n\n\n    import java.util.Scanner;\n\n    public class CricleArrayQueueDemo {\n\n    public static void main(String args[]) {\n\n        //创建一个队列\n\n        CricleArrayQueue cricleArrayQueue = new CricleArrayQueue(5);\n\n        Scanner scanner = new Scanner(System.in);\n\n        //菜单\n        boolean top = true;\n        while (top) {\n\n            System.out.println(\"s(show): 显示队列\");\n            System.out.println(\"e(exit): 退出程序\");\n            System.out.println(\"a(add): 添加数据到队列\");\n            System.out.println(\"g(get): 从队列取出数据\");\n            System.out.println(\"h(head): 查看队列头的数据\");\n\n            //接收一个字符\n            char key = scanner.next().charAt(0);\n\n\n            switch (key) {\n\n                case 's':\n\n                    try {\n                        cricleArrayQueue.showQueue();\n                        System.out.println();\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                        // System.out.println(e.getMessage());\n                    }\n                    break;\n\n                case 'e':\n                    scanner.close();\n                    System.out.println(\"程序已退出!\");\n                    top = false;\n                    break;\n\n                case 'a':\n\n\n                    System.out.println(\"请输入要添加的数据\");\n                    int n = scanner.nextInt();\n                    try {\n                        cricleArrayQueue.addQueue(n);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                    break;\n\n                case 'g':\n                    try {\n                        int a = cricleArrayQueue.getQueue();\n                        System.out.printf(\"取出的数据为%d\\n\", a);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                    break;\n\n                case 'h':\n\n                    try {\n                        cricleArrayQueue.headQueue();\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                    break;\n\n                default:\n\n                    System.out.println(\"命令输入错误！\");\n                    break;\n\n            }\n\n\n        }\n\n    }\n\n    }\n      class   CricleArrayQueue{\n\n        //这是数组队列类\n\n        private int MaxSize; //数组的最大容量\n        private int front; //指向队头元素的前一个，默认为-1\n        private int rear;  //指向队尾元素，默认为-1\n        private int [] arr; //数组\n\n        public  CricleArrayQueue(int maxSize) {\n            MaxSize=maxSize;\n            arr=new int[MaxSize];\n            front=0;\n            rear=0;\n\n            //这样通过构造函数就可以创建指定大小的数组\n        }\n\n\n        //写方法\n\n        //判断是否为空\n\n        public boolean isEmpty(){\n\n            return  front==rear;//两者相等的话就说明为空\n        }\n\n        //判断是否为满\n\n        public  boolean isFull(){\n\n            return  (rear+1)%MaxSize==front; //环形对列的满条件\n        }\n\n        //添加队列\n        public  void  addQueue(int n){\n\n            //判断是否为满\n            if(isFull()){\n\n                System.out.println(\"队列已满，添加失败！\");\n                return;\n            }\n\n            //否则添加队列\n            //rear向后移\n            arr[rear]=n;\n\n            rear=(rear+1)%MaxSize;\n            System.out.println(\"添加成功了！\");\n        }\n\n        //取队列的数据(从头取)\n        public  int getQueue(){\n\n            //判断是否空\n            if(isEmpty()){\n\n                throw new RuntimeException(\"队列空，不能取数据\");\n\n            }\n            //否则\n            //front后移\n            int a=arr[front];\n\n            front=(front+1)%MaxSize;\n            //返回数据\n            return  a;\n\n        }\n\n        //显示队列的所有数据\n        public void showQueue(){\n\n            //判断是否空\n            if (isEmpty()){\n\n                System.out.println(\"队列为空，无法取出\");\n\n            }\n\n            for(int i=front;i<front+size();i++){\n\n                System.out.printf(\"arr[%d]=%d\\t\",i%MaxSize,arr[i%MaxSize]);\n\n            }\n\n        }\n\n        //查看队列的头元素\n        public  void headQueue(){\n            if (isEmpty()) {\n                System.out.println(\"队列为空，查看头信息失败！\");\n            }\n\n            System.out.println(arr[front]);\n\n        }\n\n        public  int size(){\n\n            //对列有效数据个数\n            return  (rear-front+MaxSize)%MaxSize;\n        }\n\n\n    }\n\n\n\n\n\n\n\n# 哎哟不错哦！\n\n\n\n\n","tags":["学习笔记"]}]